{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Accueil","text":""},{"location":"#objectif","title":"Objectif","text":"<p>Attention</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan, mis en forme par Mehdi et propuls\u00e9 avec le soutien de Nolan. Nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible et esthetique pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"#credits","title":"Cr\u00e9dits","text":"<p>Le site de notre professeur d'informatique,  Site originel</p>"},{"location":"#legende","title":"L\u00e9gende","text":""},{"location":"#theoremes","title":"Th\u00e9or\u00e8mes","text":"<p>Pour mettre en valeur un th\u00e9or\u00e8me, on utilise la syntaxe suivante :</p> <p>Th\u00e9or\u00e8me</p> <p>Lorem impsum</p> <pre><code>!!!danger \"\"\n    **Th\u00e9or\u00e8me**\n\n    Lorem impsum\n</code></pre>"},{"location":"#propostions","title":"Propostions","text":"<p>Pour mettre en valeur une proposition, on utilise la syntaxe suivante :</p> <p>Proposition</p> <p>Lorem impsum</p> <pre><code>!!!warning \"\"\n    **Proposition**\n\n    Lorem impsum\n</code></pre>"},{"location":"#corollaires","title":"Corollaires","text":"<p>Pour mettre en valeur un corollaire, on utilise la syntaxe suivante :</p> <p>Corollaire</p> <p>Lorem impsum</p> <pre><code>!!!quote \"\"\n    **Corollaire**\n\n    Lorem impsum\n</code></pre>"},{"location":"#definitions","title":"D\u00e9finitions","text":"<p>Pour mettre en valeur une d\u00e9finition, on utilise la syntaxe suivante :</p> <p>D\u00e9finition: Lorem</p> <p>Lorem impsum</p> <pre><code>!!!quote \"\"\n    **D\u00e9finition**\n\n    Lorem impsum\n</code></pre>"},{"location":"#preuves-demonstrations","title":"Preuves / D\u00e9monstrations","text":"<p>Pour mettre en valeur un preuve, on utilise la syntaxe suivante :</p> <p>Preuve</p> <p>Lorem impsum</p> <pre><code>!!!note \"\"\n    **Preuve**\n\n    Lorem impsum \n</code></pre>"},{"location":"#remarques-credits","title":"Remarques / Cr\u00e9dits","text":"<p>Pour mettre en valeur une remarque ou les cr\u00e9dits, on utilise la syntaxe suivante :</p> <p>Remarque/Credit</p> <p>Lorem impsum</p> <pre><code>!!!tip \"\"\n    **Remarque/Credit**\n\n    Lorem impsum\n</code></pre>"},{"location":"#exemples-exercices","title":"Exemples / Exercices","text":"<p>Pour mettre en valeur un exemple, on utilise la syntaxe suivante :</p> <p>Exemple</p> <p>Lorem impsum</p> <pre><code>!!!example \"\"\n    **Exemple**\n\n    Lorem impsum\n</code></pre> <p>Ou si l'exemple est trop long ou qu'il n'est pas forc\u00e9ment primordiale :</p> Exemple / Exercice <p>Lorem impsum t</p> <pre><code>???example \"Exemple / Exercice\"\n    Lorem \n    impsum\n    t\n</code></pre> <p>Si c'est un exercice, sa potentielle correction se fait comme ceci :</p> <p>Correction</p> <p>Bla bla bla</p> <pre><code>!!!tip \"Correction\"\n    Bla\n    bla\n    bla\n</code></pre>"},{"location":"#attention","title":"Attention","text":"<p>Pour mettre en valeur une attention, on utilise la syntaxe suivante :</p> <p>Attention</p> <p>Lorem impsum t</p> <pre><code>!!!warning \"Attention\"\n    Lorem \n    impsum \n    t\n</code></pre>"},{"location":"#danger","title":"Danger","text":"<p>Pour mettre en valeur un danger, on utilise la syntaxe suivante :</p> <p>Danger</p> <p>Lorem impsum t</p> <pre><code>!!!danger \"Danger\"\n    Lorem \n    impsum\n    t\n</code></pre>"},{"location":"#supplement","title":"Suppl\u00e9ment","text":"<p>On utilisera en plus, ceci, pour mettre en valeur un bloc d'id\u00e9e :</p> <p>Mon id\u00e9e trop g\u00e9niale</p> <ul> <li>Premier point</li> <li>Deuxi\u00e8me point<ul> <li>Sous point</li> <li>Sous point </li> </ul> </li> </ul> <pre><code>!!!note inline \"\"\n    Mon id\u00e9e trop g\u00e9niale\n\n    - Premier point\n    - Deuxi\u00e8me point\n        - Sous point\n        - Sous point\n</code></pre>"},{"location":"Algorithmique/1-Glouton/","title":"Algorithmes gloutons","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Algorithmique/1-Glouton/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":""},{"location":"Algorithmique/1-Glouton/#presentation","title":"Pr\u00e9sentation","text":"<p>Un algorithme glouton (greedy algorithm en anglais, parfois  appel\u00e9 aussi algorithme gourmand, ou goulu) est un  algorithme qui suit le principe de r\u00e9aliser, \u00e9tape par \u00e9tape, un  choix optimum local, afin d\u2019obtenir un r\u00e9sultat optimum  global (Wikipedia).  </p> <p>Exemples classiques</p> <ul> <li>Rendu de monnaie</li> <li>Coloration des sommets d\u2019un graphe</li> <li>Algorithme de Dijkstra pour la recherche de PCC ;  </li> </ul> <p>Un algorithme glouton fournit le plus souvent une solution au  probl\u00e8me. Dans les cas o\u00f9 il ne donne pas syst\u00e9matiquement  la solution optimale, il est appel\u00e9 une heuristique gloutonne.  </p> <p>Exemple d\u2019heuristique gloutonne</p> <p><p></p></p> <p>Un algorithme glouton peut retourner une solution sous-optimale.  </p> <p>En partant du point \\(A\\) et en cherchant \u00e0 monter selon la plus forte pente, un algorithme glouton trouvera le maximum local  \\(m\\), mais pas le maximum global \\(M\\).</p> <p>Il faut bien comprendre que m\u00eame si elle ne fournit pas toujours de solution optimale, une strat\u00e9gie gloutonne est souvent adopt\u00e9e en raison de la simplicit\u00e9 de sa mise en \u0153uvre.</p>"},{"location":"Algorithmique/1-Glouton/#exemple-du-rendu-de-monnaie","title":"Exemple du rendu de monnaie","text":""},{"location":"Algorithmique/1-Glouton/#presentation_1","title":"Pr\u00e9sentation","text":"<p>Soit un ensemble \\(C\\) (pour \"coins\") de \\(n\\) valeurs enti\u00e8res de billets et pi\u00e8ces de monnaies \\(v_1 &lt; v_2 &lt; \u00b7\u00b7\u00b7 &lt; v_n\\). Par exemple  \\(C =\\text{ {1\u20ac, 2\u20ac, 5\u20ac, 10\u20ac, 20\u20ac, 100\u20ac, 200\u20ac}}\\)</p> <p>Le probl\u00e8me du rendu de monnaie consiste \u00e0 d\u00e9terminer le  nombre minimal de billets et de pi\u00e8ces pour rendre une somme donn\u00e9e. Par exemple, la somme de \\(49\\)\u20ac peut \u00eatre rendue en utilisant \\(49\\) pi\u00e8ces de \\(1\\)\u20ac, ou \\(2\\) billets de \\(20\\)\u20ac, \\(1\\) billet de \\(5\\)\u20ac et \\(2\\) pi\u00e8ces de \\(2\\)\u20ac. Donc \\(5\\) billets/pi\u00e8ces rendues VS \\(49\\). Ce nombre \\(5\\) est  d\u2019ailleurs le plus petit qu\u2019on puisse trouver pour le syst\u00e8me de pi\u00e8ces \\(C\\).  </p>"},{"location":"Algorithmique/1-Glouton/#precisions","title":"Pr\u00e9cisions","text":"<p>Pour raison de concision, nous emploierons dans toute la suite  le terme \"pi\u00e8ce\" au lieu de \"pi\u00e8ce ou billet\".</p> <p>De plus nous supposons que le stock de chaque valeur de pi\u00e8ce est illimit\u00e9, ce qui ne re\ufb02\u00e8te que partiellement la r\u00e9alit\u00e9 (dans un \\(DAB\\), il y a un nombre fini de billets de \\(10\\),\\(20\\),\\(50\\) et \\(100\\)\u20ac).</p> <p>La solution calcul\u00e9e par l\u2019algorithme que nous pr\u00e9sentons et  donc une solution th\u00e9orique qui ne tient pas compte de la r\u00e9alit\u00e9 du stock.  </p>"},{"location":"Algorithmique/1-Glouton/#strategie","title":"Strat\u00e9gie","text":"<p>On choisit d\u2019abord les pi\u00e8ces qui permettent de rendre la plus  grande valeur possible sur la somme \u00e0 rendre. Dans l\u2019exemple des \\(49\\)\u20ac, il s\u2019agit de deux billets de \\(20\\)\u20ac.</p> <p>Il reste alors \u00e0 rendre \\(9\\)\u20ac. On choisit la plus grande valeur de  pi\u00e8ce plus petite que \\(9\\), soit \\(5\\)\u20ac. On rend donc un billet de \\(5\\) (et pas \\(2\\) car \\(2 \u00d7 5 &gt; 9\\)). Enfin la plus grande valeur de pi\u00e8ce plus petite que les \\(4\\)\u20ac \u00e0 rendre est \\(2\\)\u20ac. On peut en rendre deux, ce qui ram\u00e8ne la somme \u00e0 rendre \u00e0 \\(0\\)\u20ac. On s\u2019arr\u00eate donc l\u00e0.  </p>"},{"location":"Algorithmique/1-Glouton/#code","title":"Code","text":"<pre><code>let greedy_change (coins:int array) (v:int): int array =\n    let n = Array.length coins in\n    let change = Array.make n 0 in\n    let cur = ref v and i = ref (n-1) in\n    while !cur &gt; 0 do\n        let c = coins.(!i) in\n        if !cur &lt; c then decr i\n        else (\n            change.(!i) &lt;- change.(!i)+1;\n            cur := !cur - c\n        )\n    done ;\n    change ;;\n</code></pre> <p>Param\u00e8tres et variables</p> <p>Param\u00e8tres :  </p> <ul> <li><code>coins</code> : tableau des valeurs de pi\u00e8ces avec <code>t.(0)=1</code> </li> <li><code>v</code> : valeur \u00e0 rembouser  </li> </ul> <p>Variables locales :  </p> <ul> <li><code>!i</code> : num\u00e9ro de la valeur courante de pi\u00e8ce</li> <li><code>change.(!i)</code> : nb de pi\u00e8ces de la valeur courante  </li> <li><code>!cur</code> : somme restant \u00e0 rendre.  </li> </ul>"},{"location":"Algorithmique/1-Glouton/#correction-du-programme","title":"Correction du programme","text":"<p>Un variant de boucle est <code>!cur + !i</code>. Terminaison OK.  </p> <p>La condition \\(t_0 = 1\\) assure la correction (principe : apcr, on  peut rendre autant de pi\u00e8ces de \\(1\\)\u20ac que la somme restante). Le fait que \\(t_0 = 1\\), assure que <code>!i \u2265 0</code> et donc l\u2019acc\u00e8s valide  au tableau <code>coins</code>.  </p>"},{"location":"Algorithmique/1-Glouton/#optimalite","title":"Optimalit\u00e9","text":"<p>Proposition</p> <p>Si <code>coins</code> d\u00e9crit le syst\u00e8me mon\u00e9taire de la zone euro, alors le programme <code>greedy_change</code> cacule un rendu de monnaie avec le nombre minimal d\u2019\u00e9l\u00e9ments.  </p> <p>Remarque</p> <p>Un syst\u00e8me de pi\u00e8ces qui, tel celui de la zone euro, permet un rendu optimal est qualifi\u00e9 de canonique.  </p> <p>Preuve</p> <p>Certaines combinaison de pi\u00e8ces ne peuvent se trouver dans une solution optimale :</p> <ul> <li> <p>Une pi\u00e8ce de valeur val \\(= 1,5,10,50\\) ou \\(100\\) n\u2019est jamais utilis\u00e9 deux fois dans une solution optimale. En e\ufb00et, pour chacune de ces valeurs il est plus avantageux de rendre une pi\u00e8ce de valeur 2val plut\u00f4t que deux de valeur val.</p> </li> <li> <p>Une pi\u00e8ce de valeur \\(2\\) ou \\(20\\) n\u2019est jamais utilis\u00e9e \\(3\\) fois dans une solution optimale. En e\ufb00et \\(3\\) pi\u00e8ces de valeur \\(2\\) sont avantageusement remplac\u00e9e par par une pi\u00e8ce de valeur \\(1\\) et une de \\(5\\) ; \\(3\\) pi\u00e8ces de valeur \\(20\\) sont remplac\u00e9es par une \\(10\\) et une de \\(50\\).</p> </li> <li> <p>Une pi\u00e8ce de valeur \\(1\\) n\u2019accompagne jamais deux pi\u00e8ces de valeur \\(2\\) : on pourrait remplacer l\u2019ensemble par une pi\u00e8ce de \\(5\\). Une pi\u00e8ce de valeur \\(10\\) n\u2019accompagne jamais deux pi\u00e8ces de valeur \\(20\\) : on pourrait remplacer l\u2019ensemble par une pi\u00e8ce de \\(50\\).  </p> </li> </ul> <p>Exercice</p> <p>Ecrivons un petit programme qui prend en compte les  contraintes pr\u00e9c\u00e9dentes et faisons le tourner pour explorer  exhaustivement toutes les combinaisons possibles de pi\u00e8ces de  moins de \\(200\\)\u20ac. </p> <p>Correction</p> <p>La correction ci-dessous est longue, mais est int\u00e9ressante \u00e0 lire car c'est un alogrithme de backtracking assez simple \u00e0 comprendre.</p> Correction longue <pre><code>let greedy_change (coins:int array) (v:int) : int array =\n    let n = Array.length coins in\n    let change = Array.make n 0 in\n    let cur = ref v and i = ref (n-1) in\n    while !cur &gt; 0 do\n        let c = coins.(!i) in\n        if !cur &lt; c then decr i\n        else (\n            change.(!i) &lt;- change.(!i)+1;\n            cur:=!cur -c\n        )\n    done;\n    change;;\n\nlet coins  = [|1;2;5;10;20;50;100|];;\nlet nb_max =  [|1;2;1;1;2;1;1|];;\n\nlet contraint3 t =\nif t.(0)=1 &amp;&amp; t.(1) = 2\nthen false\nelse (if t.(3)=1 &amp;&amp; t.(4) = 2\nthen false else true);;\n\nlet value t =\nlet n= Array.length t in\nlet s = ref 0 in\nfor i = 0 to n-1 do\n    s :=\n    !s + t.(i) * coins.(i)\ndone; !s ;;\n\nvalue nb_max ;;\n\nlet maximum tab =\nlet j = ref 0 and n = Array.length tab in\nfor k= 1 to n-1 do\n    if snd tab.(k) &gt; snd tab.(!j) then j:=k;\ndone;\ntab.(!j);;\n\nlet check () =\nlet rec aux i acc =\n    match i with\n    | x  when x&lt;7 -&gt; explore i acc\n    |  _ -&gt; (*i=7*) let newacc = List.rev acc in\n                    let t = Array.of_list newacc in\n                    let v = value t in\n                    if contraint3 t then t,v\n                    else (Array.make 0 7), 0\nand explore i acc = \n    let nb = nb_max.(i) in\n    let tab = Array.make (nb+1) ([||],0) in\n    for j = 0 to nb do\n    tab.(j) &lt;- aux (i+1) (j::acc);\n    done; maximum tab\nin aux 0 [];;\n\ncheck();;\n\nlet coins  = [|1;2;5;10;20;50;100|];;\n(*contraintes 1 et 2*)\nlet nb_max =  [|1;2;1;1;2;1;1|];;\n\n(*3 tableaux de choix de pi\u00e8ces et 3 valeurs associ\u00e9es On renvoie le\ntuple t,v dont v est le plus grand\n*)\nlet maxi t1 v1 t2 v2 t3 v3 =\nlet v = max v1 (max v2 v3) in\nif v = v1 then t1,v1 else\n    (if v = v2 then t2,v2 else t3, v3);;\n\nlet check () =\nlet contraint3 t =\n    if t.(0)=1 &amp;&amp; t.(1) = 2\n    then false\n    else (if t.(3)=1 &amp;&amp; t.(4) = 2\n        then false else true)\nin let rec aux i acc = match i with\n        | x  when x&lt;7 &amp;&amp; nb_max.(i) = 1 -&gt;\n        let t1,v1 = aux (i+1) (0::acc)\n        in let  t2,v2 = aux (i+1) (1::acc) in\n        if v1&lt;v2 then t2,v2 else t1,v1\n        |  x when x&lt;7 &amp;&amp; nb_max.(i) = 2 -&gt;\n        let t1,v1 = aux (i+1) (0::acc)\n        in let t2,v2 = aux (i+1) (1::acc) in\n        let t3,v3 = aux (i+1) (2::acc) in\n        let v =  max v1 (max v2 v3) in\n        if v = v1 then t1,v1 else\n            (if v = v2 then t2,v2 else t3, v3)\n        |  _ -&gt; (*i=7*)\n        let newacc = List.rev acc in\n        let t = Array.of_list newacc in\n        let v = value t in\n        if contraint3 t then t,v\n        else (Array.make 7 0), 0\nin aux 0 [];;\n\ncheck();;\n</code></pre> <p>Explication On constate que la plus grande somme possible remboursable  avec ces pi\u00e8ces est  </p> \\[2 \u00d7 2 + 5 + 2 \u00d7 20 + 50 + 100 = 199\\] <p>Ainsi, la solution optimale ne pourra JAMAIS rembourser plus  de \\(199\\)\u20ac avec des pi\u00e8ces de moins de \\(200\\)\u20ac. Dit autrement,  la solution optimale doit rembourser toute somme \\(S &gt; 200\\)\u20ac avec le maximum possible de pi\u00e8ces de \\(200\\)\u20ac (qui est en fait  \\(k = S/200\\)). Or, notre algorithme calcule exactement \\(k\\).  </p> <p>Pour une somme inf\u00e9rieure \u00e0 \\(199\\)\u20ac reprenons notre petit  programme et faison le tourner pour trouver le nombre  maximum de pi\u00e8ces de moins de \\(100\\) euros.  </p> <p>On trouve alors que la solution optimale ne peut rembourser  qu\u2019une somme de \\(99\\)\u20ac avec ces pi\u00e8ces. Pour rembourser  une somme entre entre \\(100\\)\u20ac et \\(199\\)\u20ac, il faut un billet de \\(100\\)\u20ac.</p> <p>C\u2019est exactement la quantit\u00e9 que trouve notre programme dans ce cas l\u00e0!</p> <p>etc.</p>"},{"location":"Algorithmique/2-Prodgyn/","title":"Programmation dynamique","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Algorithmique/2-Prodgyn/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"Algorithmique/2-Prodgyn/#introduction","title":"Introduction","text":"<p>La r\u00e9solution d\u2019un probl\u00e8me peut parfois se faire en le d\u00e9composant en  sous-probl\u00e8mes. Dans cette approche, les solutions aux sous-probl\u00e8mes sont ensuite combin\u00e9es pour construire la solution au probl\u00e8me initial.  </p> <ul> <li>si les sous-probl\u00e8mes sont ind\u00e9pendants les uns des autres (exemple :  d\u00e9composition en sous-ensembles disjoints comme pour le tri fusion),  on parle de m\u00e9thode diviser pour r\u00e9gner</li> <li>si les sous-probl\u00e8mes sont d\u00e9pendants (exemple : si un m\u00eame calcul -avec les m\u00eames param\u00e8tres- est fait par chaque sous-probl\u00e8me), on parle de programmation dynamique.  </li> </ul>"},{"location":"Algorithmique/2-Prodgyn/#historique","title":"Historique","text":"<p>D\u00e9finition : Programmation dynamique</p> <p>Processus de r\u00e9solution de probl\u00e8mes o\u00f9 on trouve les meilleures d\u00e9cisions les unes apr\u00e8s les autres.  </p> <p>Le terme \u00e9tait utilis\u00e9 par le math\u00e9maticien Richard Bellman d\u00e8s les ann\u00e9es 40.  </p> <p>En 1953, Bellman en donne la d\u00e9finition moderne, o\u00f9 les d\u00e9cisions \u00e0  prendre sont ordonn\u00e9es par sous-probl\u00e8mes. Le domaine a alors \u00e9t\u00e9 reconnu par l\u2019Institute of Electrical and  Electronics Engineers (IEEE) comme un sujet d\u2019analyse de syst\u00e8mes et  d\u2019ing\u00e9nierie.  </p>"},{"location":"Algorithmique/2-Prodgyn/#diviser-pour-regner","title":"Diviser pour r\u00e9gner","text":"<p>La m\u00e9thode Diviser pour r\u00e9gner est un cas particulier de  programmation dynamique. On d\u00e9compose encore un probl\u00e8me principal en sous-probl\u00e8mes.  Cependant, les sous-probl\u00e8mes sont ici ind\u00e9pendants les uns des autres  ce qui facilite la t\u00e2che du programmeur.  </p> <p>Principe</p> <p>On divise en r\u00e9duisant un probl\u00e8me en sous-probl\u00e8mes du m\u00eame type et  qui ne se chevauchent pas. Puis on r\u00e8gne en r\u00e9solvant ces sous-probl\u00e8mes.  Il reste \u00e0 rassembler les solutions des sous-probl\u00e8mes pour obtenir une  soution au probl\u00e8me initial.  </p>"},{"location":"Algorithmique/2-Prodgyn/#cadre-dapplication","title":"Cadre d\u2019application","text":"<p>La programmation dynamique est envisag\u00e9e si le probl\u00e8me pr\u00e9sente la propri\u00e9t\u00e9 de sous-structure optimale et si les chevauchements de sous-probl\u00e8mes doivent \u00eatre g\u00e9r\u00e9s.</p>"},{"location":"Algorithmique/2-Prodgyn/#vocabulaire","title":"Vocabulaire","text":"<p>D\u00e9finition: Sous-structure optimale</p> <p>Se dit d\u2019un probl\u00e8me qu\u2019on peut r\u00e9soudre en le d\u00e9composant en sous-probl\u00e8mes du m\u00eame type,  eux-m\u00eames r\u00e9solubles r\u00e9cursivement.</p> <p>D\u00e9finition: Chevauchement de sous-probl\u00e8mes</p> <p>Se dit si des sous-probl\u00e8mes ne sont pas ind\u00e9pendants et doivent \u00eatre r\u00e9solus plusieurs  fois.</p> <p>En g\u00e9n\u00e9ral on envisage tous les sous-probl\u00e8mes comme dans une  recherche exhaustive mais on prend ses pr\u00e9cautions pour ne pas avoir \u00e0  les r\u00e9soudre tous :  </p> <ul> <li>soit parce que certains sont inutiles (ex : recherche dichotomique)  </li> <li>soit parce qu\u2019ils ont d\u00e9j\u00e0 \u00e9t\u00e9 rencontr\u00e9s et r\u00e9solus (ex : m\u00e9morisation  dans le calcul des suites de Fibonacci)  </li> </ul>"},{"location":"Algorithmique/2-Prodgyn/#principe-doptimalite","title":"Principe d\u2019optimalit\u00e9","text":"<p>La programmation dynamique s\u2019applique \u00e0 des probl\u00e8mes  d\u2019optimisations : il s\u2019agit souvent d\u2019optimiser le co\u00fbt d\u2019une suite de  d\u00e9cisions.</p> <p>Cette suite de d\u00e9cisions correspond \u00e0 un d\u00e9coupage du probl\u00e8me en  sous-probl\u00e8mes :  </p> <ul> <li>On calcule les solutions optimales successives comme pour un algorithme glouton \u00e0 des sous probl\u00e8mes li\u00e9s par une relation de r\u00e9currence.  </li> <li>Puis, c\u2019est la combinaison de ces solutions qui produit la solution au  probl\u00e8me initial.  </li> </ul> <p>Principe d\u2019optimalit\u00e9 de Bellman : une solution optimale pour un probl\u00e8me pr\u00e9sentant la propri\u00e9t\u00e9 de sous-structure optimale est la combinaison de solutions optimales locales pour les sous-probl\u00e8mes.  </p>"},{"location":"Algorithmique/2-Prodgyn/#programmation-dynamique-et-graphes","title":"Programmation dynamique et graphes","text":"<ul> <li>Un th\u00e9or\u00e8me g\u00e9n\u00e9ral \u00e9nonce que tout algorithme de programmation dynamique peut se ramener \u00e0 la recherche du plus court chemin dans un graphe.  </li> <li>Or, les techniques de recherche heuristique bas\u00e9es sur l\u2019algorithme \\(A^*\\) permettent d\u2019exploiter les propri\u00e9t\u00e9s sp\u00e9cifiques d\u2019un probl\u00e8me pour gagner en temps de calcul.  </li> <li>Autrement dit, il est souvent plus avantageux d\u2019exploiter un algorithme \\(A^*\\) que d\u2019utiliser la programmation dynamique.  </li> </ul>"},{"location":"Algorithmique/2-Prodgyn/#exemples","title":"Exemples","text":""},{"location":"Algorithmique/2-Prodgyn/#suites-de-fibonacci","title":"Suites de Fibonacci","text":"<p>Voir TD d\u00e9di\u00e9.  </p>"},{"location":"Algorithmique/2-Prodgyn/#definition","title":"D\u00e9finition","text":"<p>On appelle suite de Fibonacci toute suite r\u00e9elle ou complexe \\((f_n)_{n\u2208N}\\) r\u00e9currente d\u2019ordre 2 d\u00e9finie par \\(f_{n+2} = f_{n+1} + f_n\\) pour tout \\(n \u2208 N\\). Souvent \\(f_0 = 0, f_1 = 1\\), c\u2019est ce que nous prendrons par la suite.</p>"},{"location":"Algorithmique/2-Prodgyn/#premiere-implementation","title":"Premi\u00e8re impl\u00e9mentation","text":""},{"location":"Algorithmique/2-Prodgyn/#code","title":"Code","text":"<p>On peut proposer le code suivant :</p> <pre><code>let rec fib n = \n    match n with \n    | 0 | 1 -&gt; n \n    | _ -&gt; (fib (n-1)) + (fib (n-2));;\n</code></pre>"},{"location":"Algorithmique/2-Prodgyn/#calcul-de-f_5","title":"Calcul de \\(f_5\\)","text":"<p>On constate que \\(f_2\\) est calcul\u00e9 3 fois.</p>"},{"location":"Algorithmique/2-Prodgyn/#complexite","title":"Complexit\u00e9","text":"<p>Si \\(C (n)\\) est la complexit\u00e9 pour calculer \\(f_n\\) , alors     \\(C (n) = C (n \u2212 1) + C (n \u2212 2) \u2265 2C (n \u2212 2)\\) en admettant que la complexit\u00e9 soit croissante On obtient que \\(C (n) \u2265 2^{\\frac{n}{2}} \\times max(C (0), C (1)) \u2265 2^{\\frac{n}{2} -1} \u2265 \\frac{1}{2}(\\sqrt{2})^n\\) Complexit\u00e9 au moins exponentielle. De la m\u00eame fa\u00e7on, on peut majorer \\(C (n)\\) par \\(2^n\\). La complexit\u00e9 n\u2019est pas \\(\"\\)plus\\(\"\\) qu\u2019exponentielle.</p>"},{"location":"Algorithmique/2-Prodgyn/#fibonnaci-memorisation","title":"Fibonnaci : m\u00e9morisation","text":""},{"location":"Algorithmique/2-Prodgyn/#approche-descendante","title":"Approche descendante","text":"<p>M\u00e9morisation :</p> <ul> <li>On m\u00e9morise une valeur de la suite si c\u2019est la premi\u00e8re fois qu\u2019on la rencontre.</li> <li>Si on a d\u00e9j\u00e0 rencontr\u00e9 le calcul courant, on r\u00e9cup\u00e8re sa valeur par un acc\u00e8s \u00e0 la structure de stockage en O(1)</li> <li>On ne lance le calcul que si la valeur voulue n\u2019a pas d\u00e9j\u00e0 \u00e9t\u00e9 calcul\u00e9e.</li> </ul> <p>Approche descendante : On commence par lancer les calculs pour les valeurs de param\u00e8tres les plus grands. Ces calculs induisent des appels avec des param\u00e8tres plus petits.</p> <p>Dans le cas qui nous occupe, le calcul de f (n) am\u00e8ne \u00e0 g\u00e9rer un tableau de \\(n + 1\\) cases dont la case \\(i\\) contient \u22121 (pas encore calcul\u00e9) ou \\(f (i)\\) (calcul d\u00e9j\u00e0 rencontr\u00e9).</p> <p>Mais ici, un tableau n\u2019est pas n\u00e9cessaire : il suffit de m\u00e9moriser les 2 derni\u00e8res valeurs.</p>"},{"location":"Algorithmique/2-Prodgyn/#partition-equilibree-dun-tableau-dentiers-positifs","title":"Partition \u00e9quilibr\u00e9e d'un tableau d'entiers positifs","text":""},{"location":"Algorithmique/2-Prodgyn/#presentation-du-probleme","title":"Pr\u00e9sentation du probl\u00e8me","text":"<p>On dispose d\u2019un (multi) ensemble d\u2019entiers positifs \\(E\\).</p> <p>On souhaite d\u00e9terminer une partition de \\(E\\) en deux sous-ensembles \\(E_1, E_2\\) tels que  </p> <ul> <li> <p>\\(E_1 \\cup E_2 = E\\); \\(E_1 \\cap E_2 = \\emptyset\\) (partition)</p> </li> <li> <p>La somme des \u00e9l\u00e9ments de \\(E_1\\) et celle de \\(E_2\\) sont les plus proches possibles. Cela signifie que</p> </li> </ul> \\[ |\\sum_{x \\in E_1} x - \\sum_{y \\in E_2} y| = \\newline min(\\ \\{ |\\sum_{x \\in E'} x - \\sum_{y \\in E''} y| \\text{ avec (E', E'') une partition de E} \\ \\}) \\] <p>On note \\(S\\) la somme des \u00e9l\u00e9ments de \\(E\\) et \\(S(A)\\) la somme des \u00e9l\u00e9ments d\u2019un sous-ensemble \\(A\\). \\(S/2\\) d\u00e9signe la division euclidienne de \\(S\\) par \\(2\\).  </p>"},{"location":"Algorithmique/2-Prodgyn/#approche-gloutonne","title":"Approche gloutonne","text":"<p>Pour  \\(E = \\{e, . . . , e_n\\}\\) : On g\u00e8re deux sous-ensembles \\(E_1\\), \\(E_2\\) initialis\u00e9s resp. en {\\(e_1\\)}, \\(\u2205\\).  </p> <p>On place les \u00e9l\u00e9ments suivants dans \\(E\\) un \u00e0 un jusqu\u2019\u00e0 ce que \\(S(E_2) &gt; S(E_1)\\). Les \u00e9l\u00e9ments suivants sont alors plac\u00e9s dans \\(E_1\\) etc.  </p> <p>Malheureusement, m\u00eame en triant les \u00e9l\u00e9ments de E , la solution  fournie n\u2019est pas toujours optimale.</p> <p>Exercice</p> <p>Implanter cet algorithme. Donner sa complexit\u00e9. Exhiber un exemple o\u00f9 la solution n\u2019est pas optimale.</p> <p>Correction</p> <p><pre><code>let greedy_partition e =\n    let rec aux l l1 l2 s1 s2 =\n        match l with\n        | [] -&gt; l1, l2\n        |x::q -&gt; if x + s1 &lt; s2 then\n                aux q (x::l1) l2 (s1+x) s2\n            else aux q (x::l2) l1 (s2+x) s1\n    in match e with\n        | [] -&gt; [], []\n        | x::q -&gt; aux q [x] [] x 0\n;;\n</code></pre> \\(C(n) = 2\\times C(n-1) + ... \\text{ donc }  C(n)\\text{ est en }O(2^n)\\)</p>"},{"location":"Algorithmique/2-Prodgyn/#algorithme-base-sur-la-demi-somme","title":"Algorithme bas\u00e9 sur la demi-somme","text":"<p>On dispose d\u2019un ensemble d\u2019entiers positifs \\(E\\) . Si \\(E_1\\) et \\(E_2\\) r\u00e9alisent une partition \u00e9quilibr\u00e9e de \\(E\\) , quitte \u00e0 les \u00e9changer, on peut supposer \\(S(E_1) \u2264 S(E_2)\\)</p> <p>Comme \\(S(E_1) + S(E_2) = S\\), on a \\(S(E_1) \u2264 \\frac{S}{2} \\leq S(E_2)\\) les \u00e9l\u00e9ments sont entiers, on obtient \\(S(E_1) \u2264 (S/2) \u2264 S(E_2)\\).  </p>"},{"location":"Algorithmique/2-Prodgyn/#distance-a-la-demi-somme","title":"Distance \u00e0 la demi-somme","text":"<p>Soit \\(A \u2282 E\\) tel que :  </p> \\[|S/2 - \\sum_{a\\in A} a| = min(\\{|S/2 - \\sum_{x \\in X} x| \\text{ avec } X \\subset E\\})\\] <p>Si \\(S(A) \u2264 S/2\\), soit \\((F, G)\\) partition de \\(E\\) telle que \\(S(F) \u2264 S(G)\\). Alors \\(S(F) \u2264 S/2\\).  </p> <p>Puisque \\(A\\) r\u00e9alise la meilleure distance \u00e0 \\(S/2\\) : $$S(F ) \u2264 S(A) \\text{ et } S(E \\setminus A) \u2264 S(G) $$ Et donc \\(|S(E \\backslash A) \u2212 S(A)| \u2264 |S(G ) \u2212 S(F )|\\)</p> <p>De m\u00eame si \\(S(A) \u2265 S/2\\). On en d\u00e9duit que \\(\\color{red}(A, E \\backslash A) \\text{ r\u00e9alise une  partition \u00e9quilibr\u00e9e de } E.\\) </p>"},{"location":"Algorithmique/2-Prodgyn/#solution-par-programmation-dynamique","title":"Solution par programmation dynamique","text":""},{"location":"Algorithmique/2-Prodgyn/#methode-descendante","title":"M\u00e9thode descendante","text":"<p>On cherche (\\(E_1\\), \\(E_2\\)), partition \u00e9quilibr\u00e9e de \\(E\\) La remarque \\(2\\) du slide pr\u00e9c\u00e9dent sugg\u00e8re de travailler avec</p> <ul> <li>la demi-somme des \u00e9l\u00e9ments de \\(E\\) et</li> <li>l\u2019ensemble \\(E_1\\) (puisqu\u2019on trouve  alors \\(E_2\\) facilement).</li> </ul> <p>Agorithme r\u00e9cursif : On g\u00e8re un ensemble \\(E\\) et la demi-somme \\(S/2\\) des \u00e9l\u00e9ments de \\(E\\). On cherche \u00e0 construire \\(E_1\\). Prendre \\(e \u2208 E\\) et calculer la distance \\(|S(E_1) \u2212 S|\\) dans \\(2\\) cas :  </p> <ul> <li>\\(\\color{red}{\\text{En mettant }e\\text{ dans }E_1}\\). Cela revient \u00e0 ajouter \\(e\\) \u00e0 la solution au probl\u00e8me  lorsque \\(E = E \\backslash \\{e\\}\\) et \\(S' = S/2 \u2212 e\\)</li> <li>\\(\\color{red}{\\text{En ne mettant pas }e\\text{ dans }E_1}\\). On calcule la solution au probl\u00e8me lorsque \\(E \\backslash \\{e\\}\\) et \\(S/2\\) est inchang\u00e9.  </li> </ul> <p>Choisir la meilleure des \\(2\\) options : celle qui am\u00e9liore la distance de la  somme des \u00e9l\u00e9ments de \\(E_1\\) \u00e0 la demi-somme \\(S/2\\).</p> <p>Exercice</p> <p>Les multi-ensemble de nombres sont impl\u00e9ment\u00e9s par des listes. 1. Ecrire une fonction <code>partition : int list -&gt; int list</code> qui  renvoie un ensemble \\(A \u2282 E\\) telle que \\(|S(A) \u2212 S/2|\\) soit minimal. On ne cherche pas \u00e0 m\u00e9moriser les r\u00e9sultats interm\u00e9diaires. 2. Estimer la complexit\u00e9 (on peut se contenter de la minorer) en fonction de \\(|E|\\).  </p> <p>Correction</p> <p><pre><code>let sum = List.fold_left (+) 0;;\nlet rec _part e s =\n    match e with\n    | [] | [_] -&gt; e\n    | x::q -&gt; \n        let p1, p2 = _part q (s-x), _part q s in\n        let s1 = x + sum p1 and s2 = sum p2 in\n        if abs (s1 -s) &lt; abs (s2 -s) then x::p1\n        else p2;;\nlet partition_brut e =\n    let s = sum e in\n    _part e (s/2);;\n</code></pre> \\(C(n) &gt;= 2\\times C(n-1) + n-1 &gt;= 2\\times(n-1)\\newline \\text{ Donc la complexit\u00e9 est exponentielle !}\\)</p>"},{"location":"Algorithmique/2-Prodgyn/#methode-ascendante-avec-tableau-de-bouleen","title":"M\u00e9thode ascendante avec tableau de boul\u00e9en","text":"<p>\\(E = \\{e_0, . . . , e_{n\u22121}\\}\\), multi-ensemble de nombres entiers positifs, \\(S = \\sum_{e \\in E} e\\) et \\(|E| = n\\).  </p> <ul> <li>On construit une matrice de boul\u00e9ens \\(T\\) de taille \\((n + 1) \u00d7 (S + 1)\\) </li> <li>On fait en sorte que le coefficient \\(T_{i,j}, (i \u2265 0, j \u2265 0)\\) soit vrai si et seulement si il existe un sous-ensemble de \\(\\{e_k | k \u2264 i \u2212 1\\}\\) dont la somme des \u00e9l\u00e9ments vaut \\(j\\).  </li> <li>On cherche une relation de r\u00e9currence qui construit \\(T_{i,j}\\) connaissant les \\(T_{i',j'}\\) pour \\((i', j') &lt; (i, j)\\) au sens lexicographique.  </li> </ul> <p>\\(E = \\{e_0 , . . . , e_{n\u22121} \\}\\), multi-ensemble de nombres entiers positifs \\((|E | = n)\\). - Ligne \\(0\\) : Pour \\(k \u2265 0\\), \\(T_{0,k}\\) d\u00e9signe la possibilit\u00e9 pour que la somme  des \u00e9l\u00e9ments de l\u2019ensemble \\(\\{e_k | k \u2264 0 \u2212 1\\} = \u2205\\) vale \\(k\\). Ainsi \\(T_{0,k}\\) est faux sauf si \\(k = 0\\). - Pour \\(i \u2265 0\\), \\(T_{i+1, j}\\) est vrai si et seulement si il existe un sous-ensemble  de \\(\\{e, . . . , e_i \\}\\) dont la somme des \u00e9l\u00e9ments vaut \\(j\\). Ceci se d\u00e9compose en :     - Ou bien il existe un sous-ensemble de \\(\\{e, . . . , e_{i-1} \\}\\) dont la somme des  \u00e9l\u00e9ments vaut j. Ceci est \u00e9quivalent \u00e0 \"\\(T_{i,j}\\text{ est vrai }\\)\".     - Ou bien, il existe un sous-ensemble de\\(\\{e, . . . , e_{i-1} \\}\\) dont la somme des  \u00e9l\u00e9ments vaut j \u2212 \\(e_i\\) (chose impossible si \\(j &lt; e_i\\) ).      Ceci est \u00e9quivalent \u00e0  \"\\(T_{i,j\u2212e_i}\\text{ est vrai }\\)\" lorsque \\(j \u2265 e_i\\) . - Relation de r\u00e9currence : pour \\(i \u2265 1, j \u2265 0\\), \\(T_{i+1,j}\\) est \u00e9quivalent \u00e0 :  \\(\\color{red}{T_{i,j}\\text{ ou } (j \u2265 e_i\\text{ et }T_{i,j\u2212e_i})}\\)</p>"},{"location":"Algorithmique/2-Prodgyn/#code-construction-du-tableau-de-bouleens","title":"Code : construction du tableau de boul\u00e9ens","text":"<p>Exercice</p> <p>Ecrire la fonction <code>tableau : int array -&gt; bool array array * int</code> telle que <code>tableau e</code> renvoie le tuple \\((T, m)\\) o\u00f9 \\(T\\) est d\u00e9crit au transparent pr\u00e9c\u00e9dent et \\(m\\) est la plus grande somme d\u2019\u00e9l\u00e9ments de \\(E\\) plus petite que \\(S/2\\). \u00c9valuer la complexit\u00e9 de votre fonction.  </p> <p>Correction (\u00e0 priori \u00e7a fonctionnne)</p> <pre><code>let sum = Array.fold_left (+) 0;;\nlet tableau e =\nlet n = Array.length e in\nlet s = sum e in\nlet t = Array.make_matrix (n+1) (s/2+1) false in\nt.(0).(0) &lt;- true;\nfor i = 1 to n do\n    for j =0 to s/2 do\n    t.(i).(j) &lt;-\n        t.(i-1).(j) ||\n        (j &gt;= e.(i-1) &amp;&amp; t.(i-1).(j-e.(i-1)));  \n    done;\ndone;\nlet m = ref (s/2) in\nwhile not t.(n).(!m) do\n    decr m;\ndone;\nt, !m;;\n</code></pre>"},{"location":"Algorithmique/2-Prodgyn/#construction-de-la-partition-equilibree","title":"Construction de la partition \u00e9quilibr\u00e9e","text":"<p>Une fois trouv\u00e9s le tableau de boul\u00e9ens \\(T\\) et la somme \\(m\\), on construit \\(E_1\\)  r\u00e9cursivement en lui ajoutant ou pas l\u2019\u00e9l\u00e9ment courant. On part de \\(T_{n,m}\\) (qui est Vrai) et \\(E_1 = \u2205\\). On parcourt une suite \\((T_{i,m_i})_{i=n,n-1,...1}\\) de coe\ufb03cients avec \\(m_i\\) \\(\u2193\\) et \\(m_n = m\\). C\u2019est donc une suite dont les indices sont positifs et d\u00e9croissants  strictement au sens lexicographique, ce qui assure la terminaison de la r\u00e9cursion. </p> <p>Invariant \"\\(T_{i,m_i} \\text{ est vrai}\\)\". Crit\u00e8re de d\u00e9placement dans la matrice :  </p> <ul> <li>Si \\(T_{i\u22121,m_i}\\) est vrai, alors on peut trouver un sous-ensemble de  \\(\\{e, . . . , e_{i\u22122}\\}\\) qui a pour somme \\(m_i\\) . Donc \\(E_1\\) peut ne pas contenir  \\(e_{i\u22121}\\) : il reste inchang\u00e9.  </li> <li>Sinon c\u2019est que \\(T_{i\u22121,m_i\u2212e_i\u22121}\\) est vrai. On peut trouver un sous-ensemble  de \\(\\{e, . . . , e_{i\u22122}\\}\\) qui a pour somme \\(m \u2212 e_{i\u22121}\\). On ajoute donc \\(e_{i\u22121}\\) \u00e0 \\(E_1\\).  </li> </ul> <p>Exercice</p> <p>Ecrire la fonction <code>partitition : int array -&gt; int array</code> telle que <code>partitition e</code> renvoie sous forme de tableau l\u2019ensemble \\(E_1\\). Donner sa complexit\u00e9.</p> <p>Correction donn\u00e9 par Mat\u00e9o</p> <pre><code>let partitition e =\nlet n = Array.length e in\nlet t,m = tableau e in\nlet rec _part i s acc=\n    match i with\n    0 -&gt; acc\n    | _ -&gt; if t.(i-1).(s) then _part (i-1) s acc\n    else\n        (*c'est que t.(i-1).(s - e.(i-1)) = true *)\n        _part (i-1) (s - e.(i-1)) (e.(i-1) :: acc)\nin _part n m [];;\n;;\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/","title":"Terminaison et correction","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> Sommaire <ol> <li>Terminaison et variants</li> <li>Correction et invariants  </li> <li>\u00c9tude de cas : tri fusion</li> </ol>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#terminaison-et-variants","title":"Terminaison et variants","text":""},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#demontrer-quune-boucle-ou-une-recursion-termine","title":"D\u00e9montrer qu'une boucle ou une r\u00e9cursion termine","text":"<p>Montrer la terminaison d'un programme, c'est prouver que le programme termine quel que soit l'\u00e9tat initial.</p> <p>Le probl\u00e8me se pose principalement pour les boucles conditionnelles (<code>while</code>) et pour les fonctions r\u00e9cursives.</p> <p>Focntions r\u00e9cursives en C et en OCaml</p> <pre><code>int power(int x , int n){\n    assert (n&gt;=0);\n    int r = 1;\n    while (n&gt;0)\n        {r\u2217=x; n\u2212=1;}\n    return r ;\n}\n</code></pre> <pre><code>let power x n =\n    let rec pow n acc =\n        match n with\n        | z when z &lt; 0-&gt; failwith \"exposant n\u00e9gatif\"\n        | 0 -&gt; acc\n        | _ -&gt; pow (n-1) (x*acc)\n    in pow n 1;;\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#notion-de-variant","title":"Notion de variant","text":"<p>D\u00e9finition</p> <p>Soit un algorithme et une boucle de cet algorithme. Un variant (de cette boucle) est une fonction des variables de l'algorithme qui :</p> <ul> <li>ne prend que des valeurs enti\u00e8res positives ou nulles \\(\\color{red}\\text{lorsque la condition de boucle est v\u00e9rifi\u00e9e}\\),</li> <li>d\u00e9cro\u00eet strictement \u00e0 chaque tour de boucle</li> </ul> <p>D\u00e9finition</p> <p>Soit un algorithme r\u00e9cursif. Un variant (de cette r\u00e9cursion) est une fonction des variables de l'algorithme qui :</p> <ul> <li>ne prend que des valeurs enti\u00e8res positives ou nulles \\(\\color{red}\\text{lorsque la condition de r\u00e9cursion est v\u00e9rifi\u00e9e}\\),</li> <li>d\u00e9cro\u00eet strictement \u00e0 chaque appel r\u00e9cursif.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#consequence-de-lexistence-dun-variant","title":"Cons\u00e9quence de l'existence d'un variant","text":"<p>Il n'existe pas de suite strictement d\u00e9croissante (infinie) d'entiers positifs.</p> <p>En cons\u00e9quence, si un variant de boucle (resp. de r\u00e9cursion) est identifi\u00e9, la boucle (resp. la r\u00e9cursion) termine.</p> <p>Consid\u00e9rons ces 2 codes d'exponentiation na\u00efve.</p> <pre><code>int power(int x , int n){\n    assert (n&gt;=0);\n    int r = 1;\n    while (n&gt;0)\n        {r\u2217=x; n\u2212=1;}\n    return r ;\n}\n</code></pre> <pre><code>let power x n =\n    let rec pow n acc =\n        match n with\n        | z when z &lt; 0-&gt; failwith \"exposant n\u00e9gatif\"\n        | 0 -&gt; acc\n        | _ -&gt; pow (n-1) (x*acc)\n    in pow n 1;;\n</code></pre> <p>Pour le code en C, les variables sont \\(x , n, r\\) .  Le variant est \\(n\\) (quantit\u00e9 enti\u00e8re strictement d\u00e9croissante \u00e0 chaque appel).</p> <p>Pour le code en OCaml, les variables de la r\u00e9cursion sont \\(acc, n, x\\) .  Le variant est encore \\(n\\).</p> <p>Ces deux programmes terminent.</p> <p>Remarque</p> <pre><code>int x = 3;\nwhile ( true ){\n    x = x \u2212 2;\n}\n</code></pre> <p>On est tent\u00e9 de prendre \\(x\\) comme variant.</p> <p>Mais il s'av\u00e8re que \\(x\\) devient n\u00e9gatif au bout de quelques tours \\(\\color{red}\\text{sans que ce soit une condition de sortie de boucle}\\).  Ce n'est donc pas un variant. Ouf ! Car le programme ne s'arr\u00eate manifestement pas.</p>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#precaution","title":"Pr\u00e9caution","text":"<p>Lorsque le candidat variant ne peut prendre que des valeurs positives (par exemple : longueur d'une liste), sa stricte d\u00e9croisssance suffit pour \u00e9tablir la terminaison.</p> <p>En revanche, il faut faire attention s'il peut prendre des valeurs n\u00e9gatives. Dans ce cas, il faut v\u00e9rifier que ces valeurs n\u00e9gatives sont bien captur\u00e9es par la condition de sortie de boucle.</p>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#variant-de-recursion","title":"Variant de r\u00e9cursion","text":"<p>Soit <code>v</code> le candidat variant.</p> <ul> <li>On \u00e9tablit que les cas de bases terminent et, d'une fa\u00e7on plus g\u00e9n\u00e9rale, que tout ce qui n'est pas appel r\u00e9cursif interne termine</li> <li>On \u00e9tablit que, lors d'un appel interne, le variant est strictement plus petit que dans l'appel externe.</li> <li>Si, par sa nature, le candidat variant ne peut prendre que des valeurs positives (par exemple : longueur d'une liste), les deux premiers points suffisent pour \u00e9tablir la terminaison.</li> <li>En revanche, si il peut prendre des valeurs n\u00e9gatives, il faut s'assurer que les cas de bases capturent bien les valeurs n\u00e9gatives du variant (i.e. le cas \\(v \u22640\\) est pris en compte par un des cas de base).</li> </ul>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#fusion-de-listes-triees","title":"Fusion de listes tri\u00e9es","text":"<p>Exercice</p> <p>\u00c9crire un programme OCaml <code>fusion : int list -&gt; int -&gt; list -&gt; int list</code> qui prend en param\u00e8tres deux listes tri\u00e9es d'entiers (par ordre croissant) et les fusionne en une seule liste tri\u00e9e. \u00c9tablir la terminaison.</p>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#solution","title":"Solution","text":"<p>Correction</p> <pre><code>let rec fusion l1 l2 =\n    match l1 , l2 with\n    | [], l -&gt; l\n    | l, [] -&gt; l\n    | x1::t1, x2::t2 -&gt; if x1 &lt;=x2\n        then x1 :: fusion t1 l2\n        else x2 :: fusion l1 t2 ;;\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#terminaison-de-fusion","title":"Terminaison de fusion","text":"<p>Cette fonction ne manipule pas directement des nombres entiers mais des listes.</p> <p>On pourrait prendre comme variant la longueur de <code>l1</code> (resp. <code>l2</code> ). Malheureusement, cette longueur est certe d\u00e9croissante mais pas toujours strictement.</p> <p>En revanche :</p> <ul> <li>Les \\(2\\) cas de base terminent et</li> <li>la somme des longueurs des deux listes est strictement d\u00e9croissante \u00e0 chaque appel r\u00e9cursif.</li> <li>Par sa nature (somme de longueurs de listes), le candidat variant ne peut prendre que des valeurs positives.</li> </ul> <p>La somme des longueurs des listes est donc bien un variant. Le programme termine.</p>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#un-mauvais-exemple","title":"Un mauvais exemple","text":"<p>Ou comment conclure un peu trop vite qu'une fonction termine</p> <pre><code>(*pr\u00e9condition : n &gt; 0*)\nlet rec f n = match n with\n    | 0 -&gt; 0\n    | n -&gt; f(n-2)\n</code></pre> <p>Le cas de base termine</p> <p>On a bien que <code>f 0</code> termine.</p> <p><code>n</code> semble un bon candidat variant. L'argument de l'appel interne respecte la r\u00e8gle de stricte d\u00e9croissance : \\(n \u22122 &lt; n\\).</p> <p>On conclut un peu vite que <code>f n</code> termine. Mais <code>f 1</code> nous prouve le contraire !</p> <p>C'est parce que, en prenant \\(n\\) comme variant, on a oubli\u00e9 de v\u00e9rifier si \\(n &lt; 0\\) est pris en compte par les cas de base. Or, ce n'est pas trait\u00e9.</p>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#la-factorielle","title":"La factorielle","text":"<pre><code>let factorielle n =\nlet rec facto acc n = match n with\n| 0 -&gt; acc\n| _ -&gt; facto (acc*n) (n-1)\nin facto 1 n;;\n</code></pre> <p>Il faut \u00e9tudier la terminaison de la fonction auxiliaire.</p> <p>Le candidat variant est \\(n\\). C'est bien une quantit\u00e9 strictement d\u00e9croissante.</p> <p>Mais par sa nature (un entier), \\(n\\) peut prendre des valeurs n\u00e9gatives. Et celles-ci ne sont pas couvertes par les cas de base : il est clair que <code>facto</code> ne termine pas si \\(n &lt; \u22121\\). Encore une fois, la stricte d\u00e9croissance ne suffit pas.</p> <p>Deux possibilit\u00e9s :</p> <ul> <li>On peut ajouter le filtrage <code>| x when x&lt;0 -&gt; failwith \"cas &lt;0\"</code> . L'hypoth\u00e8se \\(n \u22640\\) est alors bien captur\u00e9e par les cas de base.</li> <li>On peut aussi ajouter la pr\u00e9condition \\(n \u22650\\) avant l'appel \u00e0 <code>factorielle</code> .</li> <li>On num\u00e9rote les appels internes \u00e0 partir de \\(0\\), et on note ni la valeur du param\u00e8tre \\(n\\) lors de l'appel r\u00e9cursif \\(n\\) (\\(n_0\\) est la valeur de <code>n</code> lors de l'appel <code>factorielle n</code>). On trouve la r\u00e9currence \\(n_{i+1} = n_i \u22121.\\)</li> <li>On en d\u00e9duit que \\(n_i = n_0 \u2212i\\) . Et donc \\(n_{n_0} = n_0 \u2212n_0 = 0\\). Comme \\(0\\) est bien captur\u00e9 par le cas de base, la terminaison pour la pr\u00e9condition \\(n \u22650\\) est \u00e9tablie.</li> <li>Mais c'est quand m\u00eame plus simple d'ajouter un cas de base !!</li> </ul>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#redaction-cas-dun-variant-de-boucle","title":"R\u00e9daction (cas d'un variant de boucle)","text":"<p>Quand le candidat variant <code>v</code> est une expression complexe imposant d'\u00eatre tr\u00e8s pr\u00e9cis, on raisonne par r\u00e9currence pour montrer qu'il s'agit bien d'un variant :</p> <ul> <li>On num\u00e9rote les tours de boucles \u00e0 partir de \\(1\\) ; le tour \\(0\\) d\u00e9signant ce qui se passe avant la boucle.</li> <li>Les variables et le candidat variant sont indic\u00e9s par les tours de boucles : \\(x_i\\) d\u00e9signe la valeur de la variable \\(x\\) \u00e0 la fin du tour \\(i\\) ; \\(x_0\\) la valeur de \\(x\\) avant la boucle.</li> <li>Si le candidat variant \\(v\\) peut prendre des valeurs n\u00e9gatives, on montre que si \\(\\color{red}v_i\\) \\(\\color{red}\\text{est n\u00e9gatif au tour i, alors il n'y a pas de tour de boucle suppl\u00e9mentaire.}\\)</li> <li>Pour \\(i \u2208\u2115\\), on suppose qu'il y a un tour \\(i + 1\\) (s'il n'y en a pas, le programme s'arr\u00eate et on est content). \\(\\color{red}\\text{Il s'agit alors de prouver que } v_i &gt; v_i +1\\). Remarque : une cons\u00e9quence de l'hypoth\u00e8se est que \\(v_i \u22650\\).</li> <li>Si la d\u00e9croissance stricte est prouv\u00e9e, le candidat variant est bien un variant. On en d\u00e9duit la terminaison du programme.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#recherche-dichotomique-dans-une-liste-triee","title":"Recherche dichotomique dans une liste tri\u00e9e","text":"<p>L'id\u00e9e centrale de cette approche repose sur l'id\u00e9e de r\u00e9duire de moiti\u00e9 l'espace de recherche \u00e0 chaque \u00e9tape : on regarde la valeur du milieu et si ce n'est pas celle recherch\u00e9e, on sait qu'il faut continuer de chercher dans la premi\u00e8re moiti\u00e9 ou dans la seconde.</p> <p>Exercice</p> <p>\u00c9crire en C une fonction imp\u00e9rative <code>bool dichot(int n, int t[], int x)</code> qui indique par un boul\u00e9en si \\(x\\) est pr\u00e9sent dans le tableau tri\u00e9 (par ordre croissant) \\(t\\) . \u00c9tablir la terminaison.</p> <p>Correction</p> <p>S\u00e9mantique : <code>g</code> est l'indice \u00e0 partir duquel on cherche, <code>d</code> celui \u00e0 partir duquel on ne cherche plus.</p> <pre><code>bool dichot (int n, int t [n], int x){\n    int g = 0, d = n; // on cherche x entre g et d\u22121\n    while(g &lt; d){// hypoth\u00e8ses : n&gt;=0, |t| = n\n        int m = (g + d)/2;// milieu\n        if (x == t[m]) \n            return true;\n        else if (x &lt; t[m]) \n            d = m;\n        else \n            g = m + 1;\n    }// while\n    return false ; \n}//dichot\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#terminaison-de-dichot","title":"Terminaison de dichot","text":"<p>Les variables sont <code>x,g,d,m,t</code> .</p> <p><code>x</code> (resp. <code>t</code> ) ne varie pas selon les tours de boucle, <code>g</code> est croissante dans la boucle, <code>m</code> n'est pas monotone dans la boucle. Ces quantit\u00e9s ne peuvent donc \u00eatre des variants de boucles.</p> <p><code>d</code> est bien d\u00e9croissante \u00e0 chaque tour de boucle mais pas strictement d\u00e9croissante : <code>d</code> ne peut pas \u00eatre un variant.</p> <p>Notons \\(d_i , g_i\\) les valeurs respectives de <code>d,g</code> \u00e0 la fin de chaque tour de boucle \\(i \u22651\\).</p> <p>Si \\(d_i \u2212g_i \u22640\\) (donc \\(d_i \u2264 g_i\\) ) : il n'y a pas de tour de boucle suppl\u00e9mentaire. De plus, di \u2212gi est manifestement toujours entier. Ainsi, \\(d_i \u2212g_i\\) est un bon candidat variant.</p> <p>Soit \\(i \u2208 \u2115\\). S'il y a un tour \\(i + 1\\), alors \\(d_i &gt; g_i\\) donc \\(d_i \u2212g_i &gt; 0\\). On a \\(m_i +1 = \\left \\lfloor \\frac{d_i + g_i}{2} \\right \\rfloor\\)</p> <ul> <li>si \\(t_{m_i+1} = x\\) , alors le programme s'arr\u00eate : on est content.</li> <li>Sinon, comme \\(d_i \u2212g_i &gt; 0\\), on a que \\(g_i \u2264 m_{i +1} &lt; d_i\\).</li> <li>Si \\(d_{i +1} = m_{i +1}\\) , alors \\(g_{i +1} = g_i\\) et     \\(\\(d_{i +1} \u2212g_{i +1} = m_{i +1} \u2212g_i &lt;d_i \u2212g_i\\)\\)     (d\u00e9croissance stricte)</li> <li>Si \\(g_{i +1} = m_{i +1} + 1\\), alors \\(d_{i +1} = d_i\\) et   \\(\\(d_{i +1} \u2212g_{i +1} = d_i \u2212m_{i +1} \u22121 &lt;d_i \u2212m_{i +1} \u2264d_i \u2212g_i\\)\\)   (d\u00e9croissance stricte)</li> <li>Dans tous les cas de figure la d\u00e9croissance est stricte.</li> <li>Ainsi \\(d_i \u2212g_i\\) est un variant. L'algorithme s'arr\u00eate \u00e0 un moment.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#correction-et-invariants","title":"Correction et invariants","text":""},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#specification-dun-algorithme","title":"Sp\u00e9cification d'un algorithme","text":"<p>La sp\u00e9cification d'un probl\u00e8me algorithmique est une description des attendus en deux parties :</p> <ul> <li>la description des entr\u00e9es admissibles, et</li> <li>la description du r\u00e9sultat et/ou des effets attendus.</li> </ul> <p>On d\u00e9crit les entr\u00e9es admissibles par des contraintes appel\u00e9e pr\u00e9conditions.</p> <ul> <li>les entr\u00e9es sont des entiers positifs</li> <li>les entr\u00e9es sont un tableau de flottants tri\u00e9 par ordre croissant et un flottant ;</li> <li>Les entr\u00e9es sont deux listes sans intersection...</li> </ul> <p>La sp\u00e9cification d'un algorithme est la sp\u00e9cification du probl\u00e8me r\u00e9solu par cet algorithme.</p> <p>Les questions de code dans un DS d'informatique sont des sp\u00e9cifications de l'algorithme attendu.</p>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#usages-de-la-specification","title":"Usages de la sp\u00e9cification","text":"<p>En phase de conception, la sp\u00e9cification d\u00e9crit ce qui doit \u00eatre r\u00e9alis\u00e9.</p> <p>En phase d'utilisation, la sp\u00e9cification indique \u00e0 l'utilisateur ce qu'il doit entrer et le r\u00e9sultat auquel il peut s'attendre.</p> <p>En phase de test, la sp\u00e9cification donne les crit\u00e8res pour se prononcer sur la r\u00e9ussite ou l'\u00e9chec d'un test.</p> <p>En phase de preuve de correction, la sp\u00e9cification \u00e9nonce ce qui doit \u00eatre d\u00e9montr\u00e9.</p>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#invariant-de-boucle","title":"Invariant de boucle","text":"<p>Objectif : D\u00e9terminer si un programme contenant une boucle est correct vis \u00e0 vis de sa sp\u00e9cification (c.a.d s'il fait bien ce qu'on attend de lui).</p> <p>Moyen : On utilise un invariant de boucle, c'est-\u00e0-dire une propri\u00e9t\u00e9 :</p> <ol> <li>qui est v\u00e9rifi\u00e9e avant d'entrer dans la boucle.</li> <li>qui si elle est v\u00e9rifi\u00e9e avant une it\u00e9ration est v\u00e9rifi\u00e9e apr\u00e8s celle-ci,</li> </ol> <p>Un invariant de boucle pas tr\u00e8s utile est par exemple <code>1==1</code>. Il s'applique \u00e0 toutes les boucles ! C'est pour cette raison qu'on ajoute souvent une troisi\u00e8me contrainte :</p> <ol> <li>Lorsque la propri\u00e9t\u00e9 est v\u00e9rifi\u00e9e en sortie de boucle, elle permet de d\u00e9duire que le programme est correct (ou du moins la partie du programme d\u00e9limit\u00e9e par la boucle).</li> </ol>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#calcul-de-2n","title":"Calcul de \\(2^n\\)","text":"<p>Montrer que ce programme de calcul de \\(2^n\\) est correct pour tout entier \\(n \u22650\\), c.a.d qu'en sortie de boucle <code>p</code> contient \\(2^n\\).</p> <pre><code>int p=1, c = n;// pr\u00e9 condition : n entier &gt;=0\nwhile (c &gt;0){\n    p = p \u22172;\n    c = c \u2212 1; \n}\n</code></pre> <p>On note \\(c_i , p_i\\) les contenus des variables <code>c</code> et <code>p</code> apr\u00e8s l'it\u00e9ration \\(i\\).</p> <ul> <li>Avant l'entr\u00e9e dans la boucle : \\(c_0 = n, p_0 = 1\\).</li> <li>Apr\u00e8s l'it\u00e9ration \\(i\\) : \\(c_{i +1} = c_i \u22121 et p_{i +1} = 2\u00d7p_i\\) .</li> <li>Invariant potentiel \\(Inv(i)\\) : \\(c_i \u22650\\) et \\(p_i = 2^{n\u2212c_i}\\) .</li> <li>Cas de base, it\u00e9ration \\(0\\) (avant l'entr\u00e9e dans la boucle) : \\(c0 = n \u22650, p_0 = 1 = 20 = 2n\u2212c_0\\) : OK.</li> <li>H\u00e9r\u00e9dit\u00e9. On suppose \\(Inv(i )\\) v\u00e9rifi\u00e9.</li> <li>Si on entre dans la boucle, alors \\(c_i &gt; 0\\) et \\(c_{i +1} = c_i \u22121 \u22650\\). De plus \\(p_{i +1} = 2\u00d7p_i = 2^{n\u2212c_i+1} = 2^{n\u2212(c_i \u22121)} = 2^{n\u2212c_{i +1}}\\) . Donc \\(Inv(i + 1)\\) v\u00e9rifi\u00e9.</li> <li>Si on sort de la boucle, alors \\(c_i \u22640\\) (condition de sortie) et \\(c_i \u22650\\) (par \\(Inv(i)\\)) donc \\(c_i = 0\\), donc \\(p_i = 2^{n\u2212c_i} = 2^n\\) .</li> </ul>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#vocabulaire","title":"Vocabulaire","text":"<p>Il y a correction totale lorsque le programme termine toujours et v\u00e9rifie la sp\u00e9cification.</p> <p>Il y a correction partielle lorsque le programme v\u00e9rifie la sp\u00e9cification dans tous les cas o\u00f9 il termine.</p>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#etude-de-cas-tri-fusion","title":"\u00c9tude de cas : tri fusion","text":"<p>Attention</p> <p>Dans tout ce qui suit :</p> <ul> <li>Par liste tri\u00e9, on sous-entend implicitement \"liste tri\u00e9e par ordre croissant \".</li> <li>Par version tri\u00e9e d'une liste on sous-entend une nouvelle liste, tri\u00e9e par ordre croissant, ayant la m\u00eame taille que la premi\u00e8re, et contenant tous les \u00e9l\u00e9ments de la premi\u00e8re avec le m\u00eame nombre d'occurences.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#historique","title":"Historique","text":"<p>\u00c9crit vers 1945.</p> <p>Attribu\u00e9 au Hongro-Am\u00e9ricain John Von Neumann.</p> <p>Un des premiers algorithmes de tris propos\u00e9 pour les ordinateurs.</p> <p>Utilise le principe diviser pour r\u00e9gner qui consiste \u00e0 d\u00e9composer r\u00e9cursivement un gros probl\u00e8me en plus petits sous-probl\u00e8mes.</p>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#principe","title":"Principe","text":"<p>On veut une version tri\u00e9e d'une liste <code>l</code> .</p> <ul> <li>D\u00e9couper la liste en deux parties de tailles proches.</li> <li>Trier ces deux parties.</li> <li>Fusionner les deux listes tri\u00e9es obtenues.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#fusion-rappel","title":"Fusion (rappel)","text":"<pre><code>let rec fusion l1 l2 = \n    match l1 , l2 with\n    | [], l -&gt; l\n    | l, [] -&gt; l\n    | x1::t1, x2::t2 -&gt; if x1 &lt;=x2\n        then x1 :: fusion t1 l2\n        else x2 :: fusion l1 t2 ;;\n</code></pre> <ul> <li>Terminaison : d\u00e9j\u00e0 \u00e9tablie</li> <li>Correction : on veut montrer que <p>\\(\\text{pour deux listes tri\u00e9es par ordre croissant }\\)<code>l1, l2</code> , \\(\\color{red}\\text{la liste obtenue par appel de}\\) <code>fusion l1 l2</code> \\(\\color{red}\\text{est une version tri\u00e9e de }\\)<code>l1 @ l2</code>.</p></li> </ul>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#correction-de-la-fusion","title":"Correction de la fusion","text":"<p>Pr\u00e9conditions : <code>l1</code> et <code>l2</code> sont des listes tri\u00e9es d'entiers.</p> <ul> <li>On note \\(n_1 = |l_1|\\) et \\(n_2 = |l_2|\\) les longueurs des listes op\u00e9randes.</li> <li>On montre par r\u00e9currence sur \\(n_1 + n_2 = n\\) la propri\u00e9t\u00e9 \\(P(n)\\) \"\\(\\color{red}\\text{la liste r\u00e9sultat de}\\) <code>fusion l1 l2</code> \\(\\color{red}\\text{est une version tri\u00e9e de}\\) <code>l1 @ l2</code> \". Remarque : sa taille est donc \\(n_1 + n_2\\)</li> <li>Cas de base. Lorsque \\(n_1 + n_2 = 0\\), alors les deux listes sont vides. On retourne la liste vide qui est tri\u00e9e et contient les \u00e9l\u00e9ments de <code>l1,l2</code>.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#heredite","title":"H\u00e9r\u00e9dit\u00e9","text":"<p>On suppose \\(P(n)\\) v\u00e9rifi\u00e9e. On r\u00e9alise l'appel <code>fusion l1 l2</code> avec \\(n_1 + n_2 = n + 1\\).</p> <ul> <li>Si l'une des deux listes est vide, on retourne celle qui ne l'est pas. L'invariant est v\u00e9rifi\u00e9 trivialement.</li> <li>Si les deux listes sont non vides, supposons que l'appel interne soit <code>fusion q1 l2</code> (se produit si le premier \u00e9l\u00e9ment \\(x_1\\) de <code>l1</code> est inf\u00e9rieur au premier de <code>l2</code> ; l'autre cas est laiss\u00e9 au lecteur).</li> <li>L'hypoth\u00e8se de r\u00e9currence s'applique puisque   \\(|q_1|+ |l_2|= n_1 \u22121 + n_2 = n\\) et <code>q1,l2</code> sont tri\u00e9s</li> <li>Donc <code>fusion q1 l2</code> est une version tri\u00e9e de <code>q1@l2</code> .</li> <li>Comme <code>q1,l2</code> ne contiennent que des \u00e9l\u00e9ments plus grands que \\(x_1\\) , <code>x1::fusion q1 l2</code> est tri\u00e9e et contient les bons \u00e9l\u00e9ments. IZP\\(^1\\) !!</li> </ul> <p>\\(\\overline{\\text{1. In Ze Pocket}}\\)</p>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#fonction-de-separation","title":"Fonction de s\u00e9paration","text":"<p>Exercice</p> <ul> <li> <p>\u00c9crire une fonction <code>div : int -&gt; 'a list -&gt; 'a list *'a list</code> qui prend en param\u00e8tres un indice \\(i\\) et une liste \\(t\\) et un retourne les deux listes <code>t[:i]</code> et <code>t[i:]</code> (en notation de slicing Python). Par exemple <code>div 3 [0;1;2;3;4]</code> renvoie <code>([0; 1; 2], [3; 4])</code>.</p> </li> <li> <p>\u00c9crire une fonction <code>separer : 'a list -&gt; 'a list * 'a list</code> qui s\u00e9pare une liste en deux listes de tailles \u00e9gales \u00e0 \\(1\\) pr\u00e8s : la premi\u00e8re moiti\u00e9 et la seconde.  Par exemple <code>separer [0;1;2;3;4]</code> renvoie <code>([0; 1; 2], [3; 4])</code> </p> </li> </ul> <p>Correction</p> <p><pre><code>let rec div i l = \n    match i,l with\n    | 0, _ -&gt; [], l\n    | _, [] -&gt; failwith \"impossible\"\n    | _, x::q -&gt; let d,f = div (i-1) q in x::d, f ;;\n\nlet separer l =\n    let n = List.length l in\n    div (n/2) l;;\n</code></pre> Les preuves de terminaison et correction de ces deux fonctions sont admises et laiss\u00e9es au lecteur.</p>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#le-tri-fusion","title":"Le tri fusion","text":"<p>Exercice</p> <p>\u00c9crire la fonction <code>tri : 'a list -&gt; 'a list</code> qui r\u00e9alise le tri fusion. \u00c9tablir terminaison et correction.</p> <p>Correction du code</p> <pre><code>let rec tri l =\n    match l with\n    | [] -&gt; l\n    | [_] -&gt; l\n    | _ -&gt; let l1,l2 = separer l in\n        let l1 '= tri l1 and l2 ' = tri l2 in\n        fusion l1' l2 ';;\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#terminaison","title":"Terminaison","text":"<p>Dans les cas de bases, (liste vide ou singleton), la fonction termine de fa\u00e7on \u00e9vidente.</p> <p>Si <code>tri l</code> termine pour tout <code>l</code> de taille \\(\u2264n\\), consid\u00e9rons l'appel <code>tri l</code> pour <code>l</code> de taille \\(n + 1\\) avec \\(n &gt; 0\\).</p> <p>L'appel \u00e0 <code>separer</code> termine (admis) et retourne deux listes de tailles \\(\\left \\lfloor \\frac{n+1}{2} \\right \\rfloor\\) et \\(\\left \\lceil \\frac{n+1}{2} \\right \\rceil\\). Ces deux listes sont pass\u00e9es chacune en argument de <code>tri</code>.</p> <p>Et ces deux appels terminent par hypoth\u00e8se de r\u00e9currence puisque, \\(n + 1\\) \u00e9tant plus grand que \\(2\\), les deux parties enti\u00e8res de \\(\\frac{n+1}{2}\\) sont strictement plus petites que \\(n + 1\\).</p> <p>Enfin, la fusion de deux listes termine toujours donc <code>tri l</code> termine. H\u00e9r\u00e9dit\u00e9 OK.</p>"},{"location":"Analyse%20d%27algorithmes/1-Terminaison%20Correction/#correction","title":"Correction","text":"<p>Dans les cas de bases, (liste vide ou singleton), la fonction retourne une version tri\u00e9e de <code>l</code> de fa\u00e7on \u00e9vidente.</p> <p>Si <code>tri l</code> renvoie une version tri\u00e9e de <code>l</code> pour tout <code>l</code> de taille \\(\u2264n\\), consid\u00e9rons l'appel <code>tri l</code> pour <code>l</code> de taille \\(n + 1\\) avec \\(n &gt; 0\\).</p> <p>L'appel \u00e0 <code>separer</code> termine (admis) et retourne la premi\u00e8re et seconde moiti\u00e9 de <code>l</code> : <code>l1,l2</code>. Elles sont chacune strictement plus courtes que <code>l</code> puisque \\(n + 1 &gt; 1\\).</p> <p>Ces deux listes sont pass\u00e9es chacune en argument de <code>tri</code> et, par HR, on obtient une version tri\u00e9e de chacune. On les note <code>l1',l2'</code>.</p> <p>Enfin, <code>fusion</code> appliqu\u00e9e \u00e0 ces \\(2\\) listes retourne une version tri\u00e9e de <code>l1'@l2'</code> .</p> <p>Cette liste est une version tri\u00e9e de <code>l1@l2</code> donc de <code>l</code> . IZP</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/","title":"Complexit\u00e9","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li> <p>\" Option informatique MPSI, MP/MP* \", Roger Mansuy, paru chez Vuibert.</p> </li> <li> <p>Cours  \"diviser pour r\u00e9gner\", Becirspahic</p> </li> <li> <p>Wikip\u00e9dia : Analyse de la compl\u00e9xit\u00e9 des algorithmes.</p> </li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#introduction","title":"Introduction","text":""},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#definitions","title":"D\u00e9finitions","text":""},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#definition","title":"D\u00e9finition","text":"<p>D\u00e9finition : Analyse de la complexit\u00e9</p> <p>\u00c9tude formelle de la quantit\u00e9 de ressources (de temps, d'espace m\u00e9moire, ...) n\u00e9cessaire \u00e0 l'ex\u00e9cution de cet algorithme</p> <ul> <li>En temps il s'agit de savoir si une fonction termine dans un temps raisonnable</li> <li>En m\u00e9moire il s'agit de d\u00e9terminer si la fonction dispose bien toutes les ressources physiques pour s'ex\u00e9cuter.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#temps-et-espace","title":"Temps et espace","text":"<p>Soit \\(f\\) un programme prenant en param\u00e8tre une donn\u00e9e \\(d\\)</p> <ul> <li>Complexit\u00e9 en espace pour une donn\u00e9e \\(d\\) : d\u00e9terminer la place en m\u00e9moire en plus de \\(d\\) occup\u00e9e par le programme.</li> <li>Complexit\u00e9 en temps pour une donn\u00e9e \\(d\\) : d\u00e9nombrer toutes les op\u00e9rations \u00e9l\u00e9mentaires effectu\u00e9es lors de l'appel \\(f (d )\\) et faire la somme de la dur\u00e9e de chacune.</li> <li>Parfois, on ne s'int\u00e9resse qu'\u00e0 certaines op\u00e9rations bien d\u00e9finies ( \u0327ca d\u00e9pend de ce qu'on veut \u00e9tudier).</li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#complexite-selon-une-donnee-d","title":"Complexit\u00e9 selon une donn\u00e9e \\(d\\)","text":"<p>D\u00e9finition utiles</p> <p>On note \\(D_{n}\\) l'ensemble des donn\u00e9es de taille \\(n\\) et \\(C(d)\\) la complexit\u00e9 d'un certain programme pour une donn\u00e9e \\(d\\).</p> <ol> <li>\\(C_{\\max}(n) = \\max_{d \\in D_{n}}C(d)\\) Est la complexit\u00e9 dans le pire cas</li> <li>\\(C_{\\min}(n) = \\min_{d \\in D_{n}}C(d)\\) Est la complexit\u00e9 dans le meilleur des cas</li> <li>\\(C_{moy}(n) = \\sum_{d \\in D_{n}}^{}P(d)C(d)\\) Est la complexit\u00e9 en moyenne avec \\(P\\) la loi de probabilit\u00e9 associ\u00e9e \u00e0 l'apparition des donn\u00e9es de taille \\(n\\).</li> </ol>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#landau","title":"Landau","text":"<p>D\u00e9finition: Domination / Ordre de grandeur</p> <p>Soient \\(U = (u_n)\\) et \\(V = (v_n)\\) deux suites r\u00e9elles positives. On dit que :</p> <ol> <li>\\(U\\) est domin\u00e9e par \\(V\\) s'il existe \\(\\lambda \\in {\\mathbb{R}} + etN \\in {\\mathbb{N}}\\) tels que pour tout \\(n \\in {\\mathbb{N}}\\), si \\(n \u2265 N\\) alors \\(u_{n} \\leq \\lambda v_{n}\\). On le note \\(u_{n} = O\\left( v_{n} \\right)\\).  On dit aussi que V domine U.</li> <li>\\(U\\) et \\(V\\) sont de m\u00eame ordre (de grandeur) si \\(U\\) domine \\(V\\) et \\(V\\) domine \\(U\\) (i.e. \\(u_{n} = O\\left( v_{n} \\right)\\) et \\(v_{n} = O\\left( u_{n} \\right)\\)).  On le note \\(u_{n} = \\Theta\\left( v_{n} \\right)\\) (\u00ab\u00a0\\(u_{n}\\) est en grand th\u00eata de \\(v_{n}\\)\u00bb)</li> </ol> <p>D\u00e9finition : \u00c9quivalence / Grand Om\u00e9ga</p> <p>Soient \\(U = (u_n)\\) et \\(V = (v_n)\\) deux suites r\u00e9elles positives. On dit que :</p> <ol> <li> <p>On \u00e9crit \\(u_{n} = \\Omega\\left( v_{n} \\right)\\) (\u00ab\u00a0\\(u_{n}\\)est en grand Om\u00e9ga de \\(v_{n}\\)\u00a0\u00bb) s'il existe\\(\\lambda \\in {\\mathbb{R}}_+\\) et \\(N \\in {\\mathbb{N}}\\) tels que pour tout \\(n \\in {\\mathbb{N}}\\), si \\(n \u2265 N\\) alors \\(u_{n} \\geq \\lambda v_{n}\\). Observons que dans ce cas \\(\\frac{1}{\\lambda}u_{n} \\geq v_{n}\\) et donc \\(u_{n} = \\Omega\\left( v_{n} \\right) \\Leftrightarrow v_{n} = O\\left( u_{n} \\right)\\).</p> </li> <li> <p>\\(U\\) et \\(V\\) sont dites \u00e9quivalentes si et seulement si \\(v_{n} \\neq 0\\) \u00e0 partir d'un certain rang et \\(\\frac{u_{n}}{v_{n}}\\) tend vers \\(1\\) en \\(n \\rightarrow + \\infty\\). Cette d\u00e9finition (qui nous suffit) est plus restrictive que celle du cours du maths.</p> </li> </ol> <p>Remarque</p> <p>Si \\(u_{n} \\sim v_{n}\\) alors \\(u_{n} = \\Theta\\left( v_{n} \\right)\\).</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#que-compter","title":"Que compter ?","text":"<p>La plupart du temps, on se contente de donner une majoration\" \u00e0 constante multiplicative pr\u00e8s\" du temps de calcul.</p> <p>On ne compte pas pr\u00e9cis\u00e9ment le nombre d'op\u00e9rations \u00e9l\u00e9mentaires (est-ce bien malin de mettre dans le m\u00eame sac un acc\u00e8s \u00e0 un \u00e9l\u00e9ment de tableau et une addition binaire ?).</p> <p>Dans ce cas, la notation en \\(O (f (n))\\) (si \\(n\\) est l'entr\u00e9e) nous suffit.</p> <p>Parfois, on s'int\u00e9resse \u00e0 une op\u00e9ration sp\u00e9cifique, et dans ce cas un d\u00e9compte pr\u00e9cis est favoris\u00e9.</p> <p>Exemple :</p> <ul> <li>Le nombre d'\u00e9changes d'\u00e9l\u00e9ments dans un tri de tableau</li> <li>Le nombre de produits de flottants dans un produit matriciel \u00ab\u00a0optimis\u00e9\u00a0\u00bb</li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#ordres-de-grandeur","title":"Ordres de grandeur","text":"<p>Pour une donn\u00e9e de taille n</p> D\u00e9nomination D\u00e9finition Exemple Logarithmique \\(O(\\log n)\\) Recherche dans une liste tri\u00e9e (pire cas) Lin\u00e9aire \\(O(n)\\) Inversion d'un tableau Quasi-lin\u00e9aire \\(O(n\\log n)\\) Tri fusion d'un tableau Polynomiale \\(O(n\u00b2)\\) Tri par insertion (pire cas) Polynomiale \\(O(n^k)\\) pour un  \\(k&gt;1\\) Produit matriciel na\u00eff en \\(O\\left( n^{3} \\right)\\) Exponentielle \\(O(2^{P(n)})\\) \\(P\u2208\u211d[X]\\) \\(deg(P) \u2265 1\\) Satisfiabilit\u00e9 d'une formule (pire cas)"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#operations-elementaires","title":"Op\u00e9rations \u00e9l\u00e9mentaires","text":""},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#presentation","title":"Pr\u00e9sentation","text":"<p>Pour mesurer le temps d'ex\u00e9cution d'un programme, on utilise le nombre d'op\u00e9rations \u00e9l\u00e9mentaires \u00e0 effectuer plut\u00f4t qu'une dur\u00e9e en seconde. En g\u00e9n\u00e9ral on en cherche une majoration, plus rarement une minoration.</p> <p>La raison est que le m\u00eame programme s'ex\u00e9cutera plus ou moins vite selon la machine mais que le nombre d'op\u00e9rations ne changera pas.</p> <p>Il reste \u00e0 d\u00e9finir ce qu'est une op\u00e9ration \u00e9l\u00e9mentaire. C'est affaire de convention.</p> <p>Exemple d'op\u00e9rations consid\u00e9r\u00e9es dans ce cours comme \u00e9l\u00e9mentaires : </p> <pre><code>    + \u2212 / \u2217 % // op\u00e9rations sur les nombres\n    t [i] //acc\u00e8s en lecture / \u00e9criture\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#operations-elementaires-en-c","title":"Op\u00e9rations \u00e9l\u00e9mentaires en C","text":"<p>D\u00e9finitions: Op\u00e9rations \u00e9l\u00e9mentaires</p> <p>Les op\u00e9rations suivantes sont dites \u00e9l\u00e9mentaires (non exhaustif)</p> <ul> <li>Op\u00e9rations sur les nombres\u00a0: <code>+ - \\* /\u00a0%</code></li> <li>Op\u00e9rtaions bitwise : <code>&amp; &lt;&lt; &gt;&gt; ^ |</code></li> <li>Affectation, Afficher, Retourner\u00a0: <code>a = ...\u00a0; return ...</code></li> <li>Acc\u00e8s\u00a0en lecture \u00e9criture: <code>t[i]</code></li> <li>Comparaisons de nombres d\u00e9j\u00e0 calcul\u00e9s\u00a0: <code>... &lt; ...\u00a0; ... == ...</code></li> <li>Lib\u00e9ration\u00a0: <code>free(t)</code></li> </ul> <p>Ces op\u00e9rations, dites \u00e9l\u00e9mentaires sont donc consid\u00e9r\u00e9es comme de co\u00fbt constant \\(O(1)\\). Mais il y a des op\u00e9rations \u00e0 co\u00fbt constant qui ne sont pas \u00e9l\u00e9mentaires. Par exemple <code>i++</code>.</p> <ul> <li>Dans <code>x &lt; y</code>, la comparaison elle-m\u00eame est en \\(O(1)\\) mais l'\u00e9valuation de <code>x</code> et <code>y</code> peut \u00eatre co\u00fbteuse.</li> </ul> <p>La complexit\u00e9 temporelle d'un programme au pire : nombre max. d'op. elem. \u00e0 effectuer (en fonction de la taille du ou des arguments).</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#dans-dautres-langages","title":"Dans d'autres langages","text":"<p>Bien que la syntaxe soit diff\u00e9rente, les op\u00e9rations en OCaml \u00e9quivalentes \u00e0 celles ci-dessus (lorsqu'elles existent) sont aussi consid\u00e9r\u00e9es commes \u00e9l\u00e9mentaires. Le filtrage est consid\u00e9r\u00e9 comme le co\u00fbt constant (mais n'est pas \u00e9l\u00e9mentaire).</p> <p>En Python, on a coutume de consid\u00e9rer l'addition comme \u00e9l\u00e9mentaire bien que ce soit faux : en effet les entier \u00e9tant non born\u00e9s, la somme de deux s'effectue sur des parties de ces nombres, Python rajoutant un traitement logiciel pour recooler les morceaux.</p> <p>En MP2I, les allocations sur le tas <code>malloc</code>, <code>calloc</code> et <code>realloc</code> sont consid\u00e9r\u00e9es comme \u00e0 co\u00fbt constant m\u00eame si c'est en fait bien difficile \u00e0 d\u00e9terminer.</p> <p>Les op\u00e9rations d'affichage et de saisie <code>printf, scanf</code>peuvent prendre du temps. Il est pr\u00e9f\u00e9rable d'indiquer qu'elles ne sont pas comptabilis\u00e9es dans le calcul de compl\u00e9xit\u00e9 temporelle.</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#exemples-introductifs","title":"Exemples introductifs","text":"<p>Exemple introductif 1 On cherche les diviseurs d'un entier \\(n\\) :</p> <pre><code>void diviseurs1(int n){\n    for(int i=2; i&lt;n; i++){\n        if(n%i == 0){\n            printf(\"%d;\", i); //compt\u00e9 comme O(1)\n        }\n    }\n}\n</code></pre> <p>Ce programme effectue exactement \\(n - 2\\) calculs de restes de divisions euclidiennes, \\(n - 2\\) comparaisons et un nombre d'affichages inf\u00e9rieur ou \u00e9gal \u00e0 \\(n - 2\\). Au maximum, il y a donc \\(5(n - 2) + 1\\) op\u00e9rations \u00e9l\u00e9mentaires plus les \\(n - 2\\) incr\u00e9mentations de \\(i\\) + comparaisons.</p> <p>L'ordre de grandeur est donc donn\u00e9 par une application affine : On dit que \u00ab la complexit\u00e9 temporelle est en \\(O(n)\\).</p> <p>Exemple introductif 2</p> <p>Si \\(n = pq\\) avec \\(p \u2265 \\sqrt{n}\\) alors \\(q \u2264 \\sqrt{n}\\) Nouveau principe : on cherche tous les diviseurs \\(q\\) qui sont plus petits que \\(\\sqrt{n}\\); les autres valent \\(\\frac{n}{q}\\)</p> <pre><code>void diviseurs2 (int n){\n    int q ; int p ; // 2 op\n    q = 1; // 1 op\n    while (q \u2217 q &lt;= n){// 2 op\n        if (n % q == 0){ // 2 ops\n            printf(\"%d\", q); // 1 op\n            p = n / q; // 2 op\n            if (p != q) // (ne pas afficher q 2 fois si n=p\u02c62) :1 op\n                print(p); // 1 op\n            q=q +1; // 2 op\n        }\n    }\n}\n</code></pre> <ul> <li>\\(\\sqrt{n}\\) it\u00e9rations au plus, moins de \\(20\\) op\u00e9rations \u00e9l\u00e9mentaires par passage</li> <li>En tout pas plus de \\(3 + 20\\sqrt{n}\\) op\u00e9rations \"\u00e9l\u00e9mentaires\". \\(O(\\sqrt{n})\\)</li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#taille-du-probleme","title":"Taille du probl\u00e8me","text":"<p>D\u00e9terminer le temps d'ex\u00e9cution en fonction de la taille du probl\u00e8me</p> <p>Exemples</p> <ul> <li>Recherche de diviseur de \\(n\\). La taille est \\(n\\), le temps d'ex\u00e9cution est proportionnel \u00e0 \\(n\\) ou \\(\\sqrt{n}\\)</li> <li>Manipulation d'une liste. Taille du probl\u00e8me : nombre d'\u00e9l\u00e9ments.</li> <li>Traitement d'un fichier texte. Taille du probl\u00e8me : nombre de caract\u00e8res.</li> <li>Addition de matrices \\(n\\times m\\). Taille du probl\u00e8me le couple \\((n, m)\\) ou \\(nm\\)</li> <li>Recherche d'un mot dans un fichier. Taille du probl\u00e8me le couple \\((n,m)\\) o\u00f9 \\(n\\) est le nombre de carct\u00e8res du texte et \\(m\\) celui du mot.</li> <li>Compression d'images : une image n'est rien de plus qu'une matrice de \\(w \\times h\\) de pixels. La taille du probl\u00e8me est \\((w, h)\\).</li> </ul> <p>Souvent la taille du probl\u00e8me est indiqu\u00e9e dans l'\u00e9nonc\u00e9.</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#modele-de-complexite-temporelle-imperative","title":"Mod\u00e8le de complexit\u00e9 temporelle imp\u00e9rative","text":"<p>La complexit\u00e9 d'un alogrithme est une fonction \\(C\\) d\u00e9finie inductivement.</p> <ul> <li>On ne mesure pas le temps d'ex\u00e9cution d'un programme en secondes mais le nombre d'op\u00e9rations \u00e9l\u00e9mentaires.</li> <li>Op\u00e9ration \"de base\". On consid\u00e8re qu'elles ont toures le m\u00eame co\u00fbt.</li> <li>S\u00e9quences : Le co\u00fbt des instructions <code>p; q</code> en s\u00e9quence est la somme des co\u00fbts de l'instruction <code>p</code> et de l'instruction <code>q</code> : \\(C(p) + C(q)\\)</li> <li>Tests : Le co\u00fbts d'une expression conditionnelle <code>if (b) {p;} else {q;}</code> est inf\u00e9rieur ou \u00e9gal au maximum des co\u00fbts des instructions <code>p</code> et <code>q</code>, plus un test plus ou moins compliqu\u00e9 (temps d'\u00e9valuation de l'expression <code>b</code>). \\(max \\left(C(p),C(q) \\right ) + C(b)\\). En g\u00e9n\u00e9ral on a \\(C(b) = O(1)\\) et on le n\u00e9glige. Mais ce n'est pas toujours vrai.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#cout-dune-boucle-for","title":"Co\u00fbt d'une boucle <code>for</code>","text":"<p>Le co\u00fbt d'un boucle <code>for(i = 0\u00a0; i &lt; m\u00a0; i++) p();</code> son co\u00fbt est <code>m</code> fois le co\u00fbt de l'instruction <code>p</code> si ce co\u00fbt ne d\u00e9pend pas de la valeur de <code>i</code>\u00a0:</p> <p>\\(1 + m \\times \\left( C(p) + 2 \\right) = O\\left( m \\times C(p) \\right)\\)</p> <p>(\"\\(+2\\)\" pour l'incr\u00e9mentation et la comparaison \u00e0 chaque tour de boucle, \\(1\\) : initialisation).</p> <ul> <li>Quand le co\u00fbt du corps de la boucle d\u00e9pend de la valeur du compteur <code>i</code>, le co\u00fbt total de la boucle est la somme des co\u00fbts du corps de la boucle pour chaque valeur de <code>i</code> + l'incr\u00e9mentation\u00a0:</li> </ul> \\[\\sum_{i = 0}^{m - 1}\\left( C\\left( p_{i} \\right) + 2 \\right) = O\\left( \\sum_{i = 0}^{m - 1}C\\left( p_{i} \\right) \\right)\\] <p>Le co\u00fbt d'une boucle <code>for</code> ne peut pas \u00eatre inf\u00e9rieur \u00e0 \\(O(m)\\) car il y a toujours l'incr\u00e9mentation du compteur (sauf si dans le corps de la boucle se trouver une instruction d'arr\u00eat ou de retour).</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#cout-dun-boucle-while","title":"Co\u00fbt d'un boucle <code>while</code>","text":"<p>Le nombre d'it\u00e9ration n'est pas connu \u00e0 l'avance \u00e0 priori. On \u00e9value donc le nombre d'it\u00e9ration et on proc\u00e8de comme pour la boucle for en y ajoutant la complexit\u00e9 du test.</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#complextie-temporelle-cas-fonctionnel","title":"Complexti\u00e9 temporelle (cas fonctionnel)","text":"<p>Exemple de complexit\u00e9 temporelle (OCaml)</p> <p>On essaye d'\u00e9tablir une relation de r\u00e9currence entre \\(C(n)\\) (la complexit\u00e9 pour une donn\u00e9e de taille \\(n\\)) et la complexit\u00e9 des appels internes plus la complexit\u00e9 hors appel r\u00e9cursif. Complexit\u00e9 \\(C (n)\\) en nombre de multiplications pour\u00a0:</p> <pre><code>let rec fact n =\n    if n&lt;2 then 1 else n * fact (n-1);;\n</code></pre> <ul> <li>\\(C(0) = C(1) = 0\\)</li> <li>\\(C(n) = C(n - 1) + 3\\) : une multiplication seulement dans le cas \\(n\u22652\\).</li> </ul> <p>Alors on a\u00a0:</p> \\[C(n) = C(n - 1) + 1 = \\left( C(n - 2) + 1 \\right) + 1 = \\ldots = \\underbrace{C(1)}_{\\text{cte}} + (n\u20131) = O(n)\\]"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#complextie-temporelle-recursion","title":"Complexti\u00e9 temporelle (R\u00e9cursion)","text":"<p>Exemple de complexit\u00e9 temporelle (C)</p> <p>Complexit\u00e9 \\(C (n)\\) en nombre d'op\u00e9rations \u00e9l\u00e9mentaires pour\u00a0:</p> <pre><code>int fact(int n){ // n suppos\u00e9 positif\n    if (n&lt;2)\n        return 1;\n    else \n        return n * fact (n-1);\n}\n</code></pre> <ul> <li>\\(C(0) = C(1) = 0\\) (une comparaison <code>n&lt;2</code>). En fait, on pourrait aussi compter l'op\u00e9ration d'\u00e9criture \u00e0 l'adresse de retour et d'autres op\u00e9rations cach\u00e9es, mais ce n'est pas si important car on veut un comportement assymptotique.</li> <li>\\(C(n) = C(n - 1) + 3\\) : (on compte <code>n&lt;2</code>; <code>n-1</code>;<code>n * ...</code>)</li> </ul> <p>On obtient:</p> <p>\\(C(n) = C(n - 1) + 3 = \\left( C(n - 2) + 3 \\right) + 3 = \\ldots = \\underbrace{C(1)}_{\\text{cte}} + 3(n\u20131) = O(n)\\) \\(\\color{red}{\\text{Il est plus simple de prendre } C(n) = C(n-1) + 1 \\text{ (m\u00eame ODG)}}\\)</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#calculs-simplifies","title":"Calculs simplifi\u00e9s","text":"<p>En g\u00e9n\u00e9ral, on ne s'encombre pas avec une trop grande pr\u00e9cision.</p> <p>Si \\(C(n) = C(n-1) = f(n)\\) on choisit l'expression la plus simple ayant le m\u00eame ODG que \\(f\\). </p> <ul> <li>\\(n\u00b2\\) si \\(f(n) = 3n\u00b2 + 5n +15\\)</li> <li>\\(n2^n\\) si \\(f(n) = 6n2^n + 30n^5 + log(n)\\)</li> </ul> <p>Seuls cas o\u00f9 il faut \u00eatre pr\u00e9cis : lorsqu'on s'int\u00e9resse \u00e0 une op\u00e9ration en particulier (Exemples : multiplications d'entiers; \u00e9critures dans un tableau...).</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#limites-du-modele","title":"Limites du mod\u00e8le","text":"<p>Le mod\u00e8le de complexit\u00e9 pr\u00e9sent\u00e9 est une aproximation de la r\u00e9alit\u00e9.</p> <p>Le mod\u00e8le ne tient pas compte du fait que la taille des entiers peut \u00eatre grande (surtout vrai en Python). La multiplication de deux tr\u00e8s grands nombres est bien entendu plus co\u00fbteuse que celle de \\(2 \\times 3\\). Il faudra par exemple d'abord lire tous les chiffres des op\u00e9randes et \u00e9crire ceux du r\u00e9sultat. Plus toutes les autres op\u00e9rations logicielles que Python ajoute au traitement processeur.</p> <p>Autre exemple, une tr\u00e8s grande liste (ou matrice) ne tiendra pas en m\u00e9moire vive : il faudra faire des acc\u00e8s disques pour parcourir les \u00e9l\u00e9ments.</p> <p>En CPGE, on convient que <code>malloc(..)</code> est une op\u00e9ration \u00e0 co\u00fbt constant (ce qui est faux). En revanche <code>realloc(..)</code> peut-\u00eatre \u00e9ventuellement en \\(O (1)\\) dans des cas o\u00f9 il n'y a pas de copie \u00e0 faire.</p> <p>L'\u00e9valuation du temps mis par un algorithme pour s'ex\u00e9cuter est un domaine de recherche \u00e0 part enti\u00e8re, car elle se r\u00e9v\u00e8le parfois tr\u00e8s difficile.</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#meilleur-des-cas","title":"Meilleur des cas","text":"<p>La complexit\u00e9 au pire est la plus significative, mais il peut \u00eatre utile de conna\u00eetre aussi la complexit\u00e9 dans le meilleur des cas, pour avoir une borne inf\u00e9rieure du temps d'ex\u00e9cution d'un algorithme.</p> <p>En particulier, si la complexit\u00e9 dans le meilleur et dans le pire des cas sont du m\u00eame ordre, cela signifie que le temps d'ex\u00e9cution de l'algorithme est relativement ind\u00e9pendant des donn\u00e9es et ne d\u00e9pend que de la taille du probl\u00e8me.</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#complexite-en-moyenne","title":"Complexit\u00e9 en moyenne","text":"<p>Parler de moyenne des temps d'ex\u00e9cution n'a de sens que si l'on a une id\u00e9e de la fr\u00e9quence des diff\u00e9rentes donn\u00e9es possibles pour un m\u00eame probl\u00e8me de taille \\(n\\).</p> <p>Les calculs de complexit\u00e9 moyenne recourent aux notions d\u00e9finies en math\u00e9matiques dans le cadre de la th\u00e9orie des probabilit\u00e9s et des statistiques.</p> <p>La complexit\u00e9 en moyenne n'est, en g\u00e9n\u00e9ral, pas attendue dans les sujets mais on en verra quelques exemples.</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#complexite-en-espace","title":"Complexit\u00e9 en espace","text":"<p>Il n'y a pas que le temps d'ex\u00e9cution des algorithmes qui int\u00e9resse les informaticiens.</p> <p>Une autre ressource importante en informatique est la m\u00e9moire.</p> <p>On appelle complexit\u00e9 en espace d'un algorithme la place n\u00e9cessaire en m\u00e9moire pour faire fonctionner cet algorithme en dehors des param\u00e8tres du programme.</p> <p>Elle s'exprime \u00e9galement sous la forme d'un \\(O(f(n))\\) o\u00f9 \\(n\\) est la taille du probl\u00e8me.</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#complexite-en-memoire","title":"Complexit\u00e9 en m\u00e9moire","text":"<p>En g\u00e9n\u00e9ral, il suffit de faire le total des tailles en m\u00e9moire des diff\u00e9rentes variables utilis\u00e9es.</p> <p>La seule vraie exception \u00e0 la r\u00e8gle est le cas des fonctions r\u00e9cursives, qui cachent souvent une complexit\u00e9 en espace \u00e9lev\u00e9e du fait de l'empilement des stack frames. La r\u00e9cursion terminale est une bonne solution \u00e0 ce probl\u00e8me.</p> <p>La complexit\u00e9 spatiale est n\u00e9cessairement toujours inf\u00e9rieure (ou \u00e9gale) \u00e0 la complexit\u00e9 temporelle d'un algorithme : on suppose qu'une op\u00e9ration d'\u00e9criture en m\u00e9moire prend un temps \\(O(1)\\), donc \u00e9crire une m\u00e9moire de taille \\(M\\) prend un temps \\(O(M)\\).</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#un-mot-sur-la-racine-carree","title":"Un mot sur la racine carr\u00e9e","text":""},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#objectif","title":"Objectif","text":"<p>Les pages qui suivent sont donn\u00e9es pour la culture.</p> <ul> <li>Dans cette sous-section, on pr\u00e9sente une astuce tr\u00e8s utilis\u00e9e par les cartes graphiques 3D pour calculer la racine carr\u00e9e.</li> <li>Les cartes graphiques font en effet beaucoup de calculs g\u00e9om\u00e9triques (par exemple pour d\u00e9terminer si un projectile rencontre une surface comme un mur : intersection droite plan).</li> <li>Ces calculs font intervenir des notions comme le vecteur normal \u00e0 une surface (il faut diviser un produit vectoriel par une norme, donc la racine carr\u00e9e de la somme des carr\u00e9s des coordonn\u00e9es du vecteur).</li> <li>D'o\u00f9 l'importance d'un calcul efficace de la racine carr\u00e9e.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#methode-de-heron","title":"M\u00e9thode de H\u00e9ron","text":"<p>Calcul de \\(\\sqrt{A}\\)</p> <ul> <li>Par dichotomie avec une pr\u00e9cision \\(\u03b5\\) en r\u00e9solvant \\(x^2 \u2212A = 0\\) sur \\([0; A + 1]\\). Calcul en \\(O(log(\\frac{A+1}{\u03b5}))\\). Ce n'est d\u00e9j\u00e0 pas si mal.</li> <li>M\u00e9thode de H\u00e9ron (une sp\u00e9cialisation de la m\u00e9thode de Newton \u00e0 cet objectif particulier) :</li> <li>Choisir \\(x_0\\) initial puis \\(x_{k +1} = \\frac{1}{2} (x_k + \\frac{A}{x_k})\\).</li> <li>Convergence quadratique : le nombre de chiffres significatifs double \u00e0 chaque it\u00e9ration. Au bout de quelques it\u00e9rations (15 ou 20), on atteint la pr\u00e9cision maximale possible sur un ordinateur de bureau. On peut alors consid\u00e9rer que le calcul de la racine carr\u00e9e est quasiment en temps constant (pas tout \u00e0 fait).</li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#john-carmack-et-frac1sqrt2","title":"John Carmack et \\(\\frac{1}{\\sqrt{2}}\\)","text":"<p>John Carmack est un informaticien am\u00e9ricain \u00e0 l'origine de nombreux jeux vid\u00e9os, dont Wolfenstein 3D, Doom et Quake.</p> <ul> <li>Les cartes graphiques 3D avec processeur 32 bits (la majorit\u00e9 des cartes du march\u00e9 en 2020) utilisent l'astuce de John Carmack et son nombre magique pour calculer, non pas \\(\\sqrt{A}\\) mais \\(\\frac{1}{\\sqrt{A}}\\).</li> <li>Le flottant \\(A\\) cod\u00e9 sur 32 bits en \\(A\\) = \\((\u22121)^0 2^{e_1} (1 + m_1)\\) est consid\u00e9r\u00e9 comme l'entier \\(I_1 = 2^{23}(127 + e_1 + m_1)\\) : <code>int i1 = *(int*) &amp;a;</code>.</li> <li>Carmack utilise son nombre magique, l'entier cod\u00e9 en hexad\u00e9cimal 0x5f3759df (on a trouv\u00e9 mieux depuis) et lui soustrait \\(\\left \\lfloor\\frac{I_1}{2}\\right \\rfloor\\). Il convertit ensuite cet entier en flottant.</li> <li>Quelle que soit la valeur de \\(A\\), on peut montrer que le flottant retourn\u00e9 est proche de \\(\\frac{1}{\\sqrt{A}}\\) avec une erreur au pire de \\(\\frac{2}{\\sqrt{1000}}\\)!!</li> </ul> <p>Complexit\u00e9 temporelle en \\(O (1)\\).</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#exemples-de-complexites-de-fonctions-recursives","title":"Exemples de complexit\u00e9s de fonctions r\u00e9cursives","text":""},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#recurrences-c_n-c_n-1-1-et-c_n-c_n-1-n","title":"R\u00e9currences \\(C_n = C_{n-1} + 1\\) et \\(C_n = C_{n-1} + n\\)","text":""},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#exponentiation-naive","title":"Exponentiation na\u00efve","text":"<pre><code>let rec pow x n = \n    match n with \n    | 0 -&gt; 1\n    | _ -&gt; x * pow x (n-1);;\n</code></pre> <ul> <li>La complexit\u00e9 (dans tous les cas) est de la forme \\(C_n = C_{n-1} + 1\\) (d\u00e9j\u00e0 \u00e9tudi\u00e9 pour la facorielle)</li> <li>C'est une suite arithm\u00e9tique de raison \\(1\\).</li> <li>On a donc \\(C_n =\u0398(n)\\)</li> <li>\u00c0 noter que le second membre de la relation de r\u00e9currence est \\(1\\) puisqu'il y a un nombre d'op\u00e9rations \u00e9l\u00e9mentaires en \\(O(1)\\) (mais pas \u00e9gal \u00e0 \\(1\\), le filtrage lui-m\u00eame co\u00fbte quelques op\u00e9rations). On se simplifie la vie en prenant le terme le plus simple possible dans la classe de complexit\u00e9.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#insertion-dans-une-liste-triee","title":"Insertion dans une liste tri\u00e9e","text":"<pre><code>let rec insert l x = \n    match l with \n    | [] -&gt; [x]\n    | y::q when y &gt; x -&gt; x::l\n    | y::s -&gt; y::(insert q x);;\n</code></pre> <ul> <li>Hors appel r\u00e9cursif, il faut compter l'ajout en t\u00eate de liste (r\u00e8gle \\(3\\)) et le filtrage lui m\u00eame (il n'a pas un co\u00fbt nul, bien que constant).</li> <li>La relation de r\u00e9currence pour la complexit\u00e9 au pire est  donc \\(C_n = C_{n-1} = O(1)\\) ce que l'on simplifie en \\(C_n = C_{n-1} +1\\).</li> <li>Au mieux \\(C_n = 1\\) (r\u00e8gle de filtrage \\(1\\) et \\(2\\)).</li> <li>Complexit\u00e9 au pire \\(O(n)\\); au mieux \\(O(1)\\).</li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#tri-par-insertion","title":"Tri par insertion","text":"<pre><code>let rec tri l = \n    match l with \n    | [] -&gt; []\n    | x::q -&gt; insert x (tri q);;\n</code></pre> <ul> <li>Insertion dans <code>tri q</code>au pire en \\(O(n)\\) o\u00f9 \\(n = |l|\\). Complexti\u00e9 au pire \\(C_n = C_{n-1} + n\\) (\\(n\\) pour l'insertion au pire).</li> <li>On a donc \\(C_n - C_{n-1} = n\\) Il vient par t\u00e9lescopage \\(C_n - \\underbrace{C_0}_{\\text{cte}} = \\sum_{i=1}^n{C_i -C_{i-1}} = \\sum_{i=1}^n{i} = O(n\u00b2)\\)</li> </ul> <p>Donc \\(C_n = O(n\u00b2)\\)</p> <ul> <li>Complexit\u00e9 au mieux \\(C_n = C_{n-1} +1\\) Donc \\(C_n = O(n)\\).</li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#strategie-diviser-pour-regner","title":"Strat\u00e9gie \"diviser pour r\u00e9gner\"","text":""},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#diviser-pour-regner","title":"Diviser pour r\u00e9gner","text":"<p>M\u00e9thode</p> <ul> <li>On d\u00e9coupe la donn\u00e9e que l'on doit traiter en deux parties de tailles proches (ou plus) de tailles proches.</li> <li>On r\u00e9sout le probl\u00e8me sur les parties plus petites</li> <li>On combine les r\u00e9sultats obtenus pour construire le r\u00e9sultat correspondant \u00e0 la donn\u00e9e initiale</li> </ul> <ul> <li>Une donn\u00e9e de taille \\(n\\) est d\u00e9coup\u00e9e en deux autres donn\u00e9es de tailles \\(\\left\\lfloor \\frac{n}{2} \\right\\rfloor et\\left\\lceil \\frac{n}{2} \\right\\rceil\\).</li> <li>La complexit\u00e9 ob\u00e9it alors \u00e0 une relation de la forme\u00a0: \\(C_{n} = {aC}_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + {bC}_{\\left\\lceil \\frac{n}{2} \\right\\rceil} + f(n)\\) o\u00f9 \\((a,b) \\neq (0,0)\\) sont des constantes associ\u00e9es au probl\u00e8me et \\(f(n)\\) correspond au co\u00fbt total du partage et de la recombinaison.</li> <li>Cette r\u00e9currence est dite de type \u00abdiviser pour r\u00e9gner\u00a0\u00bb</li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#choix-du-premier-terme","title":"Choix du premier terme","text":"<p>Proposition</p> <p>Soient \\(a,b\\) deux entiers tels que \\(ab \\neq 0\\) et \\(f, g\\) deux fonctions croissantes de m\u00eame ordre de grandeur. Alors les suites (\\(U_{n}\\)) et (\\(V_{n}\\)) telles que \\(U_{0} = V_{0}\\) et pour tout \\(n \\in {\\mathbb{N}} ^\\ast\\)\u00a0:</p> <p>\\(\\begin{matrix} U_{n} = {aU}_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + {bU}_{\\left\\lceil \\frac{n}{2} \\right\\rceil} + f(n) \\\\ V_{n} = {aV}_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + {bV}_{\\left\\lceil \\frac{n}{1} \\right\\rceil} + g(n) \\\\ \\end{matrix}\\) sont du m\u00eame ordre de grandeur.</p> <p>Cette proposition (admise) justifie qu'on remplace le dernier terme par un terme plus simple de m\u00eame ordre de grandeur (donc \\(1\\) pour \\(O(1)\\), \\(n\u00b2\\) pour \\(O(n\u00b2)\\) etc.)</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#croissance-de-la-complexite-en-fonction-de-la-taille-n-de-la-donnee","title":"Croissance de la complexit\u00e9 en fonction de la taille \\(n\\) de la donn\u00e9e","text":"<p>On consid\u00e8re \\(U_{n} = f(n) + U_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + U_{\\left\\lceil \\frac{n}{2} \\right\\rceil}\\) avec \\(f\\) croissante. On pose aussi \\(u_0 = u_1 = 1\\) parce que \u00e7a nous arrange et qu'on \u00e9tudie un comportement asymptotique.</p> <p>Preuve</p> <p>On montre que \\(U_{n - 1} \\leq U_{n}\\) pour \\(n \u2265 1\\)</p> <ul> <li>Initialisation \\(1 = u\u2080 \u2264 u\u2081 = 1\\)</li> <li>H\u00e9r\u00e9dit\u00e9 Si \\(U_{k} \\geq U_{q}\\) pour tout \\(n &gt; k \u2265 q\\).</li> <li>\\(U_{n} = f(n) + U_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + U_{\\left\\lceil \\frac{n}{2} \\right\\rceil}\\) et</li> <li>\\(U_{n - 1} = f(n - 1) + U_{\\left\\lfloor \\frac{n - 1}{2} \\right\\rfloor} + Uu_{\\left\\lceil \\frac{n - 1}{2} \\right\\rceil}\\)</li> <li>Or les fonctions parties enti\u00e8res sont croissantes donc     \\(U_{\\left\\lfloor \\frac{n - 1}{2} \\right\\rfloor} \\leq U_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor}\\) et \\(U_{\\left\\lceil \\frac{n - 1}{2} \\right\\rceil} \\leq U_{\\left\\lceil \\frac{n}{2} \\right\\rceil}\\) par HR. Et \\(f(n-1) \u2264 f(n)\\) par hypoth\u00e8se.</li> <li> <p>Donc \\(U_{n} \\geq U_{n - 1}\\)</p> </li> <li> <p>Conclusion Donc \\(\\left( U_{n} \\right)\u2191\\). \\(\\color{red}\\text{En pratique, on ne refait pas cette preuve et on admet}\\) \\(\\color{red}\\text{que la complexit\u00e9 est croissante avec la taille des donn\u00e9es.}\\)</p> </li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#quelques-observations","title":"Quelques observations","text":"<p>Dans ce qui suit toutes les fonctions sont positives et \\(n \u2208 \u2115\\)</p> <ul> <li>Pour \\(a &gt; 0\\), \\(ln(n) = \u0398(log_a)\\) car \\(log_a(x) = \\frac{ln(x)}{ln(a)}\\)</li> <li>\\(n = \u0398(\\left \\lfloor n\\right \\rfloor)\\) car pour \\(n &gt; 2\\), \\(\\frac{n}{2} &lt; n-1 &lt; \\left \\lfloor n\\right \\rfloor \u2264 n\\) (de m\u00eame \\(n=\u0398(\u2308n\u2309)\\))</li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#dichotomie","title":"Dichotomie","text":"<pre><code>let dicho v x = (*Chercher x dans le tableau tri\u00e9 v*)\n    let rec cherche_entre a b =\n        if a = b then (x=v.(a))\n        else\n            let m = (a+b)/2 in\n            if v.(m) = x then true\n            else if v.(m) &gt; x then cherche_entre a (m-1)\n            else cherche_entre (m+1) b\n    in\n    cherche_entre 0 (Array.length v - 1);;\n</code></pre> <p>A chaque \u00e9tape, la zone de recherche est divis\u00e9e par \\(2\\) (au moins) (on note \\(n//2\\) la division euclidienne par \\(2\\))</p> <p>\\(x_m\\) d\u00e9signe l'\u00e9l\u00e9ment o\u00f9 on s\u00e9pare en 2 la liste. \\([x\u00a0; x\u00a0; x_m\u00a0; x\u00a0; x]\\)\u00a0: Tableau de taille impaire \\(n\\)</p> <p>Les deux sous-tableaux sont donc de taille \\(n//2\\) ou \\(n//2 +1\\)</p> <p>\\([x\u00a0; x_m\u00a0; x\u00a0; x]\\)\u00a0: Tableau de taille paire \\(n\\)</p> <p>Au moins un sous tableau est de taille \\(n//2\\)</p> <p>Hors les appels r\u00e9cursifs, il y a un nombre born\u00e9 d'autres op\u00e9rations, toutes en \\(O(1)\\). Le co\u00fbt total \u00e0 chaque tour hors appels r\u00e9cursifs est donc \\(O(1)\\).</p> <p>Pour un tableau de taille \\(n\\), la complexit\u00e9 au pire est du type \\(C_{n} = C_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + O(1);\\) simplifi\u00e9 en \\(C_{n} = C_{\\left\\lfloor \\frac{n}{2} \\right\\rfloor} + 1\\) (On cherche dans le plus grand sous-tableau pour que \u00e7a soit dans le pire cas)</p> <p>Si \\(n = 2^{p}\\) alors \\(C_{2^{p}} = C_{2^{p - 1}} + 1 = C_{2^{p - \\color{red}{2}}} + \\underbrace{1 + 1}_{\\color{red}{2}} = \\ldots = C_{2\u2070} + p = \\Theta\\left( \\log \u2082(n) \\right)\\)</p> <p>Pour un \\(n\\) quelconque, \\(2^{\\left\\lfloor \\log \u2082n \\right\\rfloor} \\leq n &lt; 2^{\\left\\lfloor \\log \u2082(n) \\right\\rfloor + 1}\\). Comme la complexit\u00e9 est croissante avec la taille du tableau, \\(C_{n} \\leq C_{2^{\\left\\lfloor \\log \u2082(n) \\right\\rfloor + 1}} = O\\left( \\left\\lfloor \\log \u2082(n) \\right\\rfloor + 1 \\right)\\). Il vient \\(C_{n} = O\\left( \\log \u2082(n) \\right)\\).</p> <p>Idem pour la minoration\u00a0: \\(C_{n} \\geq C_{2^{\\left\\lfloor \\log \u2082(n) \\right\\rfloor}} = \\Omega\\left( \\left\\lfloor \\log \u2082(n) \\right\\rfloor + 1 \\right)\\)</p> <p>Conclusion, \\(C_{n} = \\Theta\\left( \\log \u2082(n) \\right)\\)</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#exponentation-rapide","title":"Exponentation rapide","text":"<pre><code>let rec puissance_rapide x n = \n    match n with \n    | 0 -&gt; 1\n    | n when n mod 2 = 0 puissance_rapide (x*x) (n/2)\n    | _ -&gt; x * puissance_rapide x (n-1) ;; \n</code></pre> <ul> <li>Principe \\(x^{2k} = (x\u00b2)^k\\) et \\(x^{2k+1} = x \\times x^{2k}\\)</li> <li>Complexit\u00e9 en nombre de multiplications</li> <li>Lorsque \\(n\\) est paire \\(C_n = C_{\\frac{n}{2}} +1 = C_{\\left \\lfloor\\frac{n}{2}\\right \\rfloor} +1\\).</li> <li> <p>Si \\(n\\) est impaire (et \\(&gt; 1\\))</p> </li> <li> <p>Donc r\u00e9currence de la forme \\(C_n = C_{\\left \\lfloor\\frac{n}{2}\\right \\rfloor} +O(1)\\). On \u00e9tudie toujours la forme la plus simple \\(C_n = C_{\\left \\lfloor\\frac{n}{2}\\right \\rfloor} +1\\). On a vu que \\(C_n = O(log_2(n))\\)</p> </li> <li> <p>Il est pertinent ici d'exprimer la complexit\u00e9 du nombre de bits de \\(n\\) : il faut \\(\\left \\lfloor log_2(n)\\right \\rfloor + 1 = \u0398(log_2(n))\\) Donc complexit\u00e9 lin\u00e9aire en le nombre de bits de l'exposant.</p> </li> </ul>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#tri-fusion","title":"Tri fusion","text":"<p>Pour raison de commodit\u00e9, on \u00e9tudie la complexit\u00e9 d'une version non r\u00e9cursive terminale du tri fusion. On donne n\u00e9anmoins une version r\u00e9cursive terminale apr\u00e8s cette \u00e9tude.</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#division","title":"Division","text":"<p>On veut trier une liste. On s\u00e9pare l'entr\u00e9e en deux listes/deux tableaux (approximativement) de m\u00eame longueur, qu'on trie s\u00e9par\u00e9ment, puis on fusionne les deux r\u00e9sultats en comparant \u00e0 chaque fois les plus petits \u00e9l\u00e9ments.</p> <pre><code>let rec divise l = (*S\u00e9pare l en deux listes de m\u00eame taille*)\n    match l with\n    | [] -&gt; ([], [])\n    | [x] -&gt; ([x], [])\n    | x::y::q -&gt; let (l1, l2) = divise q in (x::l1, y::l2);;\n</code></pre> <ul> <li>Complexit\u00e9 temporelle est de la forme \\(C_{n} = C_{n - 2} + 1\\). Ainsi pour \\(n = 2k\\)\u00a0: \\(C_{2k} = C_{2k-2} + 1 = C_{2k-4} +1 +1 = ... = C_0 +k\\) On trouve de m\u00eame avec \\(C_{2k + 1} = C\u2081 + k\\) pour \\(n = 2k+1\\).</li> </ul> <p>Comme dans les 2 hypoth\u00e8ses de parit\u00e9 et d'imparit\u00e9, \\(k = \\left\\lfloor \\frac{n}{2} \\right\\rfloor\\), on obtient \\(C_{n} = \\Theta(n)\\)</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#fusion","title":"Fusion","text":"<p>On fusionne maintenant deux listes tri\u00e9es (par ordre croissant) en ajoutant prioritairement le plus petit \u00e9l\u00e9ment des deux listes.</p> <pre><code>let rec fusion l1 l2 = (*Fusionne deux listes tri\u00e9es*)\n    match (l1, l2) with\n    | ([], l) -&gt; l\n    | (l, []) -&gt; l\n    | (x::q, y::r) -&gt;\n        if x &lt; y then x::(fusion q l1)\n        else y::(fusion (l2) r);;\n</code></pre> <p>En dehors des appels r\u00e9cursifs, les op\u00e9rations sont en \\(O(1)\\) et en nombre born\u00e9.</p> <p>La complexit\u00e9 d\u00e9pend donc de la fa\u00e7on dont sont r\u00e9parties les donn\u00e9es dans les listes. Meilleur cas en \\(O\\left( min(|l_1|,\\ |l_2|) \\right)\\)\u00a0: lorsque tous les \u00e9l\u00e9ments de la liste la plus courte sont plus petits que ceux de la plus longue.</p> <p>Pour \u00e9viter un raisonnement qui tiendrait compte de la r\u00e9partition des donn\u00e9es, on peut \u00e9tudier la complexit\u00e9 d'une fonction manifestement plus co\u00fbteuse\u00a0mais plus simple \u00e0 \u00e9tudier : <code>fusion_couteuse</code> ci-dessous.</p> <p>La fonction suivante r\u00e9alise aussi la fusion. elle est plus co\u00fbteuse que la pr\u00e9c\u00e9dente mais plus facile \u00e0 \u00e9tudier :</p> <pre><code>let rec fusion_couteuse l1 l2 = (*Fusionne deux listes tri\u00e9es*)\n    match (l1, l2) with\n    | ([], []) -&gt; []\n    | (a::r, []) | ([], a::r) -&gt; a::(fusion_couteuse r [])\n    | (a::r, b::s) -&gt; if a &lt;= b \n        then a::(fusion_couteuse r l2)\n        else b::(fusion_couteuse l1 s);;\n</code></pre> <p>La complexit\u00e9 d\u00e9pend seulement de la somme des tailles des listes. En notant \\(n, m\\) les tailles de <code>l1, l2</code> on obtient la relation suivante\u00a0: \\(C(n+m) = C(n+m-1) + O(1)\\) et \\(C(0, 0) = 1\\)</p> <p>On \u00e9tudie donc \\(C(n+m) = C(n+m-1)+1\\). Il s'agit d'une suite arithm\u00e9tique. On a donc \\(C(n+m) = O(n+m)\\).</p> <p>Donc la complexit\u00e9 de <code>fusion</code>, toujours meilleure est aussi en \\(O(n+m)\\)</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#tri-fusion_1","title":"Tri fusion","text":"<p>Et donc pour finir le tri fusion\u00a0:</p> <pre><code>let rec tri_fusion l =\n    match l with\n    | [] -&gt; [] \n    | [e] -&gt; [e]\n    | _ -&gt;\n        let (l1, l2) = divise l in\n        fusion (tri_fusion l1) (tri_fusion l2);;\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#complexite-du-tri","title":"Complexit\u00e9 du tri","text":"<p>On note \\(n\\) la longueur de <code>l</code>, La division est en \\(\u0398(n)\\). La fusion s'applique aux deux moiti\u00e9s tri\u00e9es\u00a0; elle a ici un co\u00fbt en \\(\u0398(n)\\) (m\u00eame au meilleur cas).</p> <p>La complexit\u00e9 ob\u00e9it \u00e0 une relation diviser-pour-r\u00e9gner de la forme</p> \\[C_n = C_{\\lfloor\\frac{n}{2}\\rfloor} + C_{\\lceil\\frac{n}{2}\\rceil} + \\Theta(n) \\text{; simplifi\u00e9 en } C_n = C_{\\lfloor\\frac{n}{2}\\rfloor} + C_{\\lceil\\frac{n}{2}\\rceil} + n\\] <p>Si \\(n = 2^{k}\\) alors \\(\\left\\lfloor \\frac{n}{2} \\right\\rfloor = \\left\\lceil \\frac{n}{2} \\right\\rceil\\)(et \\(k = log\u2082 (n)\\))\u00a0:</p> \\[C_{2^k} = 2^k + 2\\times C_{2^{k-1}} = {\\color{red}{2}}\\times 2^k + 2^{\\color{red}{2}} \\times C_{2^{k-\\color{red}{2}}} = \\ldots = {\\color{red}{k}}2^k + 2^{\\color{red}{k}}C_{k-\\color{red}{k}} = \\Theta(n\\log_2 n)\\] <p>En g\u00e9n\u00e9ral, \\(2^{\\left\\lfloor \\log \u2082n \\right\\rfloor} \\leq n &lt; 2^{\\left\\lfloor \\log \u2082n \\right\\rfloor + 1}\\). Comme la complexit\u00e9 est croissante\u00a0:</p> \\[C_n \\leq C_{2^{\\left\\lfloor \\log_2 n \\right\\rfloor + 1}} = O\\left( \\overbrace{(\\lfloor \\log_2 n \\rfloor + 1)}^{O(log_2(n))} \\times \\underbrace{2^{\\lfloor \\log_2 n \\rfloor + 1}}_{O(n)} \\right ) = O(n\\log_2 n)\\] <p>Idem pour une minoration\u00a0: \\(C_n = \u0398(n \\log_2 n)\\)</p>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#tri-fusion-en-recursion-terminale","title":"Tri fusion en r\u00e9cursion terminale","text":"<p>On se donne ici une version totalement r\u00e9cursive terminale du tri fusion (on se souvient que <code>List.rev</code> est aussi en r\u00e9cursion terminale).</p> <pre><code>let rec split l l1 l2 = \n    match l with \n    | [] -&gt; l1, l2\n    | x::t -&gt; split t l2 (x::l1);;\n\nlet rec merge acc l1 l2 = \n    match l1, l2 with\n    | [], l' | l', [] -&gt; (List.rev acc) @ l'\n    | x1::t1, x2::t2 -&gt; if x1 &lt;= x2\n        then merge (x1::acc) t1 l2 else merge (x2::acc) l1 t2;;\n\nlet rec sort l = \n    match l with\n    | [] -&gt; | [_] -&gt; l\n    | _ -&gt; let l1, l2 = split l [] [] in \n        merge [] (sort l1) (sort l2) ;;\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/2-Complexit%C3%A9/#derniers-details","title":"Derniers d\u00e9tails","text":"<p>Le tri d'un tableau est dit en place si l'algorithme travaille directement sur le tableau en entr\u00e9e et n'utilise pas de tableau auxiliaire. Un tri est stable s'il conserve les positions relatives des \u00e9l\u00e9ments de m\u00eame valeur.</p> <p>Il existe une version du tri fusion pour les tableaux. Une version d\u00e9licate (mais possible) existe pour un maintien en place mais non stable.</p> <p>Le tri fusion est en \\(O(n \\times log (n))\\) au pire, au meilleur et en moyenne.</p> <p>On ne peut pas faire mieux en moyenne (voir cours sur les arbres) pour un tri par comparaison (algorithmes de tri proc\u00e9dant par comparaisons successives entre \u00e9l\u00e9ments).</p>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/","title":"Complexit\u00e9 moyenne et amortie","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li> <p>Wikipedia (Analyse amortie)</p> </li> <li> <p>\"Option informatique MPSI - MP/MP*\" Roger MANSUY (Vuibert)</p> </li> <li> <p>\"Algorithmique - 3\u00e8me \u00e9dition Cours avec 957 exercices et 158 probl\u00e8mes\" Thomas H. Cormen, Charles Leiserson, Ronald Rivest, Cli\ufb00ord Stein (Dunod)</p> </li> <li> <p>\"Informatique - MP2I/MPI - CPGE 1re et 2e ann\u00e9es\" Balabonski Thibaut, Conchon Sylvain, Filli\u00e2tre Jean-Christophe, Nguyen Kim, Sartre Laurent (ellipse)</p> </li> </ul>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#tri-rapide","title":"Tri rapide","text":"<p>Dans le tri rapide, on s\u00e9pare l'entr\u00e9e en deux listes en comparant \u00e0 un \u00e9l\u00e9ment pivot, on les trie s\u00e9par\u00e9ment et on les fusionne par concat\u00e9nation.</p> <ul> <li> <p>Dans le tri rapide, la fonction de division est d\u00e9licate et celle de fusion triviale. C'est le contraire pour le tri fusion.</p> </li> <li> <p>On donne une version pour les listes. On peut en donner une version en place pour des tableaux.</p> </li> <li> <p>Mis au point en \\(1960\\) par Tony Hoare, alors \u00e9tudiant en visite \u00e0 l'universit\u00e9 d'Etat de Moscou.</p> </li> <li> <p>Poss\u00e8de une variante Quick select pour le calcul du \\(k\\)-i\u00e8me \u00e9l\u00e9ment d'une liste sans proc\u00e9der au tri pr\u00e9alable (application : calcul de la m\u00e9diane).</p> </li> </ul>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#partition","title":"Partition","text":"<pre><code>let rec partition l p = match l with\n    | []   -&gt; [] ,[]\n    | t::q -&gt; let (l1,l2) = partition q p in\n        if t &lt;= p then (t::l1,l2) else (l1,t::l2);;\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#terminaison-de-la-partition","title":"Terminaison de la partition","text":"<p>Les cas de bases terminent et l'appel interne se fait avec une liste strictement plus courte que la liste initiale et il n'y a pas de boucle ou d'appel \u00e0 une fonction qui ne termine pas.</p> <p>C'est tout bon !</p>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#complexite-temporelle-de-la-partition","title":"Complexit\u00e9 temporelle de la partition","text":"<p>Dans tous les cas de la forme \\(C_{n} = C_{n} - 1 + 1\\) pour une liste de taille \\(n\\). Lin\u00e9aire.</p>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#correction-par-induction","title":"Correction par induction","text":"<p>Montrons que la fonction retourne deux listes dont la 1ere contient tous les \u00e9l\u00e9ments de \\(l\\) plus petits que le pivot, les \u00e9l\u00e9ments strictement plus grands \u00e9tant dans la seconde.</p> <ul> <li>Cas de base : OK de fa\u00e7on \u00e9vidente</li> <li>H\u00e9r\u00e9dit\u00e9 : Supposons que <code>partition q p</code> partitionne correctement <code>q</code> en \\(l_1, l_2\\). Supposons aussi \\(t \u2264 p\\). Alors dans le tuple retourn\u00e9 :</li> <li>On ajoute \\(t\\) \u00e0 la liste \\(l_1\\) des \u00e9l\u00e9ments de \\(q\\) plus petits que \\(p\\). On obtient exactement tous les \u00e9l\u00e9ments de \\(l\\) plus petits que le pivot.</li> <li>La liste \\(l_2\\) est constitu\u00e9e exactement des \u00e9l\u00e9ments de \\(q\\) strictement plus grands que \\(p\\) ; donc (puisque \\(t \u2264 p\\)) exactement ceux ceux de \\(l\\).</li> <li>Correction OK. Le cas \\(t &gt; p\\) cas est laiss\u00e9 au lecteur.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#algorithme","title":"Algorithme","text":"<pre><code>let rec tri_rapide l = match l with\n    | [] -&gt; []\n    | t::q -&gt; let (l1,l2) = partition q t in\n        (tri_rapide l1)@(t::(tri_rapide l2));;\n</code></pre>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#terminaison","title":"Terminaison","text":"<ul> <li>Variant \\(|l|\\).</li> <li>Le cas de base termine (envoie de la liste vide).</li> <li>L'appel \u00e0 <code>partition</code> termine (d\u00e9j\u00e0 vu).</li> <li>Seulement deux appels internes, tous deux e\ufb00ectu\u00e9s avec des listes de taille strictement inf\u00e9rieure \u00e0 \\(|l|\\) (puisque \\(|l1| + |l2| = |l| \u2212 1\\)).</li> <li>Terminaison OK.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#correction","title":"Correction","text":"<p>Preuve par induction</p> <p>Cas de base : OK.</p> <p>Supposons que les deux appels internes retournent une version tri\u00e9e de <code>l1</code> et de <code>l2</code>.</p> <ul> <li>Par correction de partition : <code>l1</code> contient les \u00e9l\u00e9ments de <code>q</code> plus petits ou \u00e9gaux au pivot et <code>l2</code> les \u00e9l\u00e9ments strictement plus grands.</li> <li>La concat\u00e9nation retourn\u00e9e<ul> <li>est tri\u00e9e : d'abords les \u00e9l\u00e9ments plus petits que le pivot     rang\u00e9s dans l'ordre, puis le pivot, puis les \u00e9l\u00e9ments plus grands que le pivot rang\u00e9s dans l'ordre.</li> <li>contient exactement tous les \u00e9l\u00e9ments de <code>q</code> (puisque la r\u00e9union de <code>l1</code> et <code>l2</code> les contient) plus l'\u00e9l\u00e9ment manquant <code>t</code> .</li> <li>La concat\u00e9nation est la version tri\u00e9e de <code>l</code> .</li> </ul> </li> </ul> <p>H\u00e9r\u00e9dit\u00e9 OK</p> <p>Preuve par r\u00e9currence</p> <p>Cas de base : OK.</p> <p>\\(\\color{red}\\text{Supposons que le tri soit correct pour des tailles de liste} \u2264 n\\). Par HR, les deux appels sur \\(l_1\\) et \\(l_2\\) retournent une version tri\u00e9e de <code>l1</code> et de <code>l2</code>.</p> <ul> <li>Par correction de <code>partition</code> : <code>l1</code> contient les \u00e9l\u00e9ments de <code>q</code> plus petits ou \u00e9gaux au pivot et <code>l2</code> les \u00e9l\u00e9ments strictement plus grands.</li> <li>La concat\u00e9nation retourn\u00e9e<ul> <li>est tri\u00e9e : d'abords les \u00e9l\u00e9ments plus petits que le pivot     rang\u00e9s dans l'ordre, puis le pivot, puis les \u00e9l\u00e9ments plus grands que le pivot rang\u00e9s dans l'ordre.</li> <li>contient exactement tous les \u00e9l\u00e9ments de <code>q</code> (puisque la r\u00e9union de <code>l1</code> et <code>l2</code> les contient) plus l'\u00e9l\u00e9ment manquant <code>t</code> .</li> <li>La concat\u00e9nation est la version tri\u00e9e de <code>l</code> .</li> </ul> </li> </ul> <p>H\u00e9r\u00e9dit\u00e9 OK</p>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#tri-rapide-complexite-en-nombre-de-comparaisons","title":"Tri rapide : complexit\u00e9 en nombre de comparaisons","text":""},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#cas-ou-lune-des-listes-est-toujours-vide","title":"Cas o\u00f9 l'une des listes est toujours vide","text":"<p>Supposons que l'une des listes retourn\u00e9e par partition soit vide \u00e0 chaque fois (cela se produit par exemple si la liste est d\u00e9j\u00e0 tri\u00e9e).</p> <p>On d\u00e9signe par \\(T_n\\) la complexit\u00e9 temporelle en nombre de compraisons pour une liste tri\u00e9e de taille \\(n\\).</p> <ul> <li>Alors Tn v\u00e9ri\ufb01e une relation de la forme \\(Tn = Tn\u22121 + n \u2212 1\\). (\\(n \u2212 1\\) : nombre de comparaisons dans <code>partition</code>). Remarquons au passage que \\(T_1 = 0\\)  (aucune comparaison) et que \\(T_{1-1} + 1 - 1 = 0 = T_1\\)</li> <li>Complexit\u00e9 en somme des premiers entiers soit \\(O(n^2)\\).</li> <li>On montre dans la suite que ce cas est bien le pire, c'est \u00e0 dire que la complexit\u00e9 \\(C_n\\) en nombre de comparaisons est la pire si le pivot est \u00e0 une extr\u00e9mit\u00e9 et donc que \\(C_n = T_n\\).</li> </ul> <p>Hypoth\u00e8se de r\u00e9currence selon \\(n\\)\u00a0(\\(= HR(n)\\)): \\(\\forall q \\leq n\\)\u00a0:</p> <ol> <li>\\(T_{q}\\) est la pire complexit\u00e9</li> <li> <p>\\(\\forall k \\in \\{ 1,\\ldots,n\\},T_{k - 1} + T_{n - k} + n\u20131 \\leq T_{n}\\) (avec \u00e9galit\u00e9 si \\(k=1\\))</p> </li> <li> <p>Cas de base :  \\(n = 1\\), \\(T_0 = 0 = T_1,k \\in \\{ 1\\}.\\) Alors \\(T_{1 - 1} + T_{1 - 1} + 1\u20131 = 0 \\leq T_1\\) et \\(T_1\\) est la pire complexit\u00e9. OK</p> </li> <li> <p>Si \\(HR(n)\\) est v\u00e9rifi\u00e9e. Soit \\(k \\in \\{ 1,\\ldots,n + 1\\}\\)</p> \\[\\begin{matrix} T_{k - 1} + \\textcolor{red}{T_{n + 1\u2013k}} + n &amp;\\underset{\\text{def. de T}}{=} &amp; T_{k - 1} + \\textcolor{red}{T_{n - k} + (n - k)} + n\u20131 + 1\\\\ &amp;&amp; \\\\ &amp;\\underset{\\text{HR(n)}}{\\leq} &amp; T_{n} + (n\u2013k + 1) \\leq T_{n} + n \\\\ &amp;&amp; \\\\ &amp; = &amp; T_{n + 1} \\end{matrix} \\] <p>C'est ce qu'on veut.</p> </li> <li> <p>Soit \\(l\\) une liste \\(\\color{red}\\text{quelconque}\\) de longueur \\(n+1\\) partitionn\u00e9e lors de l'appel <code>partition q</code>en deux sous-listes \\(l_1, l_2\\) de longueur \\(k\\) et \\(n-k\\) (\\(k \u2265 0\\)). Notons \\(C^l_{n+1}\\) la complexit\u00e9 exavte en nombre de comparaisons de l'appel <code>tri_rapide l</code>; \\(C^{l_1}_{n+1}\\) (resp. \\(C^{l_2}_{n+1}\\)) les complexit\u00e9s de <code>tri_rapide l1</code> (resp. <code>tri_rapide l2</code>).</p> </li> <li>Si \\(l_i\\) est vide \\(C^l_{n+1} = C^{l_j}_{n} + n \\leq T_n + n\\) par HR donc \\(C^l_{n+1} = T_{n+1}\\).</li> <li>Si \\(|l_1|\\times|l_2| \u2260 0\\) alors \\(1 \u2264 k \u2264 n-1\\) et :</li> </ol> <p>\\(\\(\\begin{matrix} C^l_{n+1} &amp; = &amp; C^{l_1}_{k} + C^{l_1}_{n-k} +n \\\\ &amp; &amp; \\\\ &amp; \\underbrace{\u2264}_{HR(n)} &amp; T_k + T_{n-k} + n \\\\ &amp;&amp; \\\\ &amp; \\underbrace{=}_{\\begin{matrix}k'= k+1  \\\\ k' \\in \u27e62,n \u27e7\\end{matrix}} &amp; T_{k'-1} + T_{n+1-k'} + n \\\\ &amp; &amp; \\\\ &amp; \u2264 &amp; T_{n+1} \\end{matrix}\\)\\) (d'apr\u00e8s la preuve du transparent pr\u00e9c\u00e9dent)</p> <ul> <li>Ainsi, \\(\\color{red}l \\text{ \u00e9tant quelconque}\\), \\(T_{n+1}\\) est la pire complexit\u00e9 possible. IZP !</li> </ul>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#complexite-moyenne-du-tri-rapide","title":"Complexit\u00e9 moyenne du tri rapide","text":"<p>La complexit\u00e9 moyenne \\(C(n)\\) du tri rapide pour une liste de taille \\(n\\) est la moyenne des complexit\u00e9s pour les di\ufb00\u00e9rentes positions du pivot.</p> <p>Elle v\u00e9ri\ufb01e (si la position \ufb01nale du pivot est \u00e9quiprobable) :</p> \\[\\begin{matrix}C(n) &amp;=&amp; \\frac{1}{n} \\sum_{k=0}^{n-1}(C(k)+C(n-k-1)+n-1)\\\\ &amp; &amp; \\\\     &amp;=&amp; n-1+\\frac{1}{n}\\sum_{k=0}^{n-1}(C(k) + C(n-k-1)) \\end{matrix} \\] <p>On constate que chaque terme appara\u00eet deux fois.</p> <p>Alors \\(C(n) = n - 1 + \\frac{2}{n}\\sum_{k = 0}^{n - 1}C(k)\\) donc \\(nC(n) = 2\\sum_{k = 0}^{n - 1}C(k) + n(n - 1)\\) et donc ainsi\u00a0:</p> \\[ \\begin{align} nC(n) - (n-1)C(n-1) &amp;\\underbrace =_\\text{def} \\textcolor{red}{2\\sum_{k=0}^{n-1}C(k)}+n(n-1)-(n-1)C(n-1) \\nonumber\\\\     &amp;= \\textcolor{red}{2C(n-1)+2\\sum_{k=0}^{n-2}C(k) + (n-1)(n-2)}- (n-1)(n-2) +n(n-1) - (n-1)C(n-1) \\nonumber\\\\     &amp;= 2C(n-1) +\\textcolor{red}{(n-1)C(n-1)}-(n-1)(n-2) + n(n-1)-(n-1)C(n-1) \\nonumber\\\\     &amp;= 2C(n-1)+n(n-1)-(n-1)(n-2) \\nonumber\\\\     &amp;\\Rightarrow nC(n)-(n-1)C(n-1) = 2(n-1) \\nonumber \\end{align} \\] <p>Il vient ainsi</p> <p>\\(\\frac{C(n)}{n + 1}\u2013\\frac{C(n - 1)}{n} = \\frac{2(n - 1)}{n(n + 1)} = \\frac{4}{n + 1}\u2013\\frac{2}{n}\\) (d\u00e9composition en \u00e9l\u00e9ments simples)</p> <p>Par t\u00e9lescopage, et puisque \\(C(0) = 0\\)\u00a0:</p> <p>\\(\\begin{matrix} \\frac{C(n)}{n + 1}\u2013\\frac{C(0)}{1} &amp;=&amp; \\frac{C(n)}{n + 1} \\\\ &amp; &amp;\\\\  &amp;=&amp;4\\sum_{k = 1}^{n}{\\frac{1}{k + 1}}\u20132\\sum_{k = 1}^{n}{\\frac{1}{k}} \\\\ &amp; &amp;\\\\  &amp;=&amp; 4\\sum_{k = 2}^{n + 1}{\\frac{1}{k}} - 2\\sum_{k = 1}^{n}{\\frac{1}{k}} \\\\ &amp; &amp;\\\\  &amp;=&amp; 2\\sum_{k = 2}^{n}\\frac{1}{k} + \\frac{4}{n + 1} - 2 \\\\ &amp; &amp;\\\\  &amp;=&amp; 2\\sum_{k = 1}^{n}{\\frac{1}{k}} + {\\frac{4}{n + 1}\u20134} \\leq 2\\underset{\\color{red}\\sim \\ln(n)}{\\underbrace{\\sum_{k = 1}^{n}{\\frac{1}{k}}}} + \\underset{\\color{red}O\\left( \\frac{1}{n} \\right)}{\\underbrace{\\frac{4}{n + 1}}} \\\\ \\end{matrix}\\)</p> <p>Sachant que \\(\\sum_{k = 1}^{n}{\\frac{1}{k}} = \\ln n + \\gamma + O\\left( \\frac{1}{n} \\right)\\) o\u00f9 \\(\u03b3\\) est la constante d'Euler (\\(\\gamma \\simeq 0,577\\)) alors\u00a0:</p> \\[\\frac{C(n)}{n+1} = (2 \\ln n + 2\\gamma + O(\\frac{1}{n}))+\\frac{4}{n+1}-4=2\\ln n +2\\gamma + O(\\frac{1}{n}) -4\\] <p>Donc \\(C(n) = O\\left( n\\log n \\right)\\).</p> <p>On peut minorer de la m\u00eame fa\u00e7on, (en exo : utiliser \\(\\sum_{k=1}^{n}{\\frac{1}{k}} &gt; \\ln(n)\\) apcr) donc \\(C_{n} = \\Theta\\left( n\\log n \\right)\\)</p>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#complexite-amortie","title":"Complexit\u00e9 amortie","text":""},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#presentation","title":"Pr\u00e9sentation","text":"<p>L'analyse amortie est une m\u00e9thode d'\u00e9valuation de la complexit\u00e9 temporelle des op\u00e9rations sur une structure de donn\u00e9es (tableaux, piles, \ufb01les, arbres...).</p> <p>Elle consiste principalement \u00e0 majorer le co\u00fbt cumul\u00e9 d'une suite d'op\u00e9rations pour attribuer \u00e0 chaque op\u00e9ration la moyenne de cette majoration, en prenant en compte le fait que les cas chers surviennent rarement et isol\u00e9ment et \\(\\color{red}\\textsf{compensent les cas bon march\u00e9}\\).</p>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#exemple-du-compteur-binaire","title":"Exemple du compteur binaire","text":"<p>On veut repr\u00e9senter, pour un entier \\(n\\), tous les tableaux possibles de boul\u00e9ens de longueur \\(n\\).</p> <p>Un tel tableau <code>t</code> peut \u00eatre vu comme la repr\u00e9sentation binaire d'en entier positif sur \\(n\\) bits. Il y en a \\(2n \u2212 1\\). On choisit la version little endian (bit de poids faible en <code>t[0])</code>, donc \\(1\\) s'\u00e9crit</p> 1 0 0 0 <p>Pour avoir tous les tableaux, on part du tableau enti\u00e8rement nul et on lui applique it\u00e9rativement un incr\u00e9ment de \\(1\\) (donc \\(2^n\\) fois) :</p> <pre><code>void incr(bool c[], int n){\n    int i = 0;\n    while(i&lt;n &amp;&amp; c[i]==1){ \n        c [i] = 0 ;\n        i++; //propagation de la retenue\n    }\n    if (i&lt;n) c[i] = 1 ;\n}\n</code></pre> <p>Nous voulons mesurer la complexit\u00e9 de cette fonction en nombre d'acc\u00e8s aux \u00e9l\u00e9ments du tableau.</p>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#analyse-grossiere","title":"Analyse grossi\u00e8re","text":"<p>Pour un tableau de taille \\(n\\).</p> <ul> <li>La complexit\u00e9 d\u00e9pend du nombre de tour dans la boucle while.</li> <li>Meileur cas : si <code>t[0] == 0</code> , alors pas de passage dans la boucle, deux acc\u00e8s seulement (en lecture puis \u00e9criture).</li> <li>Pire cas : tous les bits \u00e0 \\(1\\). Pour chacun des \\(n\\) passages, un acc\u00e8s en lecture puis un en \u00e9criture. \\(2n\\) acc\u00e8s .</li> <li>Dans le pire cas, la complexit\u00e9 est en \\(O(n)\\) pour un tableau.</li> <li>Majorer le co\u00fbt des \\(2^n\\) appels \u00e0 incr : \\(2n2^n = n2^{n+1}\\).</li> <li>C'est trop impr\u00e9cis car passer \\(n\\) fois dans la boucle arrive exceptionnellement.</li> </ul> <p>Exemple</p> Num\u00e9ro Param\u00e8tre Nombre de tours \\(0\\) \\(0000 . . . 0\\) \\(0\\) \\(1\\) \\(1000 . . . 0\\) \\(1\\) \\(2\\) \\(0100 . . . 0\\) \\(0\\) \\(3\\) \\(1100 . . . 0\\) \\(2\\) \\(4\\) \\(0010 . . . 0\\) \\(0\\) \\(5\\) \\(1010 . . . 0\\) \\(1\\) \\(6\\) \\(0110 . . . 0\\) \\(0\\) \\(7\\) \\(1110 . . . 0\\) \\(3\\) \\(8\\) \\(0001 . . . 0\\) \\(0\\) \\(9\\) \\(1001 . . . 0\\) \\(1\\) \\(10\\) \\(0101 . . . 0\\) \\(0\\) \\(11\\) \\(1101 . . . 0\\) \\(2\\) \\(12\\) \\(0011 . . . 0\\) \\(0\\) \\(13\\) \\(1011 . . . 0\\) \\(1\\) \\(14\\) \\(0111 . . . 0\\) \\(0\\) \\(15\\) \\(1111 . . . 0\\) \\(4\\) <p>Total : \\(14\\) passages dans while</p> <p>Sur \\(16\\) appels cons\u00e9cutifs \u00e0 <code>incr</code> :</p> <ul> <li> <p>Un appel sur \\(2\\) : \\(0\\) tour de boucle ;</p> </li> <li> <p>Un appel sur \\(4\\) : \\(1\\) tours de boucle ;</p> </li> <li> <p>Un appel sur \\(8\\) : \\(2\\) tours de boucle ;</p> </li> <li> <p>Un appel sur \\(16\\) : \\(3\\) tours de boucle ;</p> </li> </ul>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#cadre-detude-de-complexite-amortie","title":"Cadre d'\u00e9tude de complexit\u00e9 amortie","text":"<p>On e\ufb00ectue une \u00e9tude de complexit\u00e9 amortie pour des algorithmes qui</p> <ul> <li>ont une faible complexit\u00e9 pour de nombreuses entr\u00e9es ;</li> <li>sont co\u00fbteux pour certaines entr\u00e9es (peu nombreuses en proportion) ;</li> <li>v\u00e9ri\ufb01ent que dans toute s\u00e9quence d'appel \u00e0 l'algorithme, les entr\u00e9es co\u00fbteuses interviennent assez rarement pour que le co\u00fbt moyen reste faible.</li> </ul>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#differentes-methodes","title":"Di\ufb00\u00e9rentes m\u00e9thodes","text":"<p>Il y a \\(3\\) m\u00e9thodes usuelles d'analyse amortie : la m\u00e9thode de l'agr\u00e9gat, la m\u00e9thode comptable et la \\(\\color{red}\\textsf{m\u00e9thode du potentiel}\\) (seule \u00e9tudi\u00e9e ici).</p> <p>M\u00e9thode du potentiel : A chaque entr\u00e9e possible \\(x\\), on associe un nombre positif ou nul \\(\u03c6(x)\\) dit potentiel. Il repr\u00e9sente un co\u00fbt latent dans l'entr\u00e9e mais pas encore r\u00e9alis\u00e9.</p> <p>Une s\u00e9quence d'un algorithme ayant de bonnes propri\u00e9t\u00e9s de complexit\u00e9 amortie alterne entre :</p> <ul> <li>de (nombreuses) op\u00e9rations de faible co\u00fbt faisant monter progressivement le potentiel,</li> <li>et de (peu nombreuses) op\u00e9rations de co\u00fbt \u00e9lev\u00e9 faisant diminuer brusquement le potentiel.</li> </ul> <p>Dans l'exemple du compteur binaire, le potentiel est le nombre de \\(1\\) dans le tableau.</p>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#cout-amorti-dune-operation","title":"Co\u00fbt amorti d'une op\u00e9ration","text":"<p>D\u00e9finition : Co\u00fbt amorti</p> <p>Soit une op\u00e9ration \\(op\\) dont l'ex\u00e9cution produit une sortie \\(x_{s}\\) \u00e0 partir d'une entr\u00e9e \\(x_{e}\\). Le co\u00fbt r\u00e9el \\(C\\) de \\(op\\) est la complexit\u00e9 temporelle de son ex\u00e9cution. Son co\u00fbt amorti \\(A\\) et la somme du co\u00fbt r\u00e9el et de la variation de potentiel : \\(A = C + \\varphi(x_s) - \\varphi(x_e)\\).</p> <p>Dans cette d\u00e9\ufb01nition, les entr\u00e9es et sorties repr\u00e9sentent au sens large ce qui est donn\u00e9 \u00e0 l'algorithme (param\u00e8tres, \u00e9tat de la m\u00e9moire au d\u00e9but de l'appel) et ce qu'il produit (r\u00e9sultats renvoy\u00e9s, \u00e9tat de la m\u00e9moire en sortie).</p> <p>Une s\u00e9quence d'op\u00e9rations cons\u00e9cutives est une suite d'appels \u00e0 un algorithme de sorte que chaque sortie d'un appel soit l'entr\u00e9e du suivant.</p> <p>On montre que le co\u00fbt r\u00e9el est toujours inf\u00e9rieur au co\u00fbt amorti.</p>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#theoreme-damortissement","title":"Th\u00e9or\u00e8me d'amortissement","text":"<p>Th\u00e9or\u00e8me</p> <p>Soit une suite de \\(n\\) op\u00e9rations \\(x_0\\overset{op_1}\u2192x_1\\overset{op_2}\u2192x_2 . . .\\overset{op_n}\u2192x_n\\) \u00e0 partir d'une entr\u00e9e \\(x_0\\) telle que \\(\u03c6(x_0) = 0\\). En notant \\(C_i\\) le co\u00fbt r\u00e9el de l'op\u00e9ration \\(op_i\\) et \\(A_i\\) son co\u00fbt amorti, on a la relation d'amortissement suivante :</p> \\[\\sum_{i=1}^{n}C_i \\leq \\sum_{i=1}^{n}A_i\\] <p>Preuve</p> \\[ \\sum_{i=1}^{n}A_i = \\sum_{i=1}^{n}C_i + \\sum_{i=1}^{n}(\\varphi(x_i) - \\varphi(x_{i-1})) = \\sum_{i=1}^{n}C_i + \\varphi(x_n) - \\varphi(x_0) \\geq \\sum_{i=1}^{n}C_i\\]"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#corollaire-au-th-damortissement","title":"Corollaire au th. d'amortissement","text":"<p>Corollaire</p> <p>Avec les notations du th. d'amortissement, si le co\u00fbt amorti est born\u00e9 par une constante \\(k\\), alors la complexit\u00e9 moyenne au sein d'une s\u00e9quence arbitraire de \\(n\\) op\u00e9rations est born\u00e9e par \\(k\\).</p> <p>D\u00e9monstration</p> \\[\\sum_{i=1}^n C_i \\underbrace{\\leq}_{\\textsf{par th. d'amortissement}} \\sum_{i=1}^n A_i \\leq \\sum_{i=1}^n k = k\\times n\\]"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#retour-au-compteur-binaire","title":"Retour au compteur binaire","text":"<p>Complexit\u00e9 en nombre d'acc\u00e8s aux cases du tableau :</p> <p>Soit \\(k\\) le nombre de \\(1\\) cons\u00e9cutifs depuis la position \\(0\\). L'appel <code>incr(c,n)</code> r\u00e9alise :</p> <ul> <li> <p>\\(2(k + 1)\\) acc\u00e8s m\u00e9moire si \\(k &lt; n\\).</p> </li> <li> <p>\\(2n\\) acc\u00e8s si \\(k = n\\).</p> </li> </ul> <p>On d\u00e9\ufb01nit le potentiel \\(\u03c6(c)\\) du tableau \\(c\\) par</p> \\[\\Phi(c) = 2 \\times \\underbrace{(\\textsf{nombre de 1 dans c})}_{|c|_{1}} \\] <p>Si \\(c_{i}\\) poss\u00e8de \\(k\\) bits \\(1\\) cons\u00e9cutifs depuis la position \\(0\\), alors soit \\(k'\\) tel que \\(|c|_{1} = k + k\u2019\\). Une application de <code>incr</code>, transforme \\(c_{i}\\) en \\(c_{i + 1}\\).</p> <p>Le delta de potentiel est :</p> \\[\\phi(c_{i+1}) - \\phi(c_i) = \\left \\{ \\begin{matrix}  2(k\u2019 + 1) - 2(k + k\u2019) =  2 - 2k &amp;  \\text{ si k diff\u00e9rent de n} \\\\  -2k &amp;   \\text{ si } k = n \\text{ car alors } c_{i+1} = 00...0 \\end{matrix}\\right.\\] <p>Complexit\u00e9 en nombre d'acc\u00e8s aux cases du tableau :</p> \\[A_{i+1} = C_{i+1} + \\phi(c_{i+1}) - \\phi(c_i) =\\left \\{ \\begin{matrix}  (2k + 1) +2 -2k = 3 &amp;  \\text{ si } k \u2260 n \\\\  2k -2k = 0 &amp;   \\text{ si } k = n \\end{matrix}\\right.\\] <p>On en d\u00e9duit que la complexit\u00e9 amortie est born\u00e9e par \\(3\\). D'apr\u00e8s le corollaire du th. d'amortissement, toute s\u00e9quence d'incr\u00e9mentation commen\u00e7ant en \\(00 . . . 0\\) r\u00e9alise moins de \\(3\\) op\u00e9rations d'acc\u00e8s au tableau par appel \u00e0 <code>incr</code>.</p>"},{"location":"Analyse%20d%27algorithmes/3-Complexit%C3%A9%20moyenne%20et%20amortie/#complexite-moyen-vs-complexite-amortie","title":"Complexit\u00e9 moyen vs complexit\u00e9 amortie","text":"<p>La complexit\u00e9 moyenne est une moyenne (donc calcul\u00e9e avec des probabilit\u00e9s)</p> <p>Elle donne :</p> <ul> <li>Une complexit\u00e9 suppos\u00e9e repr\u00e9sentative du plus grand nombre d'entr\u00e9e ;</li> <li>Sans apporter aucune garantie sur la complexit\u00e9 d'une op\u00e9ration particuli\u00e8re ni m\u00eame sur une s\u00e9quence particuli\u00e8re d'op\u00e9rations.</li> </ul> <p>La complexit\u00e9 amortie apporte une borne garantie \u00e0 toute s\u00e9quence d'op\u00e9ration.</p> <ul> <li>Son calcul n'utilise pas de probabilit\u00e9 ;</li> <li>Elle ne dit rien de la complexit\u00e9 d'une op\u00e9ration particuli\u00e8re mais assure un \u00e9quilibre \u00e0 toute s\u00e9quence d'op\u00e9rations.</li> </ul>"},{"location":"Arbres/1-Induction_structurelle/","title":"Induction structurelle","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Arbres/1-Induction_structurelle/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"Arbres/1-Induction_structurelle/#objets-inductifs","title":"Objets inductifs","text":"<p>Pr\u00e9sentation informelle</p> <p>Les objets inductifs sont des objets construits progressivement \u00e0 partir d'objets de m\u00eame nature.</p> <p>Les objets inductifs sont d\u00e9crits par deux choses :</p> <ol> <li>un ou plusieurs objets de base (qui forment le point de d\u00e9part de toute construction) ;</li> <li>une ou plusieurs r\u00e8gles de combinaisons (qui permettent de former des objets plus grands)</li> </ol> <p>Exemple</p> <p>Les constructions en Lego :</p> <ul> <li>les briques et les plaques sont des constructions de base</li> <li>A partir de deux constructions en Lego, on obtient une troisi\u00e8me en les embo\u00eetant.</li> </ul> <p>Exemple des listes en OCaml</p> <p>Cas de base : la liste vide <code>[]</code></p> <p>R\u00e8gle de combinaison : si <code>l</code> est une liste et <code>e</code> un \u00e9l\u00e9ment, alors <code>e::l</code> est une nouvelle liste qui contient un \u00e9l\u00e9ment de plus que la queue <code>l</code> .</p> <p>Exemple : les entiers de Peano</p> <p>Cas de base : L'entier z\u00e9ro, not\u00e9 \\(Z\\) est un nombre entier naturel.</p> <p>R\u00e8gle de construction : si \\(n\\) est un entier naturel, alors son successeur, not\u00e9 \\(S(n)\\) est encore un entier naturel.</p> <p>3 se note \\(S(S(S(Z)))\\).</p>"},{"location":"Arbres/1-Induction_structurelle/#fonction-sur-les-termes","title":"Fonction sur les termes","text":"<p>Pour d\u00e9finir une fonction sur les termes, on se donne autant d'\u00e9quations que de constructeurs. On d\u00e9finit l'addition \\(+ : \\mathbb{N} \u00d7 \\mathbb{N} \u2192 \\mathbb{N}\\) par : \\(\\left\\{\\begin{matrix} Z + m = m  \\\\ S(n) + m = S(n + m) \\end{matrix}\\right.\\)</p> <p>Exemple</p> <p>(en d\u00e9signant \\(Z\\) par \\(0\\), \\(2\\) par \\(S(S(Z))\\)) etc.</p> <p>\\(2 + 3 = S(1) + 3 = S(1 + 3) = S(S(0) + 3) = S(S(0 + 3)) = S(S(3)) = 5\\).</p>"},{"location":"Arbres/1-Induction_structurelle/#constructeurs","title":"Constructeurs","text":"<p>On utilise une syntaxe proche de OCaml.</p> <p>A chaque objet de base et chaque mani\u00e8re de construire un nouvel objet \u00e0 partir d'objets plus petits sont associ\u00e9s un symbole appel\u00e9 constructeur.</p> <p>Tout objet est alors construit comme une combinaison d'applications explicites de ces constructeurs.</p>"},{"location":"Arbres/1-Induction_structurelle/#constructeurs-arites-termes","title":"Constructeurs, arit\u00e9s, termes","text":"<p>D\u00e9finition : Constructeur</p> <p>Un constructeur est un symbole attendant un nombre fixe d'arguments. Ce nombre est l'arit\u00e9 du constructeur.</p> <p>Pour d\u00e9finir un ensemble \\(E\\) d'objets inductifs, on fournit une signature, c.a.d un ensemble de constructeurs. Les \u00e9l\u00e9ments de \\(E\\), appel\u00e9s termes sont alors construits en utilisant exclusivement la r\u00e8gle suivante :    - Si c est un constructeur d'arit\u00e9 n et si \\(t_1,...,t_n\\) sont \\(n\\) termes alors l'application \\(c(t_1,...,t_n)\\) forme un terme.</p>"},{"location":"Arbres/1-Induction_structurelle/#sous-termes-immediats","title":"Sous-termes imm\u00e9diats","text":"<p>Si \\(t=c(t_1,...,t_n)\\), on dit que \\(t_1\\) (ou \\(t_2\\) etc.) est un sous-terme imm\u00e9diat de \\(t\\). Dans la notation,</p> \\[t=c(c(t_2,t_3),t_1)\\] <p>On a \\(t_1\\) qui est un sous-terme imm\u00e9diat de \\(t\\) mais \\(t_2,t_3\\) sont des sous-termes (non imm\u00e9diats)</p>"},{"location":"Arbres/1-Induction_structurelle/#cas-de-bases-cas-de-combinaisons","title":"Cas de bases, cas de combinaisons","text":"<p>Un constructeur \\(c\\) d'arit\u00e9 z\u00e9ro est lui-m\u00eame un terme. Un tel constructeur est appel\u00e9 une constante et forme un cas de base.</p> <p>Un constructeur \\(c\\) d'arit\u00e9 non nulle doit n\u00e9cessairement \u00eatre appliqu\u00e9 \u00e0 plusieurs termes d\u00e9j\u00e0 construits pour former un nouveau terme. Cela repr\u00e9sente un cas de combinaison.</p> <p>Un constructeur n-aire est un constructeur d'arit\u00e9 \\(n\\). On parle de constructeurs unaires, binaires, ternaires pour les arit\u00e9s \\(1, 2, 3\\)</p>"},{"location":"Arbres/1-Induction_structurelle/#structure-des-termes","title":"Structure des termes","text":"<p>D\u00e9finition : Sous termes imm\u00e9diats</p> <p>Les termes \\(t_1\\) \u00e0 \\(t_n\\) utilis\u00e9s pour construire un terme \\(t=c(t_1,...,t_n)\\) sont appel\u00e9s sous-termes imm\u00e9diats de \\(t\\). Deux termes sont \u00e9gaux si et seulement si ils sont construits de la m\u00eame fa\u00e7on, c'est \u00e0 dire \u00e0 partir des m\u00eames sous-termes, combinas par les m\u00eames constructeurs</p> <p>Remarque</p> <p>Cette \u00e9galit\u00e9 est syntaxique. </p> <p>Contre-exemple : L'\u00e9galit\u00e9 dans \\(\\mathbb{Q}\\) n'est pas seulement syntaxique. En e\ufb00et \\(\\frac{6}{4}\\) est \u00e9gal \u00e0 \\(\\frac{3}{2}\\).</p>"},{"location":"Arbres/1-Induction_structurelle/#precisions","title":"Pr\u00e9cisions","text":"<p>Sauf mention du contraire, on ne consid\u00e8re que des termes finis : ceux qui peuvent \u00eatre form\u00e9s \u00e0 partir d'un nombre fini d'applications de constructeurs.</p> <p>Un ensemble inductif \\(E\\) dont la signature contient au moins un symbole de constante est non vide.</p> <p>Une signature peut tr\u00e8s bien contenir une infinit\u00e9 de symboles (mais les termes n'en utilisent qu'un nombre fini).</p>"},{"location":"Arbres/1-Induction_structurelle/#signature-typee","title":"Signature typ\u00e9e","text":"<p>Parfois, on impose que chaque \u00e9l\u00e9ment d'un constructeur soit d'une nature pr\u00e9cise.</p> <p>Par exemple dans <code>e::l</code>, on s'attend \u00e0 ce que <code>e</code> et <code>l</code> aient des types di\ufb00\u00e9rents. Le premier est de type \u00e9l\u00e9ment et le second de type liste d'\u00e9l\u00e9ments.</p> <p>On peut donc utiliser une notation de type</p> \\[c\\text{ : }E_1 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 E_n \u2192 E\\] <p>pour indiquer qu'un constructeur \\(c\\) d'arit\u00e9 \\(n\\) attend des arguments pris dans les ensembles respectifs \\(E_1, . . . , E_n\\).</p> <p>Avec cette convention, \\(c\\) \\(:\\) \\(E\\) d\u00e9signe que \\(c\\) est une constante de l'ensemble \\(E\\) .</p>"},{"location":"Arbres/1-Induction_structurelle/#ordre-structurel","title":"Ordre structurel","text":""},{"location":"Arbres/1-Induction_structurelle/#relation-dordre","title":"Relation d'ordre","text":"<p>D\u00e9finition : </p> <p>Soit \\(E\\) un ensemble; une relation \\(\u2264\\) sur \\(E\\) est une realtion d'ordre si pour tous \\(x,y\\) et \\(z\\) \u00e9l\u00e9ments de \\(E\\) :</p> <ul> <li>\\(x \u2264 x\\) (r\u00e9fl\u00e9xivit\u00e9)</li> <li>(\\(x \u2264 y\\) et \\(y \u2264 x\\)) \\(\u21d2\\) \\(x=y\\) (antisym\u00e9trie)</li> <li>(\\(x \u2264 y\\) et \\(y \u2264 z\\)) \\(\u21d2\\) \\(x \u2264 z\\)</li> </ul>"},{"location":"Arbres/1-Induction_structurelle/#ensembles-bien-fondes","title":"Ensembles bien fond\u00e9s","text":"<p>D\u00e9finition : </p> <p>Un ensemble \\(E\\) est dit bien fond\u00e9 s'il est muni d'une relation d'ordre \\(\u227c\\) telle qu'il n'existe pas de suite\\(^a\\) strictement d\u00e9croissante de cet ensemble.</p> <p>Un ensemble est dit bien ordonn\u00e9, si il est bien fond\u00e9 et si, de plus, la relation d'ordre est totale.</p> <p>\\(a\\). Rappel : une suite sur \\(E\\) est simplement une application \\(f : \\mathbb{N} \u2192 E\\)</p>"},{"location":"Arbres/1-Induction_structurelle/#ensembles-bien-ordonnesfondes","title":"Ensembles bien ordonn\u00e9s/fond\u00e9s","text":"<p>Exemples</p> <p>\\(\u2115\\) muni de \\(\u2264\\) usuel est bien ordonn\u00e9</p> <p>\\(\u2115^2\\) muni de l'ordre lexicographique est bien ordonn\u00e9 </p> <p>\\((a, b)  \u227c_L (a', b') \\Leftrightarrow (a &lt; a') \u2228 (a = a' \u2227 b \u2264 b')\\)</p> <p>\\(\u2115^2\\) muni de l'ordre produit est bien fond\u00e9 </p> <p>\\((a, b)  \u227c_P(a', b') \\Leftrightarrow (a \u2264 a') \u2227 (b \u2264 b')\\)</p> <p>Relation non totale.</p> <p>\\(\u2124\\) muni de l'ordre usuel n'est pas bien fond\u00e9 \\((\u22121, \u22122, \u22123 . . .\\) est infini strictement d\u00e9croissante).</p>"},{"location":"Arbres/1-Induction_structurelle/#bon-ordre-et-element-minimal","title":"Bon ordre et \u00e9l\u00e9ment minimal","text":"<p>Proposition</p> <p>Un ensemble ordonn\u00e9 \\(E\\) est bien ordonn\u00e9 si et seulement si toutes les parties non vides de \\(E\\) admettent un \u00e9l\u00e9ment minimal unique. </p> <p>Par \u00e9l\u00e9ment minimal, on entend un \u00e9l\u00e9ment plus petit que tous les autres.</p> <p>Preuve</p> <p>Si \\(E\\) est bien ordonn\u00e9</p> <p>Soit \\(A \u2282 E\\) une partie non vide sans \u00e9l\u00e9ment minimal. Prenons \\(e_0 \u2208 A\\).</p> <ul> <li>Puisque \\(e_0\\) n'est pas minimal, on peut trouver \\(e_1 \u2208 A\\) tel que \\(\u00ac(e_1 \u2265 e_0)\\), c'est \u00e0 dire \\(e_1 &lt; e_0\\) puisque l'ordre est total.</li> <li>De proche en proche on construit un \\(n\\)-uplet (\\(e_0, e_1, . . . , e_n\\)) de valeurs de \\(A\\) donc de \\(E\\) strictement d\u00e9croissantes aussi longue qu'on veut. Contradiction avec \"bien fond\u00e9\". A poss\u00e8de donc un \u00e9l\u00e9ment minimal.</li> <li>L'unicit\u00e9 de l'\u00e9l\u00e9ment minimal vient de l'antisym\u00e9trie.    Si \\(e, e'\\) sont minimaux dans \\(A\\), \\(e \u2264 e'\\) et \\(e' \u2264 e\\), donc \\(e = e'\\) par antisym\u00e9trie.</li> </ul> <p>Si toute partie a un \u00e9l\u00e9ment minimal</p> <p>L'ordre est total car toute partie \u00e0 deux \u00e9l\u00e9ments admet un \u00e9l\u00e9ment minimal. L'un est donc plus petit que l'autre.</p> <ul> <li>Consid\u00e9rons la suite \\((u_n)_n\\) d'\u00e9l\u00e9ments de \\(E\\) .    Posons \\(U={u_n|n\\in\\mathbb{N}}\u2282E\\).</li> <li>Comme \\(U\u2260\u2205\\), \\(U\\) admet un \u00e9l\u00e9ment minimal, disons, \\(u_k\\) . Si la suite est strictement d\u00e9croissante, alors \\(u_k&gt;u_{k+1}\\), ce qui contredit la minimalit\u00e9.</li> <li>Il n'y a pas de suite strictement d\u00e9croissante dans l'ensemble : il est bien fond\u00e9.</li> </ul>"},{"location":"Arbres/1-Induction_structurelle/#elements-sans-predecesseurs","title":"\u00c9l\u00e9ments sans pr\u00e9d\u00e9cesseurs","text":"<p>D\u00e9finition: Elements sans pr\u00e9d\u00e9cesseur</p> <p>Dans toute partie d'un ensemble bien fond\u00e9, il y a un ou des \u00e9l\u00e9ments qui ne sont plus petits qu'aucun autre de cette partie. On les appelle \u00e9l\u00e9ments sans pr\u00e9d\u00e9cesseur.</p> <p>Soit \\(E\\) bien fond\u00e9 et \\(e_0\\), \\(F\\) tels que \\(e_0\u2208 F \u2282 E\\) . Si \\(e_0\\) est sans pr\u00e9d\u00e9cesseur dans \\(F\\) , alors on est content. Sinon, on peut trouver \\(e_1 &lt; e_0\\) dans \\(F\\) .</p> <p>De proche en proche on construit une suite \\(e_0 &gt; e_1 &gt;\u00b7\u00b7\u00b7&gt;e_n\\) dans \\(F\\). Mais cette suite ne se prolonge pas ind\u00e9finiment car l'ordre est bien fond\u00e9.</p> <p>Donc il existe \\(e_k \u2208 F\\) sans pr\u00e9d\u00e9cesseur.</p> <p>R\u00e9ciproquement \\(\\color{red}\\text{Si toute partie d'un ensemble ordonn\u00e9 admet des \u00e9l\u00e9ments}\\) \\(\\color{red}\\text{sans pr\u00e9d\u00e9cesseur, l'ensemble est bien fond\u00e9}\\).</p> <p>Preuve : adapter le transparent pr\u00e9c\u00e9dent.</p>"},{"location":"Arbres/1-Induction_structurelle/#taille-et-ordre","title":"Taille et ordre","text":""},{"location":"Arbres/1-Induction_structurelle/#taille","title":"Taille","text":"<p>D\u00e9finition : Taille d'un terme</p> <p>La taille d'un terme est le nombre de constructeurs qui le composent. Si \\(t\\) est un terme, on note \\(|t|\\) sa taille.</p> <p>Exemple</p> <p>Pour les entiers de Peano, la taille de \\(Z\\) est \\(1\\), celle de \\(S(S(S(Z)))\\) est \\(4\\).</p> <p>La d\u00e9finition de la taille peut subir quelques am\u00e9nagements suivant les contextes.</p> <p>Par exemple, pour les listes on a coutume de dire que <code>[]</code> est de taille \\(0\\) et non \\(1\\), et que la taille de <code>[1;2]</code> (qui est en fait <code>1::2::[]</code>) est \\(2\\) et non \\(3\\). La taille des listes est donc usuellement un translat\u00e9 de \\(-1\\) de la d\u00e9finition de la taille prise dans le transparent pr\u00e9c\u00e9dent.</p>"},{"location":"Arbres/1-Induction_structurelle/#ordre-structurel_1","title":"Ordre structurel","text":"<p>D\u00e9finition : Ordre structurel</p> <p>Soit \\(E\\) un ensemble de termes et \\((t_1, t_2) \u2208 E^2\\). Notons \\(t_1 &lt;_i t_2\\) pour indiquer que \\(t_1\\) est un sous-terme \"imm\u00e9diat\" de \\(t_2\\).</p> <p>L'ordre structurel sur \\(E\\) est la relation d'ordre \\(\u2264\\) engendr\u00e9 par \\(&lt;_i\\), c.a.d la cl\u00f4ture r\u00e9\ufb02exive-transitive de \\(&lt;_i\\) (plus petite relation binaire contenant \\(&lt;_i\\) et \u00e0 la fois r\u00e9\ufb02exive et transitive).   Un sous-terme de \\(t\\) est un terme \\(t'\\) tel que \\(t' \u2264 t\\)</p> <p>Remarque</p> <p>Pour s'assurer que la relation \\(\u2264\\) engendre bien un ordre, il faut s'assurer qu'elle est anti-sym\u00e9trique. Elle est, par d\u00e9finition de la cl\u00f4ture, r\u00e9\ufb02exive et transitive.</p>"},{"location":"Arbres/1-Induction_structurelle/#cloture-reflexive-transitive","title":"Cl\u00f4ture r\u00e9\ufb02exive-transitive","text":"<p>La cl\u00f4ture r\u00e9\ufb02exive-transitive de \\(&lt;_i\\) est par d\u00e9finition la plus petite relation binaire \\(R\\) sur \\(E\\) (i.e. partie de \\(E \u00d7 E\\) ) telle que :</p> <ol> <li>\\(&lt;_i\\) est incluse dans \\(R\\)</li> <li>Si \\(x\u2208E\\), alors \\((x,x)\u2208R\\)</li> <li>Si \\((x, y ) \u2208 R\\) et \\((y , z) \u2208 R\\) alors \\((x, z) \u2208 R\\)</li> </ol> <p>Remarque</p> <p>Id\u00e9e de la preuve pour l'existence de \\(\u2264\\) (qu'on pr\u00e9f\u00e8re noter de fa\u00e7on infixe)</p> <p>Indication : \\(E \u00d7 E\\) contient  \\(&lt;_i\\) et est r\u00e9\ufb02exive-transitive. Donc l'ensemble des relations qui v\u00e9rifient les 3 points est non vide.    Alors l'intersection de toutes les relations \\(R\\) qui v\u00e9rifient les points ci-dessus est bien r\u00e9\ufb02exive-transitive.    Et c'est la plus petite \u00e0 le v\u00e9rifier : on la note \\(\u2264\\).</p>"},{"location":"Arbres/1-Induction_structurelle/#theoreme-de-lordre-bien-fonde","title":"Th\u00e9or\u00e8me de l'ordre bien fond\u00e9","text":"<p>Th\u00e9or\u00e8me   Soit \\(E\\) un ensemble de termes. Notons \\(\u2264\\) l'ordre structurel sur \\(E\\) et \\(&lt;\\) l'ordre strict associ\u00e9. On a les propri\u00e9t\u00e9s suivantes :</p> <ul> <li>Si \\(t_1 &lt; t_2\\), alors \\(|t_1| &lt; |t_2|\\)</li> <li>La relation \\(\u2264\\) est une relation d'ordre bien fond\u00e9e.</li> </ul> <p>Preuve</p> <p>On suppose \\(t_1 &lt; t_2\\),</p> <p>Puisque \\(t_1 \u2264 t_2\\), alors par cons\u00e9quence de la d\u00e9finition de la cl\u00f4ture r\u00e9\ufb02exive-transitive, il existe \\(x_1,x_2,...,x_k\\) tels que \\(x_1=t_1,x_k=t_2\\) et pour tout \\(j\u2208\u27e61,k\u22121\u27e7\\), \\(x_j &lt;_i x_{j+1}\\).</p> <p>Comme \\(t_1 &lt; t_2\\), alors \\(k \u2265 2\\).</p> <p>Pour \\(j\\) convenable, puisque \\(x_j\\) est un sous-terme imm\u00e9diat de \\(x_{j+1}\\) (ce que signifie \\(x_j  &lt;_i x_{j+1}\\)) et donc \\(|x_j| &lt; |x_{j+1}|\\) (puisqu'il faut au moins un constructeur de plus pour construire \\(x_{j+1}\\) que pour \\(x_j\\) ). </p> <p>Par transitivit\u00e9 de \\(&lt;\\) sur \\(\u2115\\), on a \\(|t_1| &lt; |t_2|\\)</p> <p>Preuve : anti-sym\u00e9trie</p> <p>Soient \\(t_1, t_2\\) deux termes tels que \\(t_1 \u2264 t_2, t_2 \u2264 t_1\\) et \\(t_1 \\neq  t_2\\). </p> <p>On a donc \\(t_1 &lt; t_2\\) puisque \\(t_1 \u2264 t_2\\) et \\(t_1\u2260t_2\\). </p> <p>Ainsi \\(|t_1| &lt;_\u2115 |t_2|\\) par le point pr\u00e9c\u00e9dent.    De m\u00eame, on obtient \\(|t_2| &lt;_\u2115 |t_1|\\).    Alors \\(|t_2|, |t_1|\\) sont dans \\(\u2115\\), \\(|t_1| &lt;_\u2115 |t_2|\\) et \\(|t_2| &lt;_\u2115 |t_1|\\) : ABSURDE.</p> <p>Preuve : caract\u00e8re bien fond\u00e9</p> <p>Supposons qu'il existe une suite infinie strictement d\u00e9croissante \\((t_i)_{i\u2208\u2115}\\) pour l'ordre structurel. </p> <p>Alors, par le point 1 du th\u00e9or\u00e8me, la suite des tailles \\((|t_i|)_{i\u2208\u2115}\\) est une suite infinie strictement d\u00e9croissante de \\(\u2115\\).    Or cela est impossible puisque \\(\u2115\\) est bien ordonn\u00e9. ABSURDE.</p>"},{"location":"Arbres/1-Induction_structurelle/#principe-dinduction","title":"Principe d'induction","text":""},{"location":"Arbres/1-Induction_structurelle/#presentation_1","title":"Pr\u00e9sentation","text":"<p>La d\u00e9finition des ensembles inductifs am\u00e8ne naturellement \u00e0 une technique de raisonnement sur les termes proche de la r\u00e9currence.</p> <p>On peut r\u00e9sumer cette technique ainsi : une propri\u00e9t\u00e9 \u00e0 propos des objets inductifs qui vaut pour toutes les constantes et est pr\u00e9serv\u00e9e par chaque construction inductive, est n\u00e9cessairement vraie pour tous les objets pouvant \u00eatre construits.</p>"},{"location":"Arbres/1-Induction_structurelle/#principe-dinduction-structurelle","title":"Principe d'induction structurelle","text":"<p>Th\u00e9or\u00e8me</p> <p>Soit \\(E\\) un ensemble inductif (non vide donc avec au moins une constante) et une propri\u00e9t\u00e9 \\(P\\) \u00e0 propos des objets de \\(E\\). Si, pour chaque constructeur \\(c\\) d'arit\u00e9 \\(n\\), la propri\u00e9t\u00e9 \\(P(c(t_1,...,t_n))\\) est satisfaite d\u00e8s lors que les propri\u00e9t\u00e9s \\(P(t_1)\\) \u00e0 \\(P(t_n)\\) sont satisfaites, alors \\(P(t)\\) est satisfaite pour tout \\(t\\) de \\(E\\) .</p> <p>Remarque</p> <p>Si \\(t\\) est une constante, alors pour tout terme \\(x \u2208 E , x &lt;_i t\\) est faux. Donc \\(\u2200x \u2208 E , (x  &lt;_i t \\Rightarrow P(x))\\) est vraie. Par suite \\(P\\) est satisfaite pour tous les sous-termes imm\u00e9diats de \\(t\\). Il vient donc que \\(P(t)\\) est satisfaite.</p> <p>Rappel :\\(x &lt;_i t\\) signifie que x est sous-terme imm\u00e9diat de t.</p> <p>Preuve</p> <p>Supposons que le sous-ensemble \\(A \u2282 E\\) des termes ne satisfaisant pas \\(P\\) est non vide.</p> <p>\\(A\\) admet donc un \u00e9l\u00e9ment sans pr\u00e9d\u00e9cesseur \\(t_0\\) puisque l'ordre est bien fond\u00e9. </p> <p>Si \\(t_0\\) est une constante, alors \\(P(t_0)\\) est satisfaite. Ce n'est pas possible puisque \\(t_0 \u2208 A\\). </p> <p>Si \\(t_0\\) n'est pas une constante, il a des sous-termes imm\u00e9diats. Ils ne peuvent donc \u00eatre dans \\(A\\) puisque plus petits strictement que \\(t_0\\).</p> <p>M\u00e9zalors, chaque sous-terme satisfait la propri\u00e9t\u00e9 \\(P\\). </p> <p>D'apr\u00e8s l'hypoth\u00e8se sur \\(t\\), cela veut dire que \\(P(t_0)\\) est satisfaite et donc que \\(t_0\u2209A\\) : ABSURDE.</p> <p>Exemple : \u00e9l\u00e9ment neutre</p> <p>Les \u00e9quations d\u00e9finissant l'addition des entiers de Peano assurent que \\(Z + n = n\\) vaut pour tout \\(n \u2208 \u2124\\).</p> <p>Montrons que \\(n + Z = n\\) pour tout \\(n\\) \u00e9galement :    - Cas de base : \\(Z + Z = Z\\) par d\u00e9finition de \\(+\\) (1ere \u00e9quation)    - H\u00e9r\u00e9dit\u00e9 : prenons un entier de Peano \\(n\\) satisfaisant \\(n + Z = n\\). Alors : </p> <p>\\(S(n) + Z = S(n + Z)\\text{ par d\u00e9f. de +} \\\\ = S(n) \\text{ Par HI }\\)</p> <ul> <li>On en d\u00e9duit que pour tout entier de Peano \\(n\\), \\(n + Z = n\\).</li> </ul>"},{"location":"Arbres/1-Induction_structurelle/#recurrence","title":"R\u00e9currence","text":"<p>En r\u00e9crivant le principe d'induction structurelle des entiers de Peano avec les notations habituelles (\\(0\\) au lieu de \\(Z\\), \\(2\\) au lieu de \\(S(S(Z))\\)), et en consid\u00e9rant \\(P\\), un pr\u00e9dicat sur les entiers, nous obtenons que :</p> <ul> <li>Si \\(P(0)\\) est vrai</li> <li>Si pour tout \\(n\\) satisfaisant \\(P(n)\\), la propri\u00e9t\u00e9 \\(P(n + 1)\\) est satisfaite ;</li> <li>Alors pour tout \\(n\\) entier, la propri\u00e9t\u00e9 \\(P(n)\\) est satisfaite.</li> <li>C'est pr\u00e9cis\u00e9ment le principe de r\u00e9currence !!</li> </ul>"},{"location":"Arbres/2-Arbres%20binaires/","title":"Les arbres binaires","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>\"Option informatique MPSI, MP/MP* \", Roger Mansuy, paru chez Vuibert.</li> <li>Wikip\u00e9dia, arbres binaires</li> <li>Un cours \u00e0 Louis Le Grand</li> </ul>"},{"location":"Arbres/2-Arbres%20binaires/#introduction","title":"Introduction","text":""},{"location":"Arbres/2-Arbres%20binaires/#resume","title":"R\u00e9sum\u00e9","text":"<p>\"Les arbres permettent la r\u00e9alisation de structures de donn\u00e9es : structure persistante de dictionnaire, structure persistante de file de priorit\u00e9. Ils permettent aussi de repr\u00e9senter des expressions arithm\u00e9tiques ou des formules logiques \"(programme officiel CPGE 2013).</p> <p>Figure 1 \u2013 Une arborescence de fichiers</p> <p><p></p></p> <p>Commentaire</p> <p>La colonne de gauche est l'affichage arborescent de mon r\u00e9pertoire \\(\\texttt{Files}\\) \u00e0 l'aide de la commande \\(\\text{Unix}\\) \\(\\texttt{tree Files/}\\)</p> <p>Figure 2 \u2013 Contenu d'un fichier html</p> <p><p></p></p> <p>Commentaire</p> <p>La colonne de gauche est le code d'un fichier \\(\\texttt{html}\\). Noter la pr\u00e9sentation arborescente de ce langage de balises.</p> <p>Figure 3 \u2013 Affichage html</p> <p><p></p></p> <p>Commentaire</p> <p>La colonne de gauche est l'interpr\u00e9tation du fichier pr\u00e9c\u00e9dent par \\(\\texttt{Firefox}\\).</p>"},{"location":"Arbres/2-Arbres%20binaires/#arithmetique","title":"Arithm\u00e9tique","text":"<p>Figure 4 \u2013 Une expression arithm\u00e9tique</p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A(('+'))--&gt;B((3))\n    A--&gt;C(('\u00d7'))\n    C--&gt;D((4))\n    C--&gt;E((5))</code></pre> <p>Commentaire</p> <p>La colonne de gauche est la repr\u00e9sentation arborescente de \\(3 + 4 \u00d75\\)</p>"},{"location":"Arbres/2-Arbres%20binaires/#logique","title":"Logique","text":"<p>Figure 5 \u2013 Une expression logique</p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A((\u00ac))--&gt;B((\u2227))\n    B--&gt;F((A))\n    B--&gt;C((\u2228))\n    C--&gt;D((B))\n    C--&gt;E((C))</code></pre> <p>Commentaire</p> <p>La colonne de gauche est la repr\u00e9sentation arborescente de \\(\u00ac(A \u2227(B \u2228C )\\) soit \"\\(\\text{Non}\\) (\\(A\\) \\(\\text{et}\\) (\\(B\\) \\(\\text{ou}\\) \\(C\\))) \"</p>"},{"location":"Arbres/2-Arbres%20binaires/#definition-mathematique","title":"D\u00e9finition math\u00e9matique","text":""},{"location":"Arbres/2-Arbres%20binaires/#arbre-binaire","title":"Arbre binaire","text":"<p>D\u00e9finition \\(1\\) : Arbre binaire</p> <p>Soient \\(E\\) un ensemble de cardinal au moins un ; nil un \u00e9l\u00e9ment d'un  ensemble sans intersection avec \\(E\\) ; \\(C\\) un symbole de constructeur ternaire sans intersection avec les pr\u00e9c\u00e9dents. On d\u00e9finit inductivement les arbres binaires \u00e9tiquet\u00e9s par \\(E\\) en convenant que :</p> <ul> <li>\\(\\color{blue}\\text{R\u00e8gle de base}\\) : nil est un arbre binaire appel\u00e9 arbre vide</li> <li>\\(\\color{blue}\\text{R\u00e8gle d'induction}\\) : Si \\(x \u2208E\\) et si \\(F_g\\) ,\\(F_d\\) sont deux arbres binaires \u00e9tiquet\u00e9s par \\(E\\) , alors \\(A = C (F_g ,x ,F_d )\\) est un arbre binaire \u00e9tiquet\u00e9 par \\(E\\) .</li> <li>\\(\\color{blue}\\text{R\u00e8gle de compl\u00e9tude}\\) : Seuls nil et les \u00e9l\u00e9ments que l'on peut former en un nombre fini d'application des r\u00e8gles d'induction sont des arbres binaires.</li> </ul> <p>Remarque</p> <p>Un arbre est donc un \u00e9l\u00e9ment d'un ensemble inductif (voir chapitre pr\u00e9c\u00e9dent). On fait le choix dans la suite de ne pas utiliser de symbole pour le constructeur ternaire : on \u00e9crira \\((F_g ,x ,F_d )\\) plut\u00f4t que \\(C (F_g ,x ,F_d )\\). La raison est purement esth\u00e9tique : cela alourdirait les transparents.</p>"},{"location":"Arbres/2-Arbres%20binaires/#vocabulaire","title":"Vocabulaire","text":"<p>Avec les conventions de la d\u00e9finition \\(\\color{blue}1\\) :</p> <p>\u00c9tiquette</p> <p>\\(x\\) est appel\u00e9e \u00e9tiquette de la racine de \\(A\\),</p> <p>Fils gauche / droit</p> <p>Si \\(A = (F_g ,x ,F_d )\\), on dit que \\(F_g\\) est le fils gauche de \\(A\\), et \\(F_d\\) son fils droit. Ce sont des sous-termes imm\u00e9diats de \\(A\\).</p> <p>P\u00e8re</p> <p>On dit que \\(A\\) est le p\u00e8re de \\(F_g\\) . On dit parfois \\(\\underline{\\text{improprement}}\\) que \\(x\\) est le p\u00e8re de \\(F_g\\) .</p> <p>Feuille</p> <p>Si \\(Fg = Fd =\\) nil on dit que \\(A\\) est un arbre-feuille ou plus simplement une feuille.</p> <p>\\(\\color{red}\\text{Pour certains auteurs, les feuilles sont les nils !!}\\)</p> <p>Remarque</p> <p>Si \\(A = \\((**nil**,\\)x\\) ,\\(F_d\\) ), nous disons que \\(A\\) a un seul fils</p> <p>Chemin</p> <p>Si \\(A\\) est un arbre, on appelle chemin tout \\(n\\)-uplet (\\(n &gt; 0\\)) \\(A = A_0,...,A_n\\) tel que \\(A_0 = A\\) et quel que soit \\(k &lt; n, A_{k +1}\\) est un fils de \\(A_k\\) . Le nombre \\(n\\) est la longueur du chemin. Parfois, pour d\u00e9signer un chemin, on ne donne que les \u00e9tiquettes.</p> <p>Sous-arbre</p> <p>Dans un chemin, tous les \\(A_i\\) avec \\(i &gt; 0\\) sont appel\u00e9s des descendants de \\(A\\). On dit aussi sous-arbre ou sous-termes.</p> <p>Noeud interne</p> <p>Un n\u0153ud interne poss\u00e8de au moins un fils qui n'est pas l'arbre vide. Ce sont tous les n\u0153uds d'un arbre \u00e0 l'exception de nil et des feuilles.</p>"},{"location":"Arbres/2-Arbres%20binaires/#convention-de-representation","title":"Convention de repr\u00e9sentation","text":"<p>Par convention, on ne repr\u00e9sente ni nil, ni les arcs d'extr\u00eamit\u00e9s nil. Au lieu de</p> <p>Figure 6 \u2013 Avec nil</p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A((1))--&gt;B((2))\n    B--&gt;F((4))\n    F--&gt;G((nil))\n    F--&gt;H((nil))\n    B--&gt;I((5))\n    I--&gt;J((nil))\n    I--&gt;K((nil))\n    A--&gt;C((3))\n    C--&gt;D((nil))\n    C--&gt;E((nil))</code></pre> <p>On repr\u00e9sente</p> <p>Figure 7 \u2013 Sans nil</p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A((1))--&gt;B((2))\n    B--&gt;D((4))\n    B--&gt;E((5))\n    A--&gt;C((3))</code></pre>"},{"location":"Arbres/2-Arbres%20binaires/#proprietes","title":"Propri\u00e9t\u00e9s","text":"<p>Lemme</p> <p>Dans un arbre, aucun chemin ne comporte deux fois un m\u00eame arbre non vide.</p> <p>Preuve</p> <ul> <li>Soit un chemin \\(A_1,...,A_i ,...,A_j ,...,A_k\\) tel que \\(A_i = A_j\\) .</li> <li>Par application du th\u00e9or\u00e8me sur l'ordre structurel (voir chapitre induction), les tailles structurelles (nombres de constructeurs) sont strictement d\u00e9croissantes.</li> </ul> <p>Ainsi \\(|Ai |&gt; |Aj |\\) et \\(A_i = A_j\\) : ABSURDE.</p>"},{"location":"Arbres/2-Arbres%20binaires/#types-darbres-binaires","title":"Types d'arbres binaires","text":"<ul> <li>Certains arbres ne sont pas binaires. Exemple : la figure \\(\\color{blue}1\\).</li> <li>Un arbre binaire entier est un arbre dont tous les n\u0153uds poss\u00e8dent z\u00e9ro ou deux fils (ex : la figure \\(\\color{blue}4\\) mais pas \\(\\color{blue}5\\)).</li> <li>Un arbre binaire parfait est un arbre binaire entier dans lequel toutes les feuilles sont \u00e0 la m\u00eame distance de la racine (c'est-\u00e0-dire \u00e0 la m\u00eame profondeur) (ex : la figure \\(\\color{blue}7\\)).</li> <li>L'arbre binaire parfait est parfois nomm\u00e9 arbre binaire complet. Cependant certains auteurs\\(^\\textbf{1.}\\) d\u00e9finissent un arbre binaire complet comme \u00e9tant un arbre binaire entier dans lequel les feuilles ont pour profondeur soit \\(n\\) soit \\(n \u22121\\) pour un \\(n\\) donn\u00e9 (voir figure \\(\\color{blue}8\\)).</li> </ul> <p>\\(\\textbf{1.}\\) Et nous avec !</p>"},{"location":"Arbres/2-Arbres%20binaires/#arbres-binaires","title":"Arbres binaires","text":"<p>Figure 8 \u2013 Un arbre binaire parfait</p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A(( ))--&gt;B(( ))\n    A--&gt;C(( ))\n    B--&gt;D(( ))\n    B--&gt;E(( ))\n    C--&gt;F(( ))\n    C--&gt;G(( ))    </code></pre> <p>Tous les niveaux sont remplis.</p> <p>Figure 9 \u2013 Un arbre binaire complet gauche</p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A(( ))--&gt;B(( ))\n    A--&gt;C(( ))\n    B--&gt;D(( ))\n    B--&gt;E(( ))\n    C--&gt;F(( ))\n    C--&gt;G(( ))\n    D--&gt;H(( ))\n    D--&gt;I(( ))    \n    E--&gt;J(( ))\n    E~~~K(( ))\n    style K display:none</code></pre> <p>Tous les niveaux sont complets sauf le dernier qui est rempli incompl\u00e8tement en commen\u00e7ant par la gauche.</p>"},{"location":"Arbres/2-Arbres%20binaires/#preuve-par-induction","title":"Preuve par induction","text":""},{"location":"Arbres/2-Arbres%20binaires/#ordre-sur-les-arbres-binaires","title":"Ordre sur les arbres binaires","text":"<p>\\(\\prec\\)</p> <p>La relation binaire \\(\\prec\\) sur les arbres \u00e9tiquet\u00e9s par \\(E\\) d\u00e9finie par </p> <p>\\(A \\preceq B \\Leftrightarrow\\) \\(A\\) est un descendant de \\(B\\)</p> <p>C'est un ordre bien fond\u00e9 et \\(\\prec\\) est un ordre strict.</p> <p>D\u00e9monstration</p> <p>Un descendant est un sous-terme. Donc cet ordre n'est rien d'autre que l'ordre structurel (voir chapitre induction) lequel est bien fond\u00e9.</p>"},{"location":"Arbres/2-Arbres%20binaires/#elements-sans-predecesseur-de-displaystyle-mathcal-a","title":"El\u00e9ments sans pr\u00e9decesseur de \\({\\displaystyle {\\mathcal {A}}}\\)","text":"<p>Proposition</p> <p>L'ensemble des \u00e9l\u00e9ments sans pr\u00e9decesseur des arbres \u00e9tiquet\u00e9s par \\(E\\) est r\u00e9duit \u00e0 nil.</p> <p>Preuve</p> <p>Soit un arbre A.</p> <ul> <li>Si \\(A =\\) nil, il n'a pas de pr\u00e9d\u00e9cesseur car le constructeur est d'arit\u00e9 \\(0\\).</li> <li>Sinon, \\(A\\) est de la forme (\\(F_g ,x ,F_d\\) ) et donc \\(F_g \u227aA\\). Donc \\(A\\) admet un pr\u00e9d\u00e9cesseur.</li> </ul>"},{"location":"Arbres/2-Arbres%20binaires/#principe-dinduction-applique-aux-arbres","title":"Principe d'induction appliqu\u00e9 aux arbres","text":"<p>Soit \\(P\\) un pr\u00e9dicat sur \\({\\displaystyle {\\mathcal {A}}}\\)</p> <ul> <li>On \u00e9tablit la propri\u00e9t\u00e9 pour les \u00e9l\u00e9ments minimaux (donc \\(\\{\\)nil\\(\\}\\)).</li> <li>On prend \\(A\\) avec pr\u00e9d\u00e9cesseur. On suppose que pour tout pr\u00e9d\u00e9cesseur \\(B\\) de \\(A\\), \\(P (B )\\) est vrai, et on tente d'\u00e9tablir que \\(P(A)\\) est vrai.</li> </ul>"},{"location":"Arbres/2-Arbres%20binaires/#fonction-inductives","title":"Fonction inductives","text":"<p>Soit \\({\\displaystyle {\\mathcal {A}}}\\), l'ensemble des arbres \u00e9tiquet\u00e9s par \\(E\\). De nombreuses fonction \\(f : {\\displaystyle {\\mathcal {A}}}\u2192F\\) se d\u00e9finissent par la donn\u00e9e d'un \u00e9l\u00e9ment \\(a \\in F\\) et d'une application \\(\u03c6 : F \u00d7E \u00d7F \u2192F\\) telles que :</p> <ul> <li>\\(f (\\textbf{nil}) = a\\)</li> <li>\\(\u2200(F_g ,F_d ) \u2208{\\displaystyle {\\mathcal {A}}}^2, \u2200x \u2208E ,f (F_g ,x ,F_d ) = \u03c6(f (F_g ),x ,f (F_d ))\\)</li> </ul> <p>Le principe d'induction \u00e9tablit que \\(f\\) est d\u00e9finie sur \\({\\displaystyle {\\mathcal {A}}}\\) et qu'elle prend ses valeurs dans \\(F\\) .</p>"},{"location":"Arbres/2-Arbres%20binaires/#taille","title":"Taille","text":"<p>Taille</p> <p>La taille d'un arbre binaire est le nombre de ses n\u0153uds qui ne sont pas nil</p> <p>La taille d'un arbre \\(A\\), not\u00e9e \\(|A|\\), se d\u00e9finie inductivement par :</p> <ul> <li>\\(|\\textbf{nil}|= 0\\)</li> <li>\\(\u2200(F_g ,F_d ) \u2208{\\displaystyle {\\mathcal {A}}}^2,\u2200x \u2208E ,|(F_g ,x ,F_d )|= 1 + |F_g |+ |F_d |\\)</li> </ul> <p>Remarque</p> <p>Cette d\u00e9finition est diff\u00e9rente de la taille structurelle vue au chapitre induction en ce sens qu'elle ne compte pas les constructeurs d'arit\u00e9 \\(0\\). La d\u00e9finition varie selon les auteurs : il faut donc bien lire l'\u00e9nonc\u00e9.</p>"},{"location":"Arbres/2-Arbres%20binaires/#profondeur","title":"Profondeur","text":"<p>Hauteur</p> <p>La hauteur d'un arbre binaire est la longueur de la plus longue branche (sans arriver jusqu'\u00e0 nil).</p> <p>La hauteur d'un arbre binaire \\(A\\), not\u00e9e \\(h(A)\\), est la fonction d\u00e9finie inductivement par :</p> <ul> <li>\\(h(nil) = \u22121\\)</li> <li>\\(\u2200(F_g ,F_d ) \u2208\\displaystyle {\\mathcal {A}}^2,\u2200x \u2208E ,h((F_g ,x ,F_d )) = 1 + max(h(F_g ),h(F_d ))\\)</li> </ul> <p>Profondeur</p> <p>La profondeur d'un n\u0153ud dans un arbre binaire est la longueur du chemin qui le relie \u00e0 la racine.</p> <p>Remarque</p> <p>L\u00e0 encore, la d\u00e9finition varie selon les auteurs.</p>"},{"location":"Arbres/2-Arbres%20binaires/#un-type-textocaml-pour-les-arbres-binaires","title":"Un type \\(\\text{OCAML}\\) pour les arbres binaires","text":"<pre><code>(* type possible pour les arbres binaires *)\ntype 'a arbre =\n    Nil | Node of ('a arbre * 'a * 'a arbre);;\n\nlet a = let b = Node (Nil , 1, Nil) and c =\nNode (Nil , 2, Nil) and d = Node (Nil , 4, Nil) in\nlet g = Node (b,4,c) and f= Node (Nil , 5, Node(d,3,Nil))\nin Node(g,6,f);;(* un arbre \u00e0 repr\u00e9senter *)\n</code></pre>"},{"location":"Arbres/2-Arbres%20binaires/#hauteur-et-taille","title":"Hauteur et taille","text":"<pre><code>let rec taille a =\n    match a with\n    | Nil -&gt; 0\n    | Node(g,_,d) -&gt;1+taille g+taille d;;\n\nlet rec hauteur a =\n    match a with\n    | Nil -&gt; -1\n    | Node(g,_,d) -&gt;1+ (max (hauteur g) (hauteur d));;\n</code></pre> <ul> <li>On observe d'abord que pour ces fonctions, la complexit\u00e9 au pire est croissante avec la taille de la variable.</li> <li>En effet, soit \\(A\\) un arbre avec \\(n\\) n\u0153uds qui atteint le maximum de complexit\u00e9. Pour (\\(A\\),\\(x\\) ,nil), qui a \\(n + 1\\) n\u0153uds, le calcul n\u00e9cessite au moins une op\u00e9ration de plus (ne serait-ce que le filtrage).</li> </ul>"},{"location":"Arbres/2-Arbres%20binaires/#complexite-du-calcul-de-la-hauteur","title":"Complexit\u00e9 du calcul de la hauteur","text":""},{"location":"Arbres/2-Arbres%20binaires/#methode-informelle","title":"M\u00e9thode informelle","text":"<p>Pour un arbre de taille \\(n\\) :</p> <ul> <li>De fa\u00e7on empirique on peut dire que chaque n\u0153ud est parcouru trois fois : quand on y acc\u00e8de (au moment du filtrage), quand le parcours revient du fils gauche (avec l'info sur sa hauteur), quand il revient du fils droit (avec l'info sur sa hauteur).</li> <li>Pour chacun de ces trois passages dans le n\u0153ud, le nombre d'op\u00e9rations \u00e9l\u00e9mentaires hors appels r\u00e9cursifs est born\u00e9 par une constante (disons \\(c\\)).</li> <li>Au total, on peut donc majorer le nombre d'op\u00e9rations par \\(3nc\\) et le minorer par \\(n\\).</li> <li>Donc complexit\u00e9 en \\(\u0398(n)\\)</li> </ul>"},{"location":"Arbres/2-Arbres%20binaires/#relation-entre-taille-et-hauteur","title":"Relation entre taille et hauteur","text":"<p>Proposition</p> <p>Soit \\(A\\) un arbre. Alors \\(h(A) + 1 \u2264|A|\u22642^{h(A)+1} \u22121\\). Et les bornes sont atteintes.</p> <p>Preuve par induction</p> <ul> <li>Si \\(A =\\) nil, alors \\(|A|= 0\\); \\(h(A) = \u22121. \u22121 + 1 \u22640 \u22642^{\u22121+1} \u22121.\\) OK</li> <li>Si \\(A = (G ,x ,D )\\), et si la propri\u00e9t\u00e9 est vraie pour \\(G\\) ,\\(D\\) , alors</li> </ul> <p>\\(|A|= 1 + |G |+ |D |\u2265 1 + h(G ) + 1 + h(D ) + 1 \u22651 + (1 + max(h(G ),h(D ))) = 1 + h(A)\\)</p> <p>Et \\(|A|= 1 + |G |+ |D |\u22641 + 2^{h(G )+1} \u22121 + 2^{h(D)+1} \u22121\\)</p> <p>Donc \\(|A| \u2264\u22121 + 2 \u00b72^{max(h(G ),h(D))+1} = 2 \u00b72^{h(A)} \u22121 = 2^{h(A)+1} \u22121\\)</p> <p>Les deux bornes sont atteintes : \u00e0 gauche par les listes cha\u00een\u00e9es et \u00e0 droite par les arbres parfaits.</p>"},{"location":"Arbres/2-Arbres%20binaires/#profondeur-moyenne-et-applications","title":"Profondeur moyenne et applications","text":""},{"location":"Arbres/2-Arbres%20binaires/#profondeur-moyenne","title":"Profondeur moyenne","text":"<p>La profondeur moyenne d'un arbre est la moyenne des longueurs de ses branches ou encore la moyenne des profondeurs des feuilles.</p> <p>Proposition</p> <p>Dans un arbre binaire \u00e0 \\(n &gt; 0\\) feuilles, la profondeur moyenne est \u00e9gale ou sup\u00e9rieure \u00e0 \\(log_2(n)\\)</p>"},{"location":"Arbres/2-Arbres%20binaires/#cas-de-base","title":"Cas de base","text":"<p>Par r\u00e9currence sur le nombre de feuille \\(n\\) de \\(A\\), on montre que la profondeur moyenne \\(m_A\\) est plus grande que \\(log_2(n)\\).</p> <ul> <li>Vrai pour \\(n = 1\\) (profondeur au moins z\u00e9ro, \\(log_2 (1) = 0\\)).</li> </ul> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph LR;\nA((1))\nB((1))--&gt;C((...))\nC--&gt;D(feuille) </code></pre> <ul> <li>Si \\(n = 2\\), la plus petite profondeur moyenne intervient quand les deux feuilles sont \u00e0 la profondeur \\(1\\). Alors la profondeur moyenne vaut \\(1\\) et \\(log_2 (2) = 1\\). Si l'une des feuilles n'est pas \u00e0 la profondeur \\(1\\), la profondeur moyenne est strictement sup\u00e9rieure \u00e0 \\(log_2 (2)\\).</li> </ul> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TD;\nA((1))--&gt;B((2))\nA--&gt;C((3))\n\nD((1))--&gt;E((2))\nD--&gt;F((3))\nF~~~G(( ))\nF--&gt;H((4))\nstyle G display:none</code></pre>"},{"location":"Arbres/2-Arbres%20binaires/#cas-dun-fils-unique","title":"Cas d'un fils unique","text":"<p>Par r\u00e9currence sur le nombre de feuille \\(n\\) de \\(A\\), on montre que la profondeur moyenne \\(m_A\\) est plus grande que \\(log_2(n)\\). Supposons la propri\u00e9t\u00e9 vraie pour tout arbre binaire d'au plus \\(n\\) feuilles \\((2 \u2264n)\\). On se donne un arbre \\(A\\) de \\(n + 1\\) feuilles \\((n \u22652)\\). Si \\(A\\) n'a qu'un fils, on se ram\u00e8ne au probl\u00e8me \u00e0 deux fils :</p> <ul> <li>L'unique fils \\(F\\) de \\(A\\) a autant de feuilles que \\(A\\) mais la profondeur de ses feuilles est plus petite (car \\(m_A = m_F + 1\\)).</li> <li>En descendant dans l'arbre on finit par trouver un premier descendant \\(D\\) qui a deux fils (car \\(A\\) a au moins deux feuilles) et \\(n + 1\\) feuilles.</li> <li>On montre donc la propri\u00e9t\u00e9 pour \\(D\\) , elle sera vraie pour \\(A\\) car la profondeur moyenne y est plus grande.</li> </ul>"},{"location":"Arbres/2-Arbres%20binaires/#deux-fils-et-n1-feuilles","title":"Deux fils et \\(n+1\\) feuilles","text":"<p>On suppose que \\(A\\) a deux fils \\(F_g ,F_d\\) . Soit \\(k\\) tel que \\(F_g\\) poss\u00e8de \\(k\\) feuilles \\((n + 1 &gt; k \u22651)\\), \\(F_d\\) en a \\(n + 1 \u2212k\\)</p> <p>Relation moyenne \\(/\\) somme des profondeurs :</p> <p>On a \u00e0 gauche : \\(\\frac{\\sum_{i =1}^k{ p^g_i}}{k} = m_g\\)</p> <p>Notation</p> <ul> <li>\\(p^g_i\\) = profondeur de la feuille i du fils gauche, </li> <li>\\(m_g\\) moyenne des profondeurs \u00e0 gauche.</li> </ul> <p>Gauche : \\(\\sum_{i =1}^k{ p^g_i} = k \\times \\underbrace{m_g}_{\\text{prof. moy.}} \\underbrace{\u2265}_{\\text{par HR}} k \\times log_2(k)\\)</p> <p>Droite :</p> <p>\\(\\sum^{n+1\u2212k}_{i =1} {p^d_i} = (n + 1 \u2212k )\\times m_d \u2265 (n + 1 \u2212k )\\times log_2(n + 1 \u2212k )\\).</p> <p>La somme des profondeurs des feuilles dans \\(A\\) v\u00e9rifie</p> <p>\\(\\begin{matrix}  S_{n+1}&amp; =  &amp; \\sum_{r=1}^{n+1}p_r\\\\  &amp; &amp; \\\\  &amp; = &amp; \\sum_{i=1}^{k}{(1 + p_i^g)} + \\sum_{i=1}^{n+1-k}{(1+p_i^d)}\\\\  &amp; &amp; \\\\  &amp; = &amp; n+1+\\sum_{i=1}^k{p_i^g}+\\sum_{i=1}^{n+1-k}{p_i^d}\\\\  &amp; &amp; \\\\  &amp; \u2265 &amp; n+1+k\\times log_2(k) + (n+1-k) \\times log_2(n+1-k) \\end{matrix}\\)</p> <p>La somme \\(S_{n+1}\\) des profondeurs est :</p> <p>\\(S_{n+1} \u2265n + 1 + k \\times log_2 (k) + (n + 1 \u2212k )\\times log_2(n + 1 \u2212k)\\)</p> <p>La fonction \\(f : k \\mapsto k \\times log_2(k) + (n + 1 \u2212k ) log_2(n + 1 \u2212k )\\) se d\u00e9rive en \\(f' : k \\mapsto log_2(k) \u2212 log_2(n + 1 \u2212k )\\).</p> <p>Cette d\u00e9riv\u00e9e s'annule en \\(n+1\\) \\(f\u2032(1) &lt; 0, f\u2032(n) &gt; 0\\) donc \\(f(\\frac{n+1}{2})\\) est minimale.</p> <p>Par suite \\(f (k) = k\\times log_2 (k) + (n + 1 \u2212k )\\times log_2(n + 1 \u2212k )\\) </p> <p>Donc \\(f(k) \u2265 f(\\frac{n + 1}{2}) = (n + 1)\\times log_2(\\frac{n + 1}{2})\\)</p> <p>Alors la moyenne \\(m_A = \\frac{Sn+1}{n + 1}\\) des profondeurs v\u00e9rifie</p> <p>\\(\\begin{matrix} (n + 1) \\times m_A &amp;=&amp; \\sum_{r=1}^{n+1} p_r \\\\ &amp;&amp; \\\\ &amp;\u2265&amp; n + 1 + (n + 1)\\times log_2(\\frac{n + 1}{2})\\\\ &amp;&amp; \\\\ &amp;=&amp; n + 1 + (n + 1)\\times log_2(n + 1) \u2212(n + 1) \\\\ &amp;&amp; \\\\ &amp;=&amp; (n + 1)\\times log_2(n + 1) \\end{matrix}\\)</p> <p>Donc \\(m_A \u2265log_2(n + 1)\\) : OK !</p>"},{"location":"Arbres/2-Arbres%20binaires/#application-aux-tris","title":"Application aux tris","text":""},{"location":"Arbres/2-Arbres%20binaires/#permutation-associee-a-une-liste","title":"Permutation associ\u00e9e \u00e0 une liste","text":"<p>Consid\u00e9rons un tri \\(T\\) donn\u00e9 (par ex : tri fusion ou tri insertion).</p> <ul> <li>Consid\u00e9rons une liste (ou un tableau) \u00e0 \\(n\\) nombres \\(\\color{red}\\text{tous distincts}\\). La complexit\u00e9 du tri sur cette structure ne d\u00e9pend pas des valeurs de ces nombres mais de l'ordre initial dans lequel ils sont plac\u00e9s.</li> <li>Classer \\([12; 50; 3; 28; 46]\\) a la m\u00eame complexit\u00e9 que le classement de \\([2; 5; 1; 3; 4]\\) (permutation d'\u00e9l\u00e9ments dans J1,nK).</li> <li>A une liste \\(L\\) de \\(n\\) nombres distincts \u00e0 trier, on associe ainsi une unique permutation \\(\u03c3 \u2208S_n\\) . Le co\u00fbt \\(C (L)\\) du tri de \\(L\\) selon l'algorithme \\(T\\) d\u00e9pend seulement de \\(\u03c3\\) (ordre des \u00e9l\u00e9ments) et on le note donc \\(C (\u03c3)\\).</li> </ul>"},{"location":"Arbres/2-Arbres%20binaires/#complexite-en-moyenne","title":"Complexit\u00e9 en moyenne","text":"<p>Complexit\u00e9 en moyenne</p> <p>La complexit\u00e9 en moyenne \\(c (n)\\) du tri selon l'algo \\(T\\) des liste de taille \\(n\\) est le co\u00fbt moyen des permutations associ\u00e9es : </p> <p>\\(c (n) = \\frac{1}{n!} \\sum_{\u03c3\u2208Sn}{ C (\u03c3)}\\).</p>"},{"location":"Arbres/2-Arbres%20binaires/#arbre-de-decision","title":"Arbre de d\u00e9cision","text":"<p>Arbre de d\u00e9cision</p> <p>Un arbre de d\u00e9cision est un arbre binaire tel que </p> <ul> <li>chaque n\u0153ud interne est \u00e9tiquet\u00e9 avec une comparaison, </li> <li>chaque feuille est \u00e9tiquet\u00e9e avec une permutation</li> </ul> <p>A un algorithme de tri appliqu\u00e9 \u00e0 des listes de taille \\(n\\) on associe un arbre binaire de d\u00e9cision unique (admis). Une permutation donn\u00e9e est l'extr\u00e9mit\u00e9 d'une branche compl\u00e8te de l'arbre.</p> <p>On construit ainsi cet arbre de d\u00e9cision : La racine est la premi\u00e8re comparaison observ\u00e9e entre \u00e9l\u00e9ments. Son fils gauche est la premi\u00e8re comparaison effectu\u00e9e lorsque le test correspondant \u00e0 la racine est positif, le droit est la premi\u00e8re comparaison effectu\u00e9e si le premier test est n\u00e9gatif etc.</p> <p>L'arbre de d\u00e9cision associ\u00e9 \u00e0 un tri par comparaison sur des structures de longueur \\(n\\) est unique (c'est une affirmation, pas une preuve : il faudrait le montrer) et il a \\(n!\\) feuilles (autant que de permutations).</p> <p>Arbre de d\u00e9cision du tri par insertion pour les listes \\([A; B ; C ]\\)</p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A((A &lt; B))-- oui [A;B;C] --&gt;B((B &lt; C))\n    A-- non [B;A;C] --&gt;C((A &lt; C))\n    C-- oui --&gt;D((BAC))\n    C-- non [B;C;A] --&gt;E((B &lt; C))\n    E-- oui --&gt;F((BCA))\n    E-- non --&gt;G((CBA))\n    B-- oui --&gt;H((ABC))\n    B-- non [A;C;B] --&gt;I((A &lt; C))\n    I-- oui --&gt;J((ACB))\n    I-- non --&gt;K((CAB))</code></pre>"},{"location":"Arbres/2-Arbres%20binaires/#complexite-en-moyenne-a-partir-de-larbre-de-decision","title":"Complexit\u00e9 en moyenne \u00e0 partir de l'arbre de d\u00e9cision","text":"<p>Soit un tri \\(T\\) et son arbre de d\u00e9cision \\(A\\).</p> <ul> <li>La complexit\u00e9 du tri par \\(T\\) d'une liste \\(L\\) de longueur \\(n\\) est proportionnelle \u00e0 la longueur de la branche de A emprunt\u00e9e en traitant L. \\(\\color{red}\\text{Si }L\\text{ est associ\u00e9e \u00e0 la permutation \u03c3, la feuille sur laquelle arrive}\\) \\(\\color{red}\\text{ l'algorithme en traitant }L\\text{ est la permutation r\u00e9ciproque \u03c3\u22121 (car} \u03c3 \u25e6\u03c3^{\u22121} = id_{S_n})\\)</li> </ul> <p>Si \\(L\\) est associe \u00e0 la permutation \\([2,3,1]\\) on arrive sur la feuille CAB qui correspond \u00e0 la permutation \\([3,1,2]\\) r\u00e9ciproque de la pr\u00e9c\u00e9dente.</p> <ul> <li>La complexit\u00e9 en moyenne de \\(T\\) est donc proportionnelle \u00e0 la profondeur moyenne des \\(n!\\) feuilles.</li> <li>Or, celle-ci est minor\u00e9e par \\(log_2(n!)\\) Et la formule de Stirling nous donne \\(log_2(n!) = \u0398(n \\times log(n))\\).</li> <li>Ainsi, la meilleure complexit\u00e9 possible en moyenne pour un tri par comparaison est \\(\u0398(n \\times log (n))\\).</li> <li>La complexit\u00e9 au pire est sup\u00e9rieure \u00e0 la complexit\u00e9 en moyenne. Un algorithme qui, comme le tri fusion, r\u00e9alise une complexit\u00e9 au pire en \\(\u0398(n\\times log (n))\\) est donc un algorithme de tri par comparaison optimal.</li> </ul>"},{"location":"Arbres/2-Arbres%20binaires/#parcours-darbres-binaires","title":"Parcours d'arbres binaires","text":""},{"location":"Arbres/2-Arbres%20binaires/#objectif","title":"Objectif","text":"<p>Un parcours d'arbre est une fa\u00e7on d'ordonner les n\u0153uds d'un arbre afin de tous les parcourir.</p> <p>On peut le voir comme une fonction qui \u00e0 un arbre associe une liste de ses n\u0153uds m\u00eame si la liste n'est souvent pas explicitement construite par le parcours.</p>"},{"location":"Arbres/2-Arbres%20binaires/#parcours-en-profondeur","title":"Parcours en profondeur","text":""},{"location":"Arbres/2-Arbres%20binaires/#depth-first-search-dfs","title":"Depth-first search (DFS)","text":"<p>Les parcours en profondeur se d\u00e9finissent de mani\u00e8re r\u00e9cursive sur les arbres. Le parcours d'un arbre consiste \u00e0 traiter la racine de l'arbre et \u00e0 parcourir r\u00e9cursivement les sous-arbres gauche et droit de la racine. Les parcours pr\u00e9fixe, infixe et suffixe se distinguent par l'ordre dans lequel sont faits ces trois traitements.</p> <p>Figure \u2013 Ordre dans lequel les n\u0153uds sont visit\u00e9s (en exposant) dans un parcours en profondeur pr\u00e9fixe. Les lettres correspondent \u00e0 la num\u00e9rotation par parcours en largeur.</p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear'} } }%%\ngraph TB;\nA((a\u00b9)) --&gt; B((b\u00b2))\nA --&gt; C((c\u2075))\nB --&gt; D((d\u00b3))\nB --&gt; E((e\u2074))\nC --&gt; F((f\u2076))\nC --&gt; G(( ))\nstyle G display:none</code></pre>"},{"location":"Arbres/2-Arbres%20binaires/#type-ocaml-rappel","title":"Type OCAML (rappel)","text":"<p>Il y a beaucoup de fa\u00e7on de d\u00e9finir les arbres binaires en Ocaml. En voici une :</p> <pre><code>type 'a tree = Nil | Node of 'a tree * 'a * 'a tree;;\n\nlet t = let g = Node(Node(Nil ,3,Nil),2,Node(Nil ,4,Nil)) and\n    d = Node(Node(Nil ,6,Nil),5,Node(Nil ,7,Nil)) in\n    Node(g,1,d);;\n</code></pre>"},{"location":"Arbres/2-Arbres%20binaires/#parcours-prefixe","title":"Parcours pr\u00e9fixe","text":"<p>Principe</p> <p>D\u00e8s qu'on passe par un n\u0153ud, on effectue un traitement de son \u00e9tiquette. On n'attend pas que les descendants du n\u0153ud soient trait\u00e9s. On fait ce qu'on a \u00e0 faire avec ce n\u0153ud d\u00e8s qu'on passe dessus.</p> <pre><code>let rec parcours_prefixe = function\n    | Nil -&gt; ()\n    | Node (g, r, d) -&gt;\n        Printf.printf \"%d \" r;\n        parcours_prefixe g;\n        parcours_prefixe d ;;\n\nparcours_prefixe a;;\n</code></pre> <p>On obtient 1 2 3 4 3 6 7.</p>"},{"location":"Arbres/2-Arbres%20binaires/#parcours-suffixe","title":"Parcours suffixe","text":"<p>Principe</p> <p>Quand on passe sur un n\u0153ud, on attend que tous ses descendants soient trait\u00e9s avant d'agir sur ce n\u0153ud.</p> <pre><code>let rec parcours_suffixe = function\n    | Nil -&gt; ()\n    | Node (g, r, d) -&gt;\n        parcours_suffixe g;\n        parcours_suffixe d ;\n        Printf.printf \"%d \" r;;\n\nparcours_suffixe a;;\n</code></pre> <p>On obtient 3 4 2 6 7 5 1</p>"},{"location":"Arbres/2-Arbres%20binaires/#parcours-infixe","title":"Parcours infixe","text":"<p>Principe</p> <p>Quand on passe sur un n\u0153ud, on traite d'abord le fils gauche. Puis on traite le n\u0153ud lui m\u00eame. Et enfin on traite le second fils.</p> <pre><code>let rec parcours_infixe = function\n    | Nil -&gt; ()\n    | Node (g, r, d) -&gt;\n        parcours_infixe g;\n        Printf.printf \"%d \" r;;\n        parcours_infixe d ;;\n\n\nparcours_infixe a;;\n</code></pre> <p>On obtient 3 2 4 1 6 5 7</p>"},{"location":"Arbres/2-Arbres%20binaires/#complements","title":"Compl\u00e9ments","text":"<p>La complexit\u00e9 du parcours en profondeur pour un arbre a d\u00e9j\u00e0 \u00e9t\u00e9 \u00e9tudi\u00e9e : c'est celle du calcul de la hauteur (laquelle est un parcours suffixe dans notre code puisque le traitement a lieu lorsqu'on conna\u00eet la hauteur des \\(2\\) fils) : \\(\u0398(n)\\)</p> <p>Le parcours pr\u00e9fixe (resp. suffixe) est injectif (si l'on consid\u00e8re que Node(Nil,x,f)=Node(f,x,Nil)). Voir TD.</p>"},{"location":"Arbres/2-Arbres%20binaires/#parcours-en-largeur","title":"Parcours en largeur","text":""},{"location":"Arbres/2-Arbres%20binaires/#bfs","title":"BFS","text":"<p>L'algorithme de parcours en largeur (ou BFS, pour Breadth First Search en anglais) permet le parcours d'un arbre de la mani\u00e8re suivante : on commence par explorer un n\u0153ud source, puis tous ses fils, puis les fils des fils, etc.</p> <p>En bref, on visite compl\u00e8tement une g\u00e9n\u00e9ration avant de visiter la g\u00e9n\u00e9ration suivante.</p> <p>Un BFS</p> <p>La d\u00e9nomination des n\u0153uds suivants respecte le parcours en largeur :</p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear'} } }%%\ngraph TB;\nA((a)) --&gt; B((b))\nA --&gt; C((c))\nB --&gt; D((d))\nB --&gt; E((e))\nC --&gt; F((f))\nC --&gt; G((g))\nD --&gt; H((h))</code></pre> <p>BFS vs DFS</p> <p>La d\u00e9nomination des n\u0153uds suivants respecte le parcours en profondeur (prefixe) :</p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear'} } }%%\ngraph TB;\nA((a)) --&gt; B((b))\nA --&gt; C((f))\nB --&gt; D((c))\nB --&gt; E((e))\nC --&gt; F((g))\nC --&gt; G((h))\nD --&gt; H((d))</code></pre>"},{"location":"Arbres/2-Arbres%20binaires/#deux-fonctions-auxiliaires","title":"Deux fonctions auxiliaires","text":"<p>Liste des \u00e9tiquettes des racines d'une for\u00eat (i.e. un ens. d'arbres) :</p> <pre><code>let rec label_list f = match f with\n    | [] -&gt; []\n    | Nil::q-&gt;label_list q\n    | Node(_,x,_)::q-&gt;x::( label_list q);;\n</code></pre> <p>Liste des fils des racines d'une for\u00eat (si ce sont des n\u0153uds internes).</p> <pre><code>let rec sons f = match f with\n    | [] -&gt; []\n    | Nil::q -&gt; sons q\n    | Node(Nil ,_,Nil)::q-&gt;sons q\n    | Node(Nil ,_,d)::q-&gt; d::( sons q)\n    | Node(g,_,Nil)::q-&gt; g::( sons q)\n    | Node(g,_,d)::q-&gt; g::(d::( sons q));;\n</code></pre>"},{"location":"Arbres/2-Arbres%20binaires/#principe-du-parcours-en-largeur","title":"Principe du parcours en largeur","text":"<p>La fonction sons retourne une for\u00eat, label_list retourne la liste des \u00e9tiquettes de la for\u00eat.</p> <p>La fonction bfs utilise la fonction aux qui prend une for\u00eat et concat\u00e8ne la liste de ses \u00e9tiquettes avec la liste des \u00e9tiquettes des fils des racines.</p> bfs<pre><code>let bfs t =\n    let rec aux les_t = match les_t with\n        | [] -&gt; []\n        | _ -&gt; (label_list les_t) @ (aux (sons les_t))\n    in aux [t];;\n</code></pre> <p>Complexit\u00e9 : chaque \u00e9tiquette est ajout\u00e9e une fois et une seule \u00e0 la liste r\u00e9sultat, \\(\\text{on a envie de dire que la complexit\u00e9 est en }\u0398(n)\\).</p> <p>Dans ce qui suit on note \\(u_p\\) la complexit\u00e9 pour calculer la liste des \u00e9tiquettes de l'arbre \u00e0 la profondeur \\(p\\). Il s'agit de calculer \\(u_0\\).</p>"},{"location":"Arbres/2-Arbres%20binaires/#complexite-du-parcours-en-largeur","title":"Complexit\u00e9 du parcours en largeur","text":"<p>Pour un arbre \u00e0 \\(n\\) n\u0153uds de hauteur \\(h\\) :</p> <ul> <li>La fonction qui r\u00e9cup\u00e9re les \u00e9tiquettes des racines d'une for\u00eat \\(F\\) et celle qui r\u00e9cup\u00e8re les fils sont de complexit\u00e9 \\(\u0398(|F |)\\).</li> <li>A chaque \u00e9tape, on r\u00e9cup\u00e8re la liste des \u00e9tiquettes des sous-arbres d'une m\u00eame profondeur et on l'ajoute au r\u00e9sultat.</li> <li>Lorsqu'on traite la liste des n\u0153uds de profondeurs \\(p\\) (disons qu'il y en a \\(n_p\\) ) :<ul> <li>on r\u00e9cup\u00e8re la liste de leurs \u00e9tiquettes en \\(O (n_p )\\) ;</li> <li>on les concat\u00e8nes \u00e0 gauche du r\u00e9sultat de l'appel r\u00e9cursif en \\(O (n_p )\\) ;</li> <li>la liste des fils des n\u0153uds de profondeur \\(p\\) s'obtient aussi en \\(O (n_p )\\).</li> <li>A ceci s'ajoute le co\u00fbt de l'appel interne.</li> </ul> </li> <li>La complexit\u00e9 \\(u_p\\) v\u00e9rifie donc une relation de la forme : \\(u_p = n_p + u_{p+1}\\). \\(\\color{red}\\text{Donc }u_p \u2212u_{p+1} = n_p\\).</li> <li>Au d\u00e9part \\(u_0 \u2212u_1 = 1\\) (nombre de n\u0153uds \u00e0 la profondeur \\(0\\) : racine) et \\(u_h \u2212u_{h+1} = n_h\\) avec \\(h\\) la hauteur et \\(u_{h+1}\\) qui correspond au traitement de la liste vide (pas de n\u0153ud \u00e0 la profondeur \\(h + 1\\)).</li> <li>On somme sur les profondeurs allant de \\(0\\) (la racine) \u00e0 \\(h\\) (la hauteur de l'arbre). C'est une s\u00e9rie telescopique. On obtient : </li> </ul> <p>\\(u_0 - \\underbrace{u_{h+1}}_{\\text{exploration liste vide}} = \\sum_{p=0}^h{n_p} = \u0398(n)\\)</p> <p>La complexit\u00e9 est proportionnelle au nombre de n\u0153uds : on aurait pu s'en douter !</p>"},{"location":"Arbres/3-Rec_Ter_Abr/","title":"Arbres et r\u00e9cursions terminales","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Pour calculer la taille d'un arbre, on peut agir classiquement :</p> <pre><code>type 'a arbre = Nil | Node of ('a arbre * 'a * 'a arbre) ;;\n\nlet rec taille a =\n    match a with\n    | Nil -&gt;0\n    | Node (g,_,d) - &gt;1+ taille g + taille d;;\n</code></pre> <p>En exercice, nous avons pr\u00e9sent\u00e9 faussement la version suivante comme une r\u00e9cursion terminale :</p> <pre><code>let taille2 a =\n    let rec size acc a =\n        match a with\n        | Nil -&gt; acc\n        | Node (g,_,d) -&gt;\n            size ( size ( acc +1) g) d\n    in aux 0 a;;\n</code></pre> <p>Malheureusement, ce n'est pas vrai car la pile d'appel n'est pas vid\u00e9e : on doit garder en m\u00e9moire la valeur de <code>d</code>\\(^\\textsf{1.}\\) dans la stack frame courante. Les stack frames qui s'empilent du fait de l'appel <code>aux (acc+1) g</code> ne peuvent effacer cette valeur car elle est n\u00e9cessaire au calcul final.</p> <p>En clair, la pile d'appel n'est pas vid\u00e9e et les stack frames s'accumulent. Oublions donc cette version malheureuse qui ne remplit pas son objectif.</p> <p>La solution pour obtenir une v\u00e9ritable r\u00e9cursion terminale consiste \u00e0 utiliser une m\u00e9thode de programmation appel\u00e9e Continuation-passing style (CPS). Le flot de contr\u00f4le\\(^\\textsf{2.}\\) est pass\u00e9 explicitement en param\u00e8tre d'une fonction auxiliaire sous la forme d'une fonction de continuation.</p> <p>Par convention, cette fonction de continuation est souvent repr\u00e9sent\u00e9e par un param\u00e8tre not\u00e9 k. Plut\u00f4t que d'appeler <code>taille g</code> et d'attendre la fin du calcul pour ensuite calculer des valeurs bas\u00e9es sur son r\u00e9sultat, on appelle aux <code>g (fun resg -&gt; ...)</code>, o\u00f9 le second argument est une fonction qui indique quoi faire une fois que le r\u00e9sultat (<code>resg</code>) est disponible.</p> <pre><code>(* R\u00e9cursion terminale *)\nlet taille a =\n    let rec aux a k = match a with\n        | Nil -&gt; k 0\n        | Node (g,_,d) -&gt;\n          aux g (fun resg -&gt;\n              aux d ( fun resd -&gt;\n                  k (1 + resg + resd )))\n    in aux a (fun x -&gt; x) ;;\n</code></pre> <p>Remarque</p> <p>\\(\\textsf{1.}\\) Ce qu'on met dans la pile d'appel, c'est en fait un pointeur sur le p\u00e8re de <code>d</code> : c'est \u00e0 dire le premier param\u00e8tre de <code>aux</code>.</p> <p>\\(\\textsf{2.}\\) C'est \u00e0 dire l'ordre dans lequel les d\u00e9clarations, les instructions ou les appels de fonction sont ex\u00e9cut\u00e9s ou \u00e9valu\u00e9s</p> <p>Ici, la fonction de continuation <code>k</code> est simplement l'identit\u00e9. On constate que la fonction de continuation <code>fun resg -&gt;...</code> pass\u00e9e en argument dans le second filtrage reconstruit en quelque sorte l'arbre \u00e9tudi\u00e9: sa structure est calqu\u00e9e sur celle de <code>a</code>. </p> <p>On peut voir cela comme l'id\u00e9e selon laquelle on \u00ab emm\u00e8ne l'arbre avec soi \u00bb durant le parcours. L'accumulateur est alors la fonction construite durant le parcours et, une fois qu'il est compl\u00e8tement d\u00e9termin\u00e9, on l'applique \u00e0 son unique argument pour obtenir le r\u00e9sultat escompt\u00e9. Il s'agit bien d'une r\u00e9cursion terminale.</p> <p>Exercice</p> <p>\u00c9crire la fonction <code>hauteur (a : 'a tree) : int</code> qui calcule la hauteur d'un arbre gr\u00e2ce \u00e0 une fonction de continuation.</p>"},{"location":"Arbres/4-ABR/","title":"Arbre Binaire de Recherche et Tas","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>\"Option informatique MPSI, MP/MP*\", Roger Mansuy, paru chez Vuibert.</li> <li>Wikip\u00e9dia : Tas, Tas binaires, Tri par tas</li> <li>OpenClassRoom Arbres binaires de recherche</li> </ul>"},{"location":"Arbres/4-ABR/#arbres-binaires-de-recherche","title":"Arbres binaires de recherche","text":""},{"location":"Arbres/4-ABR/#abr","title":"ABR","text":""},{"location":"Arbres/4-ABR/#bst","title":"BST","text":"<p>D\u00e9finition: Arbre binaire de recherche</p> <p>Binary search trees (BST)</p> <p>Un arbre binaire de recherche (ABR) sur un type totalement ordonn\u00e9 est un arbre binaire tel que pour tout n\u0153ud interne, les \u00e9tiquettes apparaissant dans le sous-arbre gauche (resp.droit) sont strictement\\(^{a.}\\) inf\u00e9rieures (resp. sup\u00e9rieures) \u00e0 celle la racine.</p> <p>\\(a.\\) Selon la mise en \u0153uvre de l\u2019ABR, on pourra interdire ou non des cl\u00e9s de valeur \u00e9gale.</p> <p>Figure \u2013 Un ABR</p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A((8))--&gt;B((3))\n    A--&gt;C((10))\n    B--&gt;D((1))\n    B--&gt;E((6))\n    C--&gt;H(( ))\n    C--&gt;G((14))\n    E--&gt;J((4))\n    E--&gt;K((7))\n    G--&gt;O((13))\n    G--&gt;F(( ))\n    style H display:none\n    style F display:none</code></pre> <p>Les \u00e9tiquettes de gauche ont des valeurs plus petites que celle de la racine, celle de droite sont plus grandes</p>"},{"location":"Arbres/4-ABR/#dsf","title":"DSF","text":"<p>On peut facilement r\u00e9cup\u00e9rer les cl\u00e9s d\u2019un arbre binaire de recherche dans l\u2019ordre croissant en r\u00e9alisant un parcours en profondeur infixe.</p> <p>Contre-exemple</p> <p>Figure \u2013 Un arbre binaire qui n\u2019est pas un ABR</p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB;\n    A((6))--&gt;B((4))\n    A--&gt;C((5))</code></pre>"},{"location":"Arbres/4-ABR/#passage-liste-ordonnee-abr","title":"Passage liste ordonn\u00e9e / ABR","text":"<p>\u00c0 une liste ordonn\u00e9e correspondent plusieurs ABR.</p> Exemple <p>Figure \u2013 Un ABR pour repr\u00e9senter <code>[4,5,6]</code></p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A((6))--&gt;B((5))\n    A --&gt;Z(( ))\n    B--&gt;C((4))\n    B--&gt;W(( ))\n    style Z display:none\n    style W display:none</code></pre> <p>Figure \u2013 Un ABR \u00e9quilibr\u00e9 pour repr\u00e9senter <code>[4,5,6]</code></p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A((5))--&gt;B((6))\n    A--&gt;C((4))</code></pre> <p>Figure \u2013 Un ABR pour repr\u00e9senter <code>[4,5,6]</code></p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A --&gt;Z(( ))\n    A((4))--&gt;B((5))\n    B--&gt;W(( ))\n    B--&gt;C((6))\n    style Z display:none\n    style W display:none</code></pre>"},{"location":"Arbres/4-ABR/#inmplementation","title":"Inmpl\u00e9mentation","text":""},{"location":"Arbres/4-ABR/#type-de-donnees-pour-labr","title":"Type de donn\u00e9es pour l'ABR","text":"<p>Nous utiliserons le type suivant:</p> Type Arbre<pre><code>type 'a tree =\n    | Nil\n    | N of 'a * 'a tree * 'a tree;;\n</code></pre> <ul> <li>Une feuille est impl\u00e9ment\u00e9e par <code>N(x, Nil, Nil)</code>,</li> <li>Un n\u0153ud d\u2019arit\u00e9 \\(1\\) par <code>N(x, t, Nil)</code> ou <code>N(x, Nil, t)</code> avec <code>x</code> et <code>t</code> de type convenable.</li> <li>Une telle structure mod\u00e9lise les arbres binaires, pas seulement les ABR. C\u2019est lors de la cr\u00e9ation d\u2019un arbre que nous ferons attention \u00e0 ce qu\u2019il respecte la contrainte d\u2019ordre.</li> </ul>"},{"location":"Arbres/4-ABR/#primitives-pour-labr","title":"Primitives pour l'ABR","text":"<ul> <li>Une fonction de cr\u00e9ation d\u2019un ABR \u00e0 partir d\u2019une liste.</li> <li>Une fonction d\u2019insertion d\u2019une valeur dans un ABR.</li> <li>Une fonction de recherche d\u2019une valeur dans un arbre.</li> <li>Une fonction de suppression d\u2019une valeur dans un arbre.</li> </ul>"},{"location":"Arbres/4-ABR/#inserer-sous-une-feuille","title":"Ins\u00e9rer sous une feuille","text":"Ins\u00e9rer sous une feuille<pre><code>let rec insert x t = match t with\n    | Nil -&gt; N (x , Nil , Nil )\n    | N (y ,g , d ) when x &lt; y -&gt; N (y , insert x g , d )\n    | N (y , g , d ) when x &gt;y -&gt; N (y ,g , insert x d )\n    | _ -&gt; t (* pas de doublon *) ;; (* le laisser sinon Warning 8. *)\n</code></pre> <ul> <li>Le choix qui est fait ici est celui d\u2019un ABR sans \u00e9tiquettes de m\u00eames valeurs (pas de doublon).</li> <li>On ins\u00e8re la nouvelle valeur sous une feuille.</li> <li>On pourrait aussi ins\u00e9rer \\(x\\) \u00e0 la racine:<ul> <li>\"Couper\" l\u2019arbre en deux sous-ABR \\(g\\) , \\(d\\) contenant respectivement les \u00e9l\u00e9ments plus petits et plus grands que \\(x\\).</li> <li>construire l\u2019arbre <code>N(x, g, d)</code></li> </ul> </li> </ul>"},{"location":"Arbres/4-ABR/#complexite-de-linsertion-sous-une-feuille","title":"Complexit\u00e9 de l\u2019insertion sous une feuille","text":"<p>Description informelle pour un arbre de hauteur \\(h\\) \u00e0 \\(n\\) n\u0153uds.</p> <ul> <li>On descend le long d\u2019une branche jusqu\u2019\u00e0 la feuille.</li> <li>Il y a \\(O(h)\\) pour cette descente. Pour chaque n\u0153ud interne, les op\u00e9rations hors appel r\u00e9cursif sont \u00e0 co\u00fbt constant.</li> <li>Dans le cas d\u2019arr\u00eat, le co\u00fbt est \u00e9galement constant.</li> <li>Donc complexit\u00e9 en \\(O(h)\\).</li> <li>On comprend l\u2019int\u00e9r\u00eat de \"contr\u00f4ler\" \\(h\\). En pratique, on essaye de conserver \\(h \\leq C \\log(n)\\) pour une certaine constante. Si on arrive \u00e0 maintenir cette contrainte au fil des insertions, on obtient un arbre \u00e9quilibr\u00e9.</li> </ul>"},{"location":"Arbres/4-ABR/#creation-dabr","title":"Cr\u00e9ation d'ABR","text":"Cr\u00e9er un ABR \u00e0 partir d\u2019une liste<pre><code>let rec create l = match l with\n    | [] -&gt; Nil\n    | e :: q -&gt; insert e ( create q ) ;;\n\n(*test*)\ncreate ([1;4;2;3]) ;;\n</code></pre> <p>Figure \u2013 ABR obtenu par <code>create([1;4;2;3]);;</code></p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A((3))--&gt;B((2))\n    A--&gt;C((4))\n    B--&gt;D((1))\n    B--&gt;E(( ))\n    style E display:none</code></pre>"},{"location":"Arbres/4-ABR/#liste-triee","title":"Liste tri\u00e9e","text":"<p>Si la liste est d\u00e9j\u00e0 tri\u00e9e, on obtient une liste cha\u00een\u00e9e.</p> <p>Figure \u2013 ABR obtenu par <code>create([1;4;2;3]);;</code></p> <pre><code>%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%\ngraph TB; \n    A((4))--&gt;B((3))\n    A --&gt;Z(( ))\n    B--&gt;C((2))\n    B--&gt;W(( ))\n    C--&gt;D((1))\n    C--&gt;R(( ))\n    style Z display:none\n    style W display:none\n    style R display:none</code></pre>"},{"location":"Arbres/4-ABR/#complexite-de-la-creation-dabr","title":"Complexit\u00e9 de la cr\u00e9ation d'ABR","text":"<ul> <li>Si la liste est d\u00e9j\u00e0 tri\u00e9e, l\u2019ABR n\u2019a qu\u2019une branche.</li> <li>Pour une liste tri\u00e9e de longueur \\(n\\), la complexit\u00e9 v\u00e9rifie une relation de la forme</li> </ul> \\[ \\begin{matrix} c_n &amp;=&amp; c_{n\u22121} + \\underbrace{n}_{\\text{cpx insertion}} + \\underbrace{c}_{\\text{autres op\u00e9ration}}  \\\\ &amp;&amp; \\\\ &amp;=&amp; c_{n\u22122} + 2c + n +  \\underbrace{n-1}_{\\text{cpx insertion}} \\\\  &amp;=&amp; \\text{ ...} \\\\ &amp;=&amp; c_0 + nc + \\sum\\limits_{k=1}^{n}k \\\\ &amp;=&amp; \\theta(n\u00b2) \\end{matrix}\\] <ul> <li>On voit l\u2019int\u00e9r\u00eat de maintenir un certain \u00e9quilibre dans l\u2019arbre au moment des insertions.</li> </ul>"},{"location":"Arbres/4-ABR/#utilite-de-lequilibrage-des-arbres","title":"Utilit\u00e9 de l\u2019\u00e9quilibrage des arbres","text":"<ul> <li>\u00c0 priori, cela ne semble pas si grave d\u2019avoir une liste cha\u00een\u00e9e et non un bel arbre binaire \"\u00e9quilibr\u00e9\".</li> <li>Mais les op\u00e9rations sur les ABR (insertion, suppression, recherche) ont une complexit\u00e9 au pire qui d\u00e9pend de la hauteur...</li> <li>... d\u2019o\u00f9 l\u2019id\u00e9e qu\u2019il faut limiter la hauteur des arbres lors de l\u2019insertion.</li> <li>C\u2019est le principe du r\u00e9\u00e9quilibrage des ABR.</li> </ul>"},{"location":"Arbres/4-ABR/#creation-dun-arbre-equilibre-a-partir-dune-liste","title":"Cr\u00e9ation d\u2019un arbre \u00e9quilibr\u00e9 \u00e0 partir d\u2019une liste","text":"<ul> <li>Un arbre \\(A\\) est dit \u00e9quilibr\u00e9 lorsque \\(h(A) = O(\\log_{}(|A|))\\)</li> <li>Exemple arbres AVL: pour chaque n\u0153ud, la diff\u00e9rence entre les hauteurs de ses fils (l\u2019un \u00e9ventuellement vide) est \\(0\\), \\(1\\) ou \\(\u22121\\).</li> <li> <p>On peut \u00e9tablir que, dans un AVL de taille \\({|A| = n} \\implies {\\frac{3}{2}\\log_{2}(n+ 1) \\geq h(A)}\\) (cf TD).</p> </li> <li> <p>Autre exemple : arbres Rouge-Noir (cf TD).</p> </li> <li>Dans un arbre \u00e9quilibr\u00e9, ins\u00e9rer \\(x\\) se fait en \\(O(\\log_{2}(n))\\) appels internes au pire plus un nombre born\u00e9 d\u2019autres op\u00e9rations en \\(\\Theta(1)\\) .</li> <li>Si on maintient le caract\u00e8re \u00e9quilibr\u00e9 (le r\u00e9\u00e9quilibrage a un co\u00fbt logarithmique -admis-), le co\u00fbt de la cr\u00e9ation \u00e0 partir d\u2019une liste est donc de l\u2019ordre de \\(\\Theta \\left(\\sum\\limits_{k=1}^{n}\\log_{2}(k)\\right) = \\Theta\\left(\\log_{2}(n!)\\right) = \\Theta\\left(n\\log_{2}(n)\\right)\\)</li> </ul>"},{"location":"Arbres/4-ABR/#rechercher","title":"Rechercher","text":"<pre><code>let rec search x t = match t with\n    (* cherche x dans t *)\n    | Nil -&gt; false\n    | N (y ,_ , _ ) when y = x - &gt; true\n    | N (y ,g , _ ) when x &lt; y -&gt; search x g\n    | N (y ,_ , d ) when x &gt; y -&gt; search x d\n    | _ -&gt; false ;; (* le laisser sinon \u2019 this pattern - matching is not exhaustive . \u2019 *)\n</code></pre> <ul> <li>Si \\(x\\) est \u00e9gal \u00e0 la racine de \\(t\\), c\u2019est bon. Sinon on cherche r\u00e9cursivementdans le sous arbre gauche lorsque \\(x\\) es plus petit que la racine, et \u00e0 droite sinon.</li> <li>Si \\(x\\) est \u00e0 la profondeur \\(k\\), il y a \\(k\\) appels internes pour le trouver.</li> <li>Si \\(x\\) n\u2019est pas dans l\u2019arbre, il y a au pire \\(h(t)\\) appels internes.</li> </ul>"},{"location":"Arbres/4-ABR/#suppression","title":"Suppression","text":""},{"location":"Arbres/4-ABR/#operation-de-fusion","title":"Op\u00e9ration de fusion","text":"<p>On veut \"fusionner\" deux ABR \\(G\\) et \\(D\\) tels que les \u00e9tiquettes de \\(G\\) sont toutes plus petites que celles de \\(D\\). Ceci afin d\u2019obtenir un ABR unique construit \u00e0 partir des n\u0153uds des deux arbres.</p> <pre><code>let rec merge a b = match a , b with\n(* fusion qui privil\u00e9gie l \u2019arbre gauche *)\n| Nil , t | t , Nil -&gt; t\n| N (x , ga , da ) , N (y , gb , db ) -&gt; (* on a max a &lt;= min b *)\n    N (x , ga , N (y , merge da gb , db ) ) ;; \n</code></pre> <p>Dans cette fusion, la racine de l\u2019arbre gauche devient syst\u00e9matiquement la racine de l\u2019arbre retourn\u00e9. On aurait pu privil\u00e9gier l\u2019arbre droit.</p> <pre><code>let a1 = N (3 , N (2 , Nil , Nil ) ,N (4 , Nil , Nil ) ) in \nlet a2 = N (30 , N(20 , Nil , Nil ) ,N (40 , Nil , Nil ) ) in\nmerge a1 a2 ;;\n\n(* Et on obtient : *)\nN (3, N (2, Nil, Nil),\n    N (30, N (4 , Nil, N (20, Nil, Nil)),\n        N (40, Nil, Nil)))\n</code></pre> <p><p></p></p> <p>Figure \u2013 En rouge, la fusion des deux arbres bleus</p>"},{"location":"Arbres/4-ABR/#correction-de-la-fusion","title":"Correction de la fusion","text":"<p>Preuve par induction</p> <p>On montre que si on fusionne deux ABR \\(a, b\\) tels que \\(max a \u2264 min b\\), alors le nouvel arbre form\u00e9 est un ABR contenant toutes les \u00e9tiquettes de \\(a, b\\).</p> <ul> <li>Cas de base : si un des deux arbres est vide, on renvoie l\u2019autre. C\u2019est un ABR par hyp. et il contient bien toutes les \u00e9tiquettes des deux arbres.</li> <li>H\u00e9r\u00e9dit\u00e9. Soient \\(a = N(x, g_a, d_a)\\) et \\(b = N(y , g_b, d_b)\\) non vides avec \\(\\max a \\leq \\min b\\).<ul> <li>Notre hypoth\u00e8se d\u2019induction (HI) est que la fusion d\u2019un sous-terme imm\u00e9diats de \\(a\\) avec un sous-terme imm\u00e9diat de \\(b\\) est un ABR contenant toutes les \u00e9tiquettes de ses deux sous-termes.</li> <li>La racine du nouvel arbre est \\(x\\) et elle est plus grande que toutes les \u00e9tiquettes de son fils gauche \\(g_a\\) (puisque \\(a\\) est un ABR).</li> <li>Le fils droit est \\(d = N(y , merge(d_a, g_b), d_b)\\). Par (HI) la fusion <code>merge(da, gb)</code> est un ABR avec toutes les \u00e9tiquettes de \\(d_a, g_b\\).</li> <li>Comme \\(y\\) est sup\u00e9rieur aux \u00e9tiquettes de \\(g_b\\), elles-m\u00eames plus grandes que celles de \\(d_a\\), il vient que y est sup\u00e9rieur aux \u00e9tiquettes de l\u2019ABR r\u00e9sultant de la fusion.</li> <li>Or \\(y\\) est inf\u00e9rieur aux \u00e9tiquettes de \\(d_b\\) puisque \\(b\\) est un ABR. Donc \\(d = N(y , merge(d_a, g_b), d_b)\\) est un ABR dont toutes les \u00e9tiquettes sont aumoins plus grandes que celles de la plus petite de \\(d_a\\). De plus il contient \\(y\\) et toutes les \u00e9tiquettes de \\(d_a, g_b, d_b\\).</li> </ul> </li> <li>Donc \\(x\\) est plus petit que les \u00e9tiquettes de \\(d\\) (qui est un ABR) et plus grand que celles de \\(g_a\\) (qui est un ABR) donc \\(N(x, g_a, d)\\) est un ABR avec toutes les \u00e9tiquettes de \\(a, b\\).</li> </ul>"},{"location":"Arbres/4-ABR/#complexite-de-la-fusion","title":"Complexit\u00e9 de la fusion","text":"<p>Soient deux ABR \\(g , d\\) :</p> <ul> <li>Il y a au plus autant d\u2019appels internes que le minimum de hauteur des sous arbres.</li> <li>La complexit\u00e9 est en \\(\\Theta(\\min(h(g), h(d)))\\) o\u00f9 \\(h(g)\\) et \\(h(d)\\) sont les hauteurs respectives de \\(a, b\\).</li> <li>La fusion est une fonction auxiliaire utilis\u00e9e dans le cadre de la supression d'un noeud d'\u00e9tiquette donn\u00e9e. Dans ce cas, les deux arbres \u00e0 fusionner sont des sous-arbres de l'ABR initial. En notant \\(h\\) la hauteur de l'ABR initial, on a \\(h(g) = O(h)\\) et \\(h(d) = O(h)\\). Il vient donc que la fusion a une complexit\u00e9 temporelle en \\(\\Theta(h)\\)</li> </ul>"},{"location":"Arbres/4-ABR/#code","title":"Code","text":"Code de la suppression<pre><code>let rec remove x t = match t with (* on commence par chercher x dans t *) \n    | Nil -&gt; failwith \" x not found \" (* on n\u2019a pas trouv\u00e9 x *) \n    | N (y,g, d) when x &lt; y -&gt; N (y, remove x g, d) \n    | N (y,g, d) when x &gt; y -&gt; N (y, g, remove x d) (* A partir d'ici, on a trouv\u00e9 x *) \n    | N (y,g, d) when y = x -&gt; merge g d (* fusion des deux sous - arbres *) \n    | _ -&gt; failwith \" ne devrait pas arriver \";;\n</code></pre> <p>Remarques</p> <p>Lorsque le n\u0153ud \\(A\\) d\u2019\u00e9tiquette \\(x\\) n\u2019a qu\u2019un fils, celui-ci prend la place de son p\u00e8re (on le \"remonte\").</p> <p>Si \\(A\\) est une feuille, on se contente de la supprimer (la fusion met <code>Empty</code> \u00e0 la place de \\(A\\)).</p>"},{"location":"Arbres/4-ABR/#rotations","title":"Rotations","text":""},{"location":"Arbres/4-ABR/#rotation-droite","title":"Rotation droite","text":"<p>Soit un ABR avec \\(2\\) noeuds contenant les valeurs \\(u,v\\) et \\(3\\) sous-arbres \\(t_1, t_2, t_3\\)</p> <p></p> <p>On a (en notant de fa\u00e7on abusive) \\(t_1 &lt; u &lt; t_2 &lt; v &lt; t_3\\)</p> <p>On peut r\u00e9organiser l'arbre en conservant la propri\u00e9t\u00e9 d'ABR :</p> <p></p> <p>L'in\u00e9galit\u00e9 \\(t_1 &lt; u &lt; t_2 &lt; v &lt; t_3\\) assure qu'il s'agit bien d'un ABR; Cette transformation s'appelle rotation droite (car les 2 noeuds \\(u, v\\) ont \u00e9t\u00e9 d\u00e9plac\u00e9s vers la droite).</p>"},{"location":"Arbres/4-ABR/#rotations-droite-et-gauche","title":"Rotations droite et gauche","text":"<p>L'op\u00e9ration inverse est \u00e9galement possible</p> <p></p>"},{"location":"Arbres/4-ABR/#reequilibrage","title":"R\u00e9\u00e9quilibrage","text":"<pre><code>let rotate_right = function\n    | N(N(t1, u, t2), v, t3) -&gt; N(t1, u, N(t2, v, t3))\n    | t -&gt; t (*Si op\u00e9ration impossible, renvoyer t*)\n\nlet rotate_left = function\n    | N(t1, u, N(t2, v, t3)) -&gt; N(N(t1, u, t2), v, t3)\n    | t -&gt; t (*Si op\u00e9ration impossible, renvoyer t*)\n</code></pre> <ul> <li>Ces deux rotation constituent l'outil principal de r\u00e9\u00e9quilibrage des ABR.</li> <li>Lorsqu'un arbre se retrouve d\u00e9s\u00e9quilibr\u00e9 parce qu'il commence \u00e0 \"trop pencher d'un c\u00f4t\u00e9\", on utilise une ou plusieurs rotations pour le ramener \u00e0 un arbre plus \u00e9quilibr\u00e9.</li> </ul>"},{"location":"Arbres/4-ABR/#dictionnaires","title":"Dictionnaires","text":""},{"location":"Arbres/4-ABR/#dictionnaire","title":"Dictionnaire","text":"<p>D\u00e9finition: Tableau associatif</p> <p>Tableau associatif (aussi appel\u00e9 dictionnaire ou table d\u2019association) : type de donn\u00e9es associant \u00e0 un ensemble de clefs un ensemble correspondant de valeurs.</p> <p>Chaque clef est associ\u00e9e \u00e0 une valeur unique : un dictionnaire correspond donc \u00e0 une application en math\u00e9matiques.</p> <p>Il peut \u00eatre vu comme une g\u00e9n\u00e9ralisation du tableau dont les indices ne serait pas n\u00e9cessairement des entiers.</p>"},{"location":"Arbres/4-ABR/#operations-usuellement-fournies","title":"Op\u00e9rations usuellement fournies","text":"<ul> <li>ajout : association d\u2019une nouvelle valeur \u00e0 une nouvelle clef ;</li> <li>modification : association d\u2019une nouvelle valeur \u00e0 une ancienne clef ;</li> <li>suppression : suppression d\u2019une clef ;</li> <li>recherche : d\u00e9termination de la valeur associ\u00e9e \u00e0 une clef, si elle existe.</li> </ul> <p>Les dictionnaires peuvent \u00eatre impl\u00e9ment\u00e9s concr\u00e8tement par des ABR. Ce sont alors des donn\u00e9es persistantes. L\u2019ensemble des cl\u00e9s doit \u00eatre totalement ordonn\u00e9. Les \u00e9tiquettes des n\u0153uds de l\u2019ABR sont des couples (cl\u00e9s, valeurs) et le placement d\u2019un n\u0153ud dans l\u2019arbre est fait selon sa cl\u00e9 et non sur sa valeur. En OCaml, explorons \\(3\\) fa\u00e7ons de d\u00e9finir les dictionnaires.</p>"},{"location":"Arbres/4-ABR/#implementation-de-dictionnaire","title":"Impl\u00e9mentation de dictionnaire","text":"<p>Les dictionnnaires peuvent \u00eatre impl\u00e9ment\u00e9s concr\u00e8tement par des ABR. Ce sont alors des donn\u00e9es persistantes.</p> <p>L'ensemble des cl\u00e9s doit totalement \u00eatre ordonn\u00e9.</p> <p>Les \u00e9tiquettes des noeuds de l'ABR sont des couples (cl\u00e9s, valeurs) et le placement d'un noeud dans l'arbre est fait selon sa cl\u00e9 et non sa valeur.</p> <p>En OCaml, explorons \\(3\\) fa\u00e7ons de d\u00e9finir les dictionnaires.</p>"},{"location":"Arbres/4-ABR/#dictionnaires-par-liste-de-paires","title":"Dictionnaires par liste de paires","text":"<p>M\u00e9thode la plus simple. Persistante.</p> <pre><code>(* dictionnaires par liste de paires *)\nlet m = [ \" Sally Smart \", \" 555 -9999 \" ;\n    \" John Doe \", \" 555 -1212 \" ;\n    \" J.Random Hacker \", \" 553 -1337 \" ];;\n\nList.assoc \" John Doe \" m;;\n(* # - : string = \" 555 -1212 \" *)\n</code></pre>"},{"location":"Arbres/4-ABR/#dictionnaires-par-avl","title":"Dictionnaires par AVL","text":"<ul> <li>Les arbres AVL ont \u00e9t\u00e9 historiquement les premiers arbres binaires de recherche automatiquement \u00e9quilibr\u00e9s.</li> <li>Dans un arbre AVL, les hauteurs des deux sous-arbres d\u2019un m\u00eame n\u0153ud diff\u00e8rent au plus de un.</li> <li>La recherche, l\u2019insertion et la suppression sont toutes en \\(O(\\log_{2}(n))\\) dans le pire des cas.</li> <li>L\u2019insertion et la suppression n\u00e9cessitent d\u2019effectuer des rotations (op\u00e9rations de r\u00e9\u00e9quilibrage).</li> </ul> <p>Le nom AVL vient des deux inventeurs Georgii Adelson-Velsky et Evguenii Landis (1962).</p> <pre><code>(* dictionnaire applicatif r\u00e9alis\u00e9 par arbres \u00e9quilibr\u00e9s *)\ninclude (Map.Make (String));; \nlet m = empty \n    |&gt; add \" Sally Smart \" \" 555 -9999 \" \n    |&gt; add \" John Doe \" \" 555 -1212 \" \n    |&gt; add \" J.Random Hacker \" \" 553 -1337 \";; \n\nfind \" John Doe \" m;; \n(* # - : string = \"555 -1212\" *) \n</code></pre> <p>Structure persistante bas\u00e9e sur les arbres \u00e9quilibr\u00e9s. Ajout/Suppression/Recherche en temps logarithmique.</p>"},{"location":"Arbres/4-ABR/#dictionnaires-par-table-de-hachage","title":"Dictionnaires par table de hachage","text":"<pre><code>(* dictionnaires par table de hachage polymorphe *)\nlet m = Hashtbl.create 3;; (* taille attendue 3 , \u00e7 a peut changer *)\nHashtbl.add m \" Sally Smart \" \" 555 -9999 \" ;\nHashtbl.add m \" John Doe \" \" 555 -1212 \" ;\nHashtbl.add m \" J . Random Hacker \" \" 553 -1337 \" ;;\nHashtbl.find m \" John Doe \" ;;\n\n(* # - : string = \"555 -1212\" *)\n</code></pre> <p>Structure imp\u00e9rative. Modifications en place. Ajout/Suppression/Recherche en temps constant (en moyenne pour ajout, et pour la recherche, \u00e7a d\u00e9pend en fait de la fonction de hash).</p>"},{"location":"Arbres/4-ABR/#tas","title":"Tas","text":""},{"location":"Arbres/4-ABR/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":"<p>D\u00e9finition: Tas</p> <p>Un tas de hauteur h est un arbre binaire v\u00e9rifiant :</p> <ul> <li>Condition d\u2019ordre : les fils d\u2019un n\u0153ud ont une \u00e9tiquette inf\u00e9rieure ou \u00e9gale \u00e0 celle du p\u00e8re.</li> <li>Condition de structure: Un tas est complet gauche :<ul> <li>Tous les niveaux sont remplis sauf \u00e9ventuellement le dernier.</li> <li>Le dernier niveau (\u00e9ventuellement incomplet) est rempli sans trou enpartant de la gauche.</li> </ul> </li> </ul>"},{"location":"Arbres/4-ABR/#precisions-et-consequences","title":"Pr\u00e9cisions et cons\u00e9quences","text":"<ul> <li>Un arbre du type pr\u00e9c\u00e9dent est dit de type tas-max (racine=max).</li> <li>tas-min : l\u2019\u00e9tiquette du p\u00e8re est plus petite que celle des fils.</li> <li>Les branches sont toutes de longueur \\(h\\) ou \\(h \u2212 1\\), </li> <li>enlever les feuilles de profondeur \\(h\\) donne un arbre parfait,</li> <li>les n\u0153uds internes de profondeur \\(h \u2212 1\\) d\u2019arit\u00e9 \\(\u2265 1\\) sont \u00e0 gauche des feuilles de profondeur \\(h \u2212 1\\),</li> <li>si il y a un n\u0153ud interne de profondeur \\(h \u2212 1\\) avec un seul fils, son fils est une feuille et c\u2019est le dernier n\u0153ud dans le parcours en largeur.</li> </ul> <p>Figure \u2013 Un tas. Si on enl\u00e8ve les feuilles de profondeur \\(2\\), l\u2019arbre est parfait</p> <p><p></p></p> <p>(cf figure dans la section Tas et Tableaux pour la repr\u00e9sentation en array)</p> <p>Tous les niveaux sont remplies, sauf le dernier, lequel est partiellement rempli en commen\u00e7ant par la gauche.</p> <p>Contre-exemples</p> <p>Les arbres suivants ne sont pas des tas : <p></p> Figure \u2013 Un n\u0153ud de hauteur \\(h \u2212 1\\) et d\u2019arit\u00e9 \\(1\\) est \u00e0 gauche d\u2019un n\u0153ud de hauteur \\(h \u2212 1\\) d\u2019arit\u00e9 \\(2\\) <p></p> Figure \u2013 Un p\u00e8re a un fils d\u2019\u00e9tiquette plus grande que la sienne</p>"},{"location":"Arbres/4-ABR/#hauteur-dun-arbre-complet-gauche","title":"Hauteur d\u2019un arbre complet gauche","text":"<p>Soit \\(A\\) un arbre complet gauche \u00e0 \\(n\\) n\u0153uds et de hauteur \\(p\\)</p> <ul> <li>L\u2019avant dernier niveau (qui correspond \u00e0 un arbre parfait) est rempli. Et le dernier niveau contient au moins une feuille.</li> </ul> \\[\\begin{matrix} &amp;2p \u2212 1 &lt; n \u2264 &amp; \\underbrace {2^{p+1} \u2212 1}_\\text{taille min. d\u2019un arbre parfait plus gros que A} \\\\ &amp;\\Rightarrow &amp; 2p \u2264 n &lt; 2^{p+1} &amp;\\\\ &amp;\\Rightarrow &amp; p \u2264 log_2(n) &lt; p + 1 &amp;\\\\ &amp;\\Rightarrow &amp;\\lfloor \\log_2(n) \\rfloor  = p\\\\ \\end{matrix}\\]"},{"location":"Arbres/4-ABR/#representation-par-tableaux","title":"Repr\u00e9sentation par tableaux","text":"<p>Exemple</p> <p><p></p> Figure \u2013 Un tableau repr\u00e9sentant un tas</p> <p>Observer le lien entre le parcours en largeur et la repr\u00e9sentation en tableau.</p> <p>Contrexemples</p> <p>Les arbres suivants ne sont pas des tas : <p></p></p> <p>Figure \u2013 Un n\u0153ud de hauteur \\(h \u2212 1\\) et d\u2019arit\u00e9 \\(1\\) est \u00e0 gauche d\u2019un n\u0153ud de hauteur \\(h \u2212 1\\) d\u2019arit\u00e9 \\(2\\)</p> <p><p></p></p> <p>Figure \u2013 Un p\u00e8re a un fils d\u2019\u00e9tiquette plus grande que la sienne</p>"},{"location":"Arbres/4-ABR/#tas-et-tableaux","title":"Tas et tableaux","text":"<p>On peut stocker un tas dans un tableau dont on n\u2019utilise pas (pour le moment) le premier \u00e9l\u00e9ment.</p> <ul> <li>La racine occupe l\u2019\u00e9l\u00e9ment d\u2019indice \\(1\\),</li> <li>Les fils du n\u0153ud d\u2019indice \\(k\\) (avec \\(k &gt; 0\\)) sont aux indices \\(2k\\) et \\(2k + 1\\) (si ceux-ci ne d\u00e9passent pas la longueur du tableau).</li> <li>Le p\u00e8re du n\u0153ud d\u2019indice \\(k\\) est \u00e0 l\u2019indice \\(\\lfloor k/2 \\rfloor\\).</li> </ul> <p></p> <p>Figure \u2013 Relations p\u00e8re/fils dans un tableau repr\u00e9sentant un tas</p>"},{"location":"Arbres/4-ABR/#en-ocaml","title":"En OCaml","text":"<pre><code>(* correspond au sch\u00e9ma pr\u00e9c\u00e9dent en OCAML *) \nlet t = [|6; 12; 9; 6; 2; 7; 5; 0; 67; 33|];;\n</code></pre> <p>Lorsqu\u2019on cr\u00e9e un tableau repr\u00e9sentant un tas :</p> <ul> <li>Il faut pr\u00e9voir la taille du tableau \u00e0 l\u2019instant initial (\\(6\\) ici) et les \u00e9ventuels ajouts \u00e0 e\ufb00ectuer (en clair pr\u00e9voir plus de place que la simple taille du tableau \u00e0 l\u2019instant \\(0\\)).</li> <li>Le premier \u00e9l\u00e9ment du tableau d\u00e9signe la taille du tas (qui est di\ufb00\u00e9rente de celle du tableau).</li> <li>Les \u00e9l\u00e9ments \\(0\\), \\(67\\), \\(33\\) en fin de tableau ne sont pas consid\u00e9r\u00e9s comme appartenant au tas. Ils seront remplac\u00e9s par les valeurs \u00e9ventuellement ajout\u00e9es au tas.</li> </ul> <p>Un probl\u00e8me</p> <p>Le type de la taille du tas (int) fige le type du tableau avec l\u2019impl\u00e9mentation pr\u00e9c\u00e9dente. Toutes les valeurs du tas doivent \u00eatre des entiers...</p> <p>Une solution</p> <pre><code>(* pour dissocier le type de la taille du tas de celui de ses \u00e9l\u00e9ments,  on peut utiliser un type enregistrement *) \ntype \u2019a myHeap =\n    { mutable length : int ; heap : \u2019a array };;\n</code></pre>"},{"location":"Arbres/4-ABR/#operations","title":"Op\u00e9rations","text":""},{"location":"Arbres/4-ABR/#operations-sur-les-tas","title":"Op\u00e9rations sur les tas","text":"<ul> <li>Ajouter : ajout d\u2019un \u00e9l\u00e9ment dans le tas binaire en pr\u00e9servant la structure de tas.</li> <li>Retirer : retirer un \u00e9l\u00e9ment d\u2019indice donn\u00e9 et rectifier le tableau pour qu\u2019il corresponde de nouveau \u00e0 un tas.</li> <li>Construire : construction du tas binaire \u00e0 partir d\u2019un ensemble d\u2019\u00e9l\u00e9ments.</li> </ul>"},{"location":"Arbres/4-ABR/#ajouter-un-element","title":"Ajouter un \u00e9l\u00e9ment","text":""},{"location":"Arbres/4-ABR/#principe","title":"Principe","text":"<p>Consid\u00e9rons que l\u2019on veuille ajouter le n\u0153ud \\(x\\) \u00e0 notre tas binaire :</p> <ul> <li>On ins\u00e8re \\(x\\) \u00e0 la prochaine position libre (la position libre la plus \u00e0 gauche possible sur le dernier niveau),</li> <li>puis on e\ufb00ectue l\u2019op\u00e9ration suivante (que l\u2019on appelle percolation vers le haut ou percolate-up) pour r\u00e9tablir si n\u00e9cessaire la propri\u00e9t\u00e9 d\u2019ordre du tas binaire :</li> <li>Tant que \\(x\\) n\u2019est pas la racine de l\u2019arbre et que l\u2019\u00e9tiquette de \\(x\\) est strictement sup\u00e9rieure \u00e0 celle du p\u00e8re, \u00e9changer les positions entre \\(x\\) et son p\u00e8re.</li> </ul>"},{"location":"Arbres/4-ABR/#shema-de-lajout","title":"Sh\u00e9ma de l'ajout","text":"Exemple <p>On veut ajouter \\(50\\) dans un tas-max : <p></p> Figure \u2013 On cherche le seul emplacement possible pour pr\u00e9server la structure d\u2019arbre complet gauche</p> <p><p></p></p> <p>Figure \u2013 le n\u0153ud d\u2019\u00e9tiquette \\(50\\) est plac\u00e9 provisoirement. On le compare \u00e0 son p\u00e8re \\((28)\\) </p> <p><p></p></p> <p>Figure \u2013 Comme \\(50 &gt; 28\\), on \u00e9change les positions de \\(50\\) et \\(28\\). Et on compare \\(50\\) avec son nouveau p\u00e8re \\((41)\\)... </p> <p><p></p></p> <p>Figure \u2013 Comme \\(50 &gt; 41\\), on \u00e9change les positions de \\(50\\) et \\(41\\). Et on compare \\(50\\) avec son nouveau p\u00e8re \\((53)\\)... </p> <p><p></p></p> <p>Figure \u2013 Comme \\(50 \u2264 53\\), il n\u2019y a rien \u00e0 faire : \\(50\\) a trouv\u00e9 sa bonne place </p>"},{"location":"Arbres/4-ABR/#la-fonction-auxiliaire-dechange","title":"La fonction auxiliaire d\u2019\u00e9change","text":"<pre><code>let swap i j t = (*\u00e9change deux \u00e9l\u00e9ments d\u2019un tableau*) \n    let c = t.(i) in t.(i) &lt;-t.(j) ; t.(j) &lt;-c;; \n</code></pre> <p>Complexit\u00e9 en \\(\\Theta(1)\\).</p>"},{"location":"Arbres/4-ABR/#la-fonction-auxiliaire-de-percolation","title":"La fonction auxiliaire de percolation","text":"<pre><code>let rec percolate_up n t = \n    (* n est l\u2019indice de l\u2019\u00e9l\u00e9ment \u00e0 percoler *)\n    if n &gt; 1 then \n        begin (* t .(n) n'est pas la racine *) \n        let m = n /2 (* indice du p\u00e8re *) \n        in if t.(m) &lt; t.(n) then \n            begin \n                swap m n t ; (*\u00e9change p\u00e8re / fils *) \n                percolate_up m t ; (* percolate_up avec m *) \n            end ;\n    end;; \n</code></pre>"},{"location":"Arbres/4-ABR/#complexite-de-la-percolation-haute","title":"Complexit\u00e9 de la percolation haute","text":"<p>On applique cette fonction \u00e0 un tas d\u2019entiers de \\(n\\) n\u0153uds (repr\u00e9sent\u00e9 par un tableau) :</p> <ul> <li>Dans le pire des cas, l\u2019\u00e9l\u00e9ment remonte la branche la plus longue du tas : \\(\\log_2(n)\\) \u00e9tapes puisque le tas est un arbre binaire presque parfait.</li> <li>\u00c0 chaque \u00e9tape, il y a un nombre born\u00e9 \\(c\\) d\u2019op\u00e9rations \u00e9l\u00e9mentaires.</li> <li>Au total, entre \\(\\log_2(n)\\) op\u00e9rations et \\(c\\log_2(n)\\). Complexit\u00e9 en \\(\\Theta(\\log_2(n))\\).</li> </ul>"},{"location":"Arbres/4-ABR/#la-fonction-dinsertion","title":"La fonction d\u2019insertion","text":"<p>Principe</p> <p>On ins\u00e8re l\u2019\u00e9l\u00e9ment apr\u00e8s le dernier \u00e9l\u00e9ment du tableau (\\(\\Theta(1)\\)) et on percole (au pire \\(\\Theta(\\log_2(n))\\)) si \\(n\\) est le nombre de n\u0153ud). Donc complexit\u00e9 au pire \\(\\Theta(\\log_2(n))\\):</p> <pre><code>let insert v t = \n    t.(0) &lt;- t.(0) +1; (* maj lg du tas *) \n    t.(t.(0)) &lt;- v ; (* placer v \u00e0 la derni \u00e8 re place *) \n    percolate_up (t.(0)) t;;\n</code></pre>"},{"location":"Arbres/4-ABR/#supprimer-un-element","title":"Supprimer un \u00e9l\u00e9ment","text":""},{"location":"Arbres/4-ABR/#shema-de-la-suppression","title":"Sh\u00e9ma de la suppression","text":"Schema <p><p></p></p> <p>Figure \u2013 Le tas-max de r\u00e9f\u00e9rence</p> <p>On souhaite supprimer la racine du tas-max suivant :</p> <p><p></p></p> <p>Figure \u2013 On remplace la racine par le dernier n\u0153ud</p> <p><p></p></p> <p>Figure \u2013 On compare \\(20\\) et son fils max \\((41)\\). Comme \\(41 &gt; 20\\), on \u00e9change \\(41\\) et \\(20\\)</p> <p><p></p></p> <p>Figure \u2013 On compare \\(20\\) et son fils max \\((36)\\). Comme \\(36 &gt; 20\\), on \u00e9change \\(36\\) et \\(20\\)</p> <p><p></p></p> <p>Figure \u2013 On compare \\(20\\) et son fils max \\((31)\\). Comme \\(31 &gt; 20\\), on \u00e9change \\(31\\) et \\(20\\). On est alors dans un des deux cas d\u2019arr\u00eat : plus de fils ou pas de fils plus grand. Ici, \\(20\\) n\u2019a plus de fils. On a fini. </p>"},{"location":"Arbres/4-ABR/#principe-de-suppression","title":"Principe de suppression","text":"<p>On veut supprimer la racine :</p> <ul> <li>Lorsqu\u2019on supprime le dernier n\u0153ud d\u2019un tas, celui-ci reste un tas.</li> <li>On supprime le dernier n\u0153ud et on le met \u00e0 la place du n\u0153ud racine (la propri\u00e9t\u00e9 d\u2019ordre est perdue).</li> <li>On percole vers le bas (percolate-down) pour retrouver la propri\u00e9t\u00e9 d\u2019ordre.</li> </ul>"},{"location":"Arbres/4-ABR/#recherche-du-plus-grand-fils","title":"Recherche du plus grand fils","text":"<pre><code>let aux_max n t = (* cette fonction retourne l\u2019indice du fils le plus grand de t .(n) ; -1 si pas de fils *) \n    if 2 * n &lt; t.(0) then \n        begin (* t .(n) a deux fils *) \n            if t.(2* n) &lt; t.(2* n +1) then 2* n +1 \n            else 2* n \n        end \n    else (* moins de deux fils *) \n        begin \n            if 2 * n = t.(0) then 2 * n (* un seul fils *) \n            else -1 (* pas de fils *) \n        end;; \n</code></pre> <p>Complexit\u00e9 en \\(O(1)\\).</p>"},{"location":"Arbres/4-ABR/#percolate-down","title":"Percolate-down","text":"<pre><code>let rec percolate_down k t = \n    let m = aux_max k t (* m vaut -1,2 k ou 2 k +1 *) in \n        if m &gt; -1 &amp;&amp; t.(m) &gt; t.(k) then\n            (* rqe : si m = -1 ou t .(m) &lt;= t .(k) on ne fait rien *) \n            begin \n                swap k m t ; \n                percolate_down m t ; 10 \n            end;; \n</code></pre>"},{"location":"Arbres/4-ABR/#complexite-de-la-percolation-basse","title":"Complexit\u00e9 de la percolation basse","text":"<ul> <li>\u00c0 chaque appel interne on descend d\u2019un \u00e9tage dans l\u2019arbre.</li> <li>Le nombre d\u2019appel est major\u00e9 par la hauteur \\((\\) \\(\\log_2(n)\\) pour \\(n\\) n\u0153uds dans cet arbre complet gauche \\()\\).</li> <li>A chaque appel interne, il y a moins de \\(c\\) op\u00e9rations \u00e9l\u00e9mentaires.</li> <li>Co\u00fbt total entre \\(\\log_2(n)\\) et \\(c\\log_2(n)\\). ODG \\(\\Theta(\\log_2(n))\\)</li> </ul>"},{"location":"Arbres/4-ABR/#supprimer-la-racine","title":"Supprimer la racine","text":"<pre><code>let remove t = \n    (* mettre dernier elt dans t .(1) : *)\n    t.(1) &lt;- t.(t.(0)) ;\n    (* chger taille du tas : *)\n    t.(0) &lt;- t.(0) - 1;\n    percolate_down 1 t;;\n</code></pre> <p>Complexit\u00e9 : la m\u00eame que la percolation.</p>"},{"location":"Arbres/4-ABR/#creation","title":"Cr\u00e9ation","text":""},{"location":"Arbres/4-ABR/#par-remontee-percolation-haute-du-nud-courant","title":"Par remont\u00e9e : percolation haute du n\u0153ud courant","text":"<ul> <li> <p>Pour \\(t\\), tableau de taille \\(n\\), on fait une copie de taille assez grande, disons n+1\u00a0: $$ \\begin{array}{|c|c|c|} 6 &amp; 12 &amp; 8 &amp; 7 &amp; 15 &amp; \u2192 &amp; \\color{red}{5} &amp; 6 &amp; 12 &amp; 8 &amp; 7 &amp; 15 \\ \\end{array} $$ Et on maintient \"\\(t[1:k+1]\\) est un tas\" (notation slicing Python).</p> </li> <li> <p>\\(k = 1\\) : $$ \\begin{array}{|c|c|c|} 5 &amp; \\color{red}6 &amp; 12 &amp; 8 &amp; 7 &amp; 15 \\end{array} $$ \\(t[1:2]\\) est un tas</p> </li> <li> <p>\\(k = 2\\)\u00a0: \\begin{array}{|c|c|c|} 5 &amp; \\color{red}6 &amp; \\color{red}12 &amp; 8 &amp; 7 &amp; 15 \\end{array} On percole up \\(12\\). \\begin{array}{|c|c|c|} 5 &amp; \\color{red}12 &amp; 6 &amp; \\color{red}8 &amp; 7 &amp; 15 \\end{array} t[1:3] est un tas.</p> </li> <li> <p>\\(k = 3\\) : \\(8\\) est \u00e0 sa place. \\(t[1:4]\\) est un tas.</p> </li> <li> <p>\\(k = 4\\) : \\begin{array}{|c|c|c|} 5 &amp; 12 &amp; \\color{red}6 &amp; 8 &amp; \\color{red}7 &amp; 15 \\end{array} On percole up \\(7\\)\u00a0: \\begin{array}{|c|c|c|} 5 &amp; 12 &amp; \\color{red}7 &amp; 8 &amp; \\color{red}6 &amp; 15 \\end{array} \\(t[1:5]\\) est un tas.</p> </li> <li> <p>\\(k = 5\\) : \\begin{array}{|c|c|c|} 5 &amp; 12 &amp; \\color{red}7 &amp; 8 &amp; 6 &amp; \\color{red}15 \\end{array} On percole up \\(15\\) deux fois \\begin{array}{|c|c|c|} 5 &amp;12 &amp;\\color{red}15 &amp;8 &amp;6 &amp;\\color{red}7 \\end{array} \\begin{array}{|c|c|c|} 5 &amp;\\color{red}12 &amp;\\color{red}15 &amp;8 &amp;6 &amp;7 \\end{array} \\begin{array}{|c|c|c|} 5 &amp; \\color{red}15 &amp; \\color{red}12 &amp; 8 &amp; 6 &amp; 7 \\end{array} \\(t[1:6]\\) est un tas.</p> </li> </ul>"},{"location":"Arbres/4-ABR/#complexite-de-la-creation-du-tas-par-remontee","title":"Complexit\u00e9 de la cr\u00e9ation du tas par remont\u00e9e","text":"<p>Il y a \\(n\\) n\u0153ud, donc une hauteur de \\(p=\\lfloor \\log_2(n) \\rfloor\\).</p> <p>Pire des cas : chaque remont\u00e9e aboutit \u00e0 la racine.</p> <p>Niveau \\(k\\) : au plus \\(2^k\\) n\u0153uds remontent \u00e0 la racine en \\(k\\) \u00e9tapes.</p> \\[ \\begin{matrix} C(n) &amp;\u2264&amp; \\sum_{k = 1}^{p} k2^k = 2 \\sum_{k = 1}^p k2^{k-1}&amp; \\\\ &amp;&amp; \\\\ &amp;=&amp; 2 \\frac{d}{dx}( \\frac{x^{p+1} -1 }{x-1}) [2] &amp; \\\\ &amp;&amp; \\\\ &amp;\\leq&amp; (x \\rightarrow \\frac{\u2212px^p + px^{p+1} \u2212 x^p + 1}{ x^2 \u2212 2x + 1} )[2]\\\\ &amp;&amp; \\\\ &amp;\\leq&amp; p2^p - 2^p +1 \\leq p2^p = \\underbrace{2^{\\lfloor \\log_2(n) \\rfloor}\\lfloor \\log_2(n) \\rfloor}_{ O(n \\log_2(n))}  \\end{matrix} \\]"},{"location":"Arbres/4-ABR/#par-descente-percolation-basse-du-nud-courant","title":"Par descente : percolation basse du n\u0153ud courant","text":"<p>A partir d\u2019un tableau d'entiers :</p> <ul> <li>On le consid\u00e8re comme un arbre complet gauche en d\u00e9calant ses \u00e9l\u00e9ments d\u2019un cran \u00e0 droite et en ins\u00e9rant sa longueur.</li> <li>Parcours du tableau : on maintient l\u2019invariant Tous les sous-arbres dont la racine est \u00e0 droite du sommet courant sont des tas binaires.</li> <li>On parcourt les sommets par indices d\u00e9croissants \u00e0 partir du premier noeud interne (position \\(\\lfloor \\frac{n}{2} \\rfloor\\))</li> <li> <p>Donc apr\u00e8s avoir trait\u00e9 la racine, comme elle v\u00e9rifie l\u2019invariant, notre arbre est un tas binaire.</p> </li> <li> <p>Pour \\(t\\), tableau de taille \\(n\\), on fait une copie de taille disons \\(n+1\\) \\begin{array}{|c|c|c|} 6 &amp; 12 &amp; 8 &amp; 7 &amp; 15 &amp; 9 &amp; \u2192 &amp; \\color{red}6 &amp; 6 &amp; 12 &amp; 8 &amp; 7 &amp; 15 &amp; 9 \\end{array} \\(7,15, 9\\) aux indices &gt; \\(\\lfloor \\frac{n}{2}\\rfloor\\) sont des feuilles donc des tas.</p> </li> <li>\\(k=\\lfloor \\frac{n}{2}\\rfloor = 3\\) (Profondeur \\(1\\)). \\(8\\) est le p\u00e8re de \\(9\\). \\begin{array}{|c|c|c|} 6 &amp; 6 &amp; 12 &amp; \\color{red}8 &amp; 7 &amp; 15 &amp; \\color{red}9 &amp; \u2192 &amp; 6 &amp; 6 &amp; 12 &amp; \\color{red}9 &amp; 7 &amp; 15 &amp; \\color{red}8 \\end{array}</li> <li>\\(k = 2\\) (Profondeur \\(1\\)). \\(12\\) est p\u00e8re de \\(7\\) et \\(15\\) \\begin{array}{|c|c|c|} 6 &amp; 6 &amp; \\color{red}12 &amp; 9 &amp; 7 &amp; \\color{red}15 &amp; 8 &amp; \u2192 &amp; 6 &amp; 6 &amp; \\color{red}15 &amp; 9 &amp; 7 &amp; \\color{red}12 &amp; 8 \\end{array}</li> <li>\\(k = 1\\) (Profondeur \\(0\\)). \\(6\\) est p\u00e8re de \\(15\\) et \\(9\\). \\(2\\) percos. \\begin{array}{|c|c|c|} 6 &amp; \\color{red}6 &amp; \\color{red}15 &amp; 9 &amp; 7 &amp; \\color{red}12 &amp; 8 &amp; \u2192 &amp; 6 &amp; \\color{red}15 &amp; \\color{red}6 &amp; 9 &amp; 7 &amp; \\color{red}12 &amp; 8 \\end{array} \\begin{array}{c|c|c|} \u2192 6 &amp; \\color{red}15 &amp; \\color{red}12 &amp; 9 &amp; 7 &amp; \\color{red}6 &amp; 8 \\end{array}</li> </ul>"},{"location":"Arbres/4-ABR/#complexite-de-la-creation-du-tas-par-descente","title":"Complexit\u00e9 de la cr\u00e9ation du tas par descente","text":"<p>Hauteur \\(p=\\lfloor \\log_2(n) \\rfloor\\) pour \\(n\\) n\u0153uds.</p> <ul> <li> <p>Dans le pire des cas, chaque descente d\u2019un n\u0153ud de hauteur \\(k\\) aboutit aux feuilles : \\(p \u2212 k\\) \u00e9changes AU PLUS.</p> </li> <li> <p>Il y a au plus \\(\\lfloor \\frac{n}{2^{p-k}} \\rfloor\\) n\u0153uds de profondeur \\(k\\) (cf. TD).</p> </li> <li> <p>Complexit\u00e9 \\(C(n)\\) au pire :</p> </li> </ul> \\[ \\begin{matrix} C(n) &amp;\u2264&amp; \\underbrace{\\sum_{k = 0}^p {\\lfloor \\frac{n}{2^{p-k}} \\rfloor}}_\\text{nb node de hauteur k} {\\underbrace{\\overbrace{(p \u2013 k)}^\\text{nb \u00e9changes au pire...}}_\\text{...pour chaque node}}&amp;\\\\ &amp;&amp;\\\\ &amp;\u2264&amp; \\sum_{k=0}^p (\\frac{n}{2^{p-k}} + 1)(p-k)\\overbrace{\\leq}^\\text{ cgt. var. k = p-k } \\sum_{k=0}^p ( \\frac{n}{2^k} + 1 )k&amp;\\\\ &amp;&amp;\\\\ &amp;\u2264&amp; \\overbrace{ \\frac{p(p+1)}{2} }^{O(log_2(n)^2) } \\underbrace{\\sum_{k=0}^p {\\frac{k}{2^k}}}_\\text{s\u00e9rie CV donc major\u00e9e} = O( n )&amp; \\end{matrix} \\] <p>Donc cr\u00e9ation par descente moins co\u00fbteuse (\\(O(n)\\)) que par remont\u00e9e (\\(O(n \\log_2(n))\\)).</p>"},{"location":"Arbres/4-ABR/#tri-croissant-par-tas","title":"Tri (croissant) par tas","text":"<p>A partir d\u2019un tableau de \\(n\\) nombres \\(t\\), on cr\u00e9e un tas-max.</p> <ul> <li>\u00c9tape \\(1\\) : la racine \\(t[1]\\) est le maximum du tas, on l\u2019\u00e9change avec \\(t[n]\\) (notation Python). Le max se retrouve \u00e0 la fin du tas en position \\(t[n]\\). \\(\\color{red}t[n:] \\text{ est tri\u00e9 et contient le max.}\\)</li> <li>On met \u00e0 jour la longueur du tas (qui repr\u00e9sente le nombre d\u2019\u00e9l\u00e9ments qu\u2019il reste \u00e0 trier) en la d\u00e9cr\u00e9mentant (puisque l\u2019ancienne racine a trouv\u00e9 sa place). \\(t[:n]\\) est un tas.</li> <li>On percole bas la nouvelle racine. \\(\\color{red}\\text{Alors t[1:n] est de nouveau un tas}\\). Et on it\u00e8re(swap puis percolation)...</li> <li>L\u2019invariant qui assure la correction est \"\u00c0 la fin de l\u2019\u00e9tape \\(k\\), \\(\\color{red}\\text{t[:n-k+1] est un tas et t[n-k+1 :] est un tableau tri\u00e9}\\) par ordre croissant dont les \u00e9l\u00e9ments sont plus grands que ceux de \\(t[:n-k+1]\\)\". Il y a \\(n\\) \u00e9tapes.</li> </ul>"},{"location":"Arbres/4-ABR/#tri-par-tas","title":"Tri par tas","text":"<pre><code>let tri_tas l = \n    let t = create_down l in (* O (n) *)  \n    while t .(0) &gt; 1 do \n        (* mettre le max \u00e0 la fin du tab : *) \n        swap 1 t.(0) t ; \n        t.(0) &lt; -(t.(0)-1) ; (* le tas \u00e0 \u00e9tudier a un \u00e9l\u00e9ment de moins *) \n        percolate_down 1 t (* O (log (n)) *) \n    done ; t;; \n</code></pre>"},{"location":"Arbres/4-ABR/#complexite","title":"Complexit\u00e9","text":"<ul> <li>\\(O(n)\\) pour la cr\u00e9ation d\u2019un tas (rappel : hauteur \\(O(\\log_2(n))\\)).</li> <li>Chaque \u00e9change d\u2019\u00e9l\u00e9ments et chaque d\u00e9cr\u00e9mentation de \\(t.(0)\\) en \\(O(1)\\)</li> <li>Chaque appel \u00e0 <code>percolate down</code> en \\(O(\\log_2(n))\\) (majoration grossi\u00e8re car la longueur du tas d\u00e9cro\u00eet).</li> <li>\\(n\\) passages dans la boucle.</li> <li>Complexit\u00e9 au pire en \\(O(n\\log_2(n))\\) \u00e0 la louche.</li> <li>On ne peut pas faire mieux pour un tri par comparaison. Donc complexit\u00e9 en \\(\\Theta(n\\log_2(n))\\)</li> </ul>"},{"location":"Arbres/4-ABR/#files-de-priorites-une-application-des-tas","title":"Files de priorit\u00e9s (une application des tas)","text":"<p>D\u00e9finition : Une file de priorit\u00e9</p> <p>Une file de priorit\u00e9 est une structure de donn\u00e9es permettant de stocker des \u00e9l\u00e9ments et de retrouver e\ufb03cacement celui qui a la plus haute priorit\u00e9.</p> <p>Il y a trois primitives :</p> <ul> <li>ins\u00e9rer un \u00e9l\u00e9ment ;</li> <li>extraire l\u2019\u00e9l\u00e9ment ayant la plus grande cl\u00e9 ;</li> <li>tester si la file de priorit\u00e9 est vide ou pas.</li> <li>On ajoute parfois \u00e0 cette liste l\u2019op\u00e9ration \"augmenter/diminuer\" la cl\u00e9 d\u2019un \u00e9l\u00e9ment\", utilis\u00e9e par exemple dans l\u2019algorithme de Dijkstra.</li> </ul> <p>Les priorit\u00e9s sont d\u2019un type totalement ordonn\u00e9.</p> <p>Une file de priorit\u00e9 permet d\u2019impl\u00e9menter efficacement des planificateurs de t\u00e2ches, o\u00f9 un acc\u00e8s rapide aux t\u00e2ches d\u2019importance maximale est souhait\u00e9.</p> <p>On trouve une file de priorit\u00e9, par exemple, dans les ordonnanceurs des syst\u00e8mes d\u2019exploitation, notamment le noyau \\(Linux\\).</p> <p>Les urgences d\u2019un h\u00f4pital </p> <ul> <li>Chaque nouveau patient est ajout\u00e9 \u00e0 la file,</li> <li>chaque fois qu\u2019un m\u00e9decin est libre, il s\u2019occupe du patient avec l\u2019\u00e9tat le plus critique.</li> <li>Le tri des patients se fait sur des crit\u00e8res quantifiables et ordonn\u00e9s comme<ul> <li>comme l\u2019\u00e9tat de conscience : \u00c9chelle de Glasgow \\([\\![1,4]\\!]\\times[\\![1,5]\\!]\\times[\\![1,6]\\!]\\) (priorit\u00e9 aux scores bas, ce qui entra\u00eene d\u2019utiliser un tas-min)</li> </ul> </li> </ul> <p><p></p> Figure - Score de Glasgow : somme de trois crit\u00e8res</p> <ul> <li>s\u2019ils respirent (\\(1\\) ou \\(0\\)), ou s\u2019ils saignent (volume de la perte de sang)...</li> </ul>"},{"location":"Arbres/4-ABR/#type-de-donnees-pour-la-file-de-priorite","title":"Type de donn\u00e9es pour la file de priorit\u00e9","text":"<p>Comme le tas est un tableau de donn\u00e9es (type data), on ne peut plus r\u00e9server le premier \u00e9l\u00e9ment \u00e0 l\u2019indication de sa longueur(type int).</p> <p>Toutefois, on a pris l\u2019habitude de stocker les donn\u00e9es \u00e0 partir de l\u2019\u00e9l\u00e9ment \\(1\\) et non \\(0\\). Donc nos tableaux auront une premi\u00e8re case qui ne servira \u00e0 rien.</p> <p>La longueur du tas est toujours susceptible d\u2019\u00e9voluer. Il faut la d\u00e9finir comme mutable.</p> <p><code>f.n+1</code> d\u00e9signe la premi\u00e8re case libre du tas <code>f.tbl</code>.</p> <pre><code>type (\u2019a, \u2019b) data = { priority : \u2019a ; value : \u2019b };; \ntype (\u2019a, \u2019b) priority_file = { mutable n : int ; tbl : (\u2019 a, \u2019b) data array };; \n</code></pre>"},{"location":"Arbres/4-ABR/#primitives-pour-la-file-de-priorite","title":"Primitives pour la file de priorit\u00e9","text":""},{"location":"Arbres/4-ABR/#creation-dune-file-de-priorite","title":"Cr\u00e9ation d'une file de priorit\u00e9","text":"<pre><code>let creer_file n (p, v) = { n = 0; tbl = Array.make (n +1) { priority = p ; value = v }};; \nlet empty_queue = creer_file 5 (1, 2);; \n</code></pre>"},{"location":"Arbres/4-ABR/#exceptions","title":"Exceptions","text":"<p>On peut ajouter des \u00e9l\u00e9ments dans la file tant qu\u2019elle n\u2019est pas pleine. Si elle est pleine, on soul\u00e8ve une exception <code>Full</code>.</p> <p>On peut retirer des \u00e9l\u00e9ments de la file tant qu\u2019elle n\u2019est pas vide. Si elle est vide, on soul\u00e8ve une exception <code>Empty</code>.</p> <p>Cr\u00e9ation des exceptions :</p> <pre><code>exception Empty  ;; \nexception Full  ;; \n</code></pre>"},{"location":"Arbres/4-ABR/#ajouter","title":"Ajouter","text":"<p>Il faut adapter la fonction de percolation haute \u00e0 nos priorit\u00e9s. En exo.</p> <pre><code>let ajouter d f = \n    if f.n+1 = Array.length f.tbl then raise Full ; \n    f.n &lt;- f.n +1; \n    f.tbl.(f.n) &lt;- d ; \n    percolate_up (f.n) f;; \n</code></pre>"},{"location":"Arbres/4-ABR/#retirer","title":"Retirer","text":"<p>Il faut adapter la fonction de percolation basse \u00e0 nos priorit\u00e9s. En exo.</p> <pre><code>let retirer f = \n    if f.n = 0 then raise Empty ; \n    f.tbl.(1) &lt;- f.tbl.(f.n); \n    f.n &lt;-(f.n) -1; \n    percolate_down 1 f;; \n</code></pre>"},{"location":"Arbres/4-ABR/#augmenter-la-priorite","title":"Augmenter la priorit\u00e9","text":"<p>Quand on augmente l\u2019urgence, donc qu\u2019on diminue la valeur de priorit\u00e9 d\u2019un \u00e9l\u00e9ment, on le fait remonter par percolation haute.</p> <pre><code>let plus_prioritaire k p f = \n    (* augmente la priorit\u00e9de l'\u00e9l\u00e9 ment k *) \n    if f.tbl.(k).priority &lt;= p then failwith \" la nouvelle priorit\u00e9 doit \u00eatre plus petite\" ; \n    f.tbl.(k) &lt;- {priority = p ; value = f.tbl.(k).value }; \n    percolate_up k f;; \n</code></pre> <p>Et quand on diminue l\u2019urgence, on fait descendre l\u2019\u00e9l\u00e9ment par percolation basse. Il peut \u00eatre utile de maintenir dans la structure un dictionnaire qui indique, pour chaque valeur, \u00e0 quelle position on peut la trouver.</p>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/","title":"Bonnes pratiques","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Un m\u00e9mo du CNRS pour \\(\\texttt{Python}\\)</li> <li>Cette page D'Emmanuel Delahaye.</li> <li>\"Informatique MP2I/MPI\" Ellipse.</li> </ul>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#code-source","title":"Code source","text":""},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#code-bien-ecrit","title":"Code bien \u00e9crit","text":"<p>Un algorithme ou code \"bien \u00e9crit\" doit avoir les propri\u00e9t\u00e9s suivantes :</p> <ul> <li>\u00catre facile \u00e0 lire, pas soi-m\u00eame mais aussi par les autres.</li> <li>Avoir une organisation logique et \u00e9vidente.</li> <li>\u00catre explicite, montrer clairement les intentions du d\u00e9veloppeur.</li> <li>\u00catre soign\u00e9 et robuste au temps qui passe.</li> </ul>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#indentation","title":"Indentation","text":"<p>En C et Ocaml, l'indentation ne fait pas sens</p> <pre><code>if (x==0)\n    printf(\"x=%d\\n\", x);\n    x++;\n</code></pre> <p>On peut croire que <code>x</code> n'est incr\u00e9ment\u00e9 que si il est nul : erreur.</p> <p>C'est au programmeur de faire un effort pour que le code montre la structure.</p> <p>On peut choisir d'aligner des \u00e9l\u00e9ments comparables pour insister sur leurs similarit\u00e9s</p> <pre><code>if ( c&gt;0 ){...}\nelse if (c&lt;0){...}\n</code></pre>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#factorisation-du-code","title":"Factorisation du code","text":"<p>Pour des raisons historiques, ne pas d\u00e9passer \\(80\\) caract\u00e8res par ligne.</p> <p>Pour des expressions longues, factoriser le travail en calculs plus petits stock\u00e9s dans des variables \u00e9l\u00e9mentaires.</p> <p>D\u00e9composer un programme en sous-fonctions \u00e9l\u00e9mentaires de quelques lignes.</p> <p>Non seulement on y gagne en lisibilit\u00e9 mais aussi en r\u00e9utilisabilit\u00e9.</p>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#choix-des-noms","title":"Choix des noms","text":"<p>Fichiers, types, fonctions, variables.</p> <ul> <li>Variables locales \u00e0 une fonction : utiliser des noms courts \u00e0 une lettre. Cette lettre n'est pas choisie au hasard (par exemple <code>t</code> pour un tableau, <code>i</code> pour un entier).</li> <li>Les noms de fonctions ont int\u00e9r\u00eat \u00e0 \u00eatre explicite : par exemple <code>int dichot(int a[], int n, int x)</code> pour une fonction qui fait une recherche dichotomique dans un tableau tri\u00e9.</li> <li>On peut utiliser des underscore si le nom de fonction contient lusieurs mots <code>bool has cycle(graphe g)</code> qui indique par un boul\u00e9en si le graphe poss\u00e8de un cycle.</li> <li>On peut pr\u00e9f\u00e9rer s\u00e9parer les mots par des majuscules : <code>bool hasCycle(graphe g)</code> (notation \u00e0-la-Java). Ocaml limite par ailleurs l'usage des majuscules en premi\u00e8re lettre.</li> </ul>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#commentaires","title":"Commentaires","text":"<p>Un commentaire doit \u00eatre une valeur ajout\u00e9e. Ne pas paraphraser le code.</p> <p>Exemple de commentaire inutile</p> <pre><code>// si x&gt;0 , incr\u00e9menter, sinon d\u00e9cr\u00e9menter\nif (x&gt;0) {x++} else {x\u2212\u2212}\n</code></pre> <p>Indiquer les entr\u00e9es-sorties</p> <pre><code>/*Entr\u00e9es : a tableau tri\u00e9 d'entiers \n            n taille de a, x valeur cherch\u00e9e */\n// Sortie : position de x\nint dichot (int a [], int n, int x)\n</code></pre> <ul> <li>Le premier commentaire est une pr\u00e9condition : il sous-entend que le code ne v\u00e9rifie pas ces hypoth\u00e8ses et peut planter en cas de non respect.</li> <li>Le second commentaire est une sp\u00e9cification : il pr\u00e9cise le comportement de la fonction</li> </ul>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#invariant-de-boucle","title":"Invariant de boucle","text":"<p>Si le programme contient une boucle, une propri\u00e9t\u00e9 maintenue \u00e0 chaque it\u00e9ration est appel\u00e9e un invariant de boucle. Il est utile de pr\u00e9ciser cet invariant pour expliquer le code et pour une future preuve de correction.</p> <p>Exemple du tri insertion</p> <pre><code>for (int i = 0; i &lt;= n\u22121; i++) // tri insertion\n    {   // Inv :a [0..i[ est tri\u00e9\n        x = T [i];\n        j = i;\n        while (j &gt; 0 &amp; T[j\u22121] &gt; x)\n            {\n                T [j] = T[j\u22121];\n                j = j\u22121;\n        }\n        T[j] = x;}\n</code></pre> <p>On peut aussi repr\u00e9senter l'invariant par un dessin comme dans l'algorithme du drapeau hollandais (classement des \u00e9l\u00e9ments d'un tableau selon trois cat\u00e9gories ordonn\u00e9es)</p> <pre><code>int b =0 , i =0 , r=n ;\nwhile ( i&lt;r ) {\n// 0 b i r n\n// +\u2212\u2212\u2212\u2212+\u2212\u2212\u2212\u2212+\u2212\u2212\u2212\u2212+\u2212\u2212\u2212\u2212+\n// a | 0 | 1 | ? ? | 2 |\n// +\u2212\u2212\u2212\u2212+\u2212\u2212\u2212\u2212+\u2212\u2212\u2212\u2212+\u2212\u2212\u2212\u2212+\n}\n</code></pre> <p>On comprends que \u00e0 chaque tour <code>a[0..b[</code> ne contient que la valeur \\(0\\), <code>a[b..i[</code> ne contient que la valeur \\(1\\) etc..</p>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#a-propos-des-intervalles","title":"A propos des intervalles","text":"<p>Pour repr\u00e9senter un intervalle (dans un tableau, une cha\u00eene etc.) on peut utiliser syst\u00e9matiquement un indice gauche inclus et un indice droit exclu (comme le <code>range</code> de Python)</p> <p>Par exemple, on peut introduire une fonction</p> <pre><code>void f ( int a [ ] , int g , int d )\n</code></pre> <p>Pour travailler sur les indices dans \\([\\![g, d \u22121]\\!]\\) avec l'hypoth\u00e8se \\(0 \u2264g \u2264d \u2264|a|\\).</p> <p>Dans ce cas :</p> <ul> <li>le nombre d'\u00e9l\u00e9ments concern\u00e9s est \\(d\u2212g\\)</li> <li>Si on doit couper cet intervalle en deux ce sera avec \\([\\![g, m]\\!]\\) et \\([\\![d, m]\\!]\\) pour un \\(g \u2264m \u2264d\\)</li> <li>le tableau tout entier correspond \\(g = 0\\), \\(d = |a|\\).</li> </ul> <p>Nous respectons cette convention le plus possible.</p>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#invariant-de-structure","title":"Invariant de structure","text":"<p>Un invariant de structure d\u00e9crit une propri\u00e9t\u00e9 toujours vraies pour les valeurs d'une structure de donn\u00e9es.</p> <p>Il est utile de pr\u00e9ciser cet invariant (m\u00eame incompl\u00e8tement) au niveau de la d\u00e9finition du type</p> <pre><code>struct ArrStack{\n    int capacity ;\n    int size ; // 0 &lt;= size &lt;= capacity\n    int * data ; // tableau de taille capacity\n}\n</code></pre>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#compilation","title":"Compilation","text":""},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#compiler-aide-a-trouver-les-erreurs","title":"Compiler aide \u00e0 trouver les erreurs","text":"<p>On d\u00e9tecte les erreurs de syntaxe :</p> <pre><code>asup.c:9:1: error: expected declaration or statement at end of input\n}\n</code></pre> <p>ou encore celles de typage</p> <pre><code>asup.c:9:5: error: too many arguments to function 'f'\n</code></pre> <p>En cas d'erreur, aucun ex\u00e9cutable n'est produit.</p> <p>Le cycle de travail consiste en de \\(\\underline{\\text{fr\u00e9quents}}\\) aller-retours entre l'\u00e9dition du fichier source et la compilation.</p> <p>Compiler souvent ! La compilation n'est pas n\u00e9cessairement chronophage avec un bon Makefile (cf plus tard)</p>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#avertissements","title":"Avertissements","text":"<p>Si le compilateur \u00e9met un avertissement plut\u00f4t qu'une erreur, il va poursuivre jusqu'\u00e0 la production de l'ex\u00e9cutable.</p> <p>Un avertssement peut \u00eatre n\u00e9glig\u00e9 en premi\u00e8re approche mais il devra \u00eatre r\u00e9solu avant le rendu du projet final.</p> <p>Voici un exemple o\u00f9 le compilateur rep\u00e8re une variable non utilis\u00e9e. Ce n'est pas propre !</p> <pre><code>asup.c:8:7: warning: unused variable 'x' [-Wunused -variable]\n</code></pre> <p>Utiliser l'option <code>-Wall</code> !</p>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#compiler-des-programmes-incomplets","title":"Compiler des programmes incomplets","text":"<p>On peut n'avoir \u00e9crit que certaines fonctions du programme, et on peut tr\u00e8s bien les compiler avec l'option <code>-c</code> qui produit un fichier objet sans \u00e9dition de lien.</p> <p>Avec le m\u00e9canisme de l'arr\u00eat pr\u00e9matur\u00e9 (<code>abort()</code> en C), des assertions (<code>assert</code> en C et Ocaml) ou des exceptions (<code>failwith</code> en OCaml), on peut ne compiler que des morceaux de codes qui ne sont que partiellement \u00e9crits :</p> <pre><code>if (n &gt; 100)\n    n = n\u221210 ;\nelse {\n// TODO : je verrai plus tard\nabort () ; // quitter le programme pr\u00e9matur\u00e9ment\n}\n</code></pre>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#utiliser-des-prototypes","title":"Utiliser des prototypes","text":"<p>En C, l'\u00e9criture du prototype d'une fonction <code>f</code> permet d'appeler <code>f</code> avant d'avoir \u00e9crit son code.</p> <p>Dans cet exemple, f n'a pas encore de corps. Mais la compilation avec <code>gcc -c</code> permet de se rendre compte que dans le corps de main , on appelle f avec trop d'arguments :</p> <pre><code>#include &lt;stdio.h&gt;\n\nint f (int x); // f sera explicit\u00e9e plus tard\n\nint main (void)\n{\n    f(2, 3);\n    return 0;\n}\n</code></pre>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#execution","title":"Ex\u00e9cution","text":""},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#le-compilateur-ne-detecte-pas-tout","title":"Le compilateur ne d\u00e9tecte pas tout","text":"<p>Un th\u00e9or\u00e8me c\u00e9l\u00e8bre (th. de Rice) a pour cons\u00e9quence qu'aucun compilateur ne peut pr\u00e9voir toutes les erreurs possibles.</p> <p>Par exemple un compilateur ne peut pas garantir dans tous les cas qu'on ne divisera jamais par \\(0\\), qu'on n'acc\u00e8dera jamais \u00e0 un tableau en dehors de ces bornes ou qu'on ne tombera jamais dans une boucle infinie.</p> <p>Les raisons pour lesquelles un programme plante sont incompl\u00e8tement indiqu\u00e9e \u00e0 l'ex\u00e9cution. Mais cette information lacunaire est quand m\u00eame utile.</p> <p>Avec un debugger on peut aller plus loin dans la recherche du bug.</p>"},{"location":"Bonnes%20Pratiques/1-Bonne_pratiques/#erreur-de-segmentation","title":"Erreur de segmentation","text":"<p>L'erreur de segmentation est un plantage d'une application qui a tent\u00e9 d'\u00e9crire dans une zone m\u00e9moire qui ne lui \u00e9tait pas allou\u00e9e.</p> <p>Dans cet exemple le pointeur <code>variable_entiere</code> n'est pas initialis\u00e9 et contient donc une valeur quelconque qui a de forte chance d'\u00eatre une zone m\u00e9moire interdite en \u00e9criture.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main (void)\n{\n    int* variable_entiere;\n    scanf(\"%d\", variable_entiere);\n    return EXIT SUCCESS ;\n}\n</code></pre> <p>Apr\u00e8s compilation et ex\u00e9cution</p> <pre><code>$./a.out\n2\nErreur de segmentation (core dumped)\n</code></pre> <p>A noter que l'option <code>-Wall</code> d\u00e9tecte que le pointeur n'est pas initialis\u00e9.</p> <p>En travaux.</p>"},{"location":"C/01-MinimC/","title":"C si facile","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>\u00c0 propos</p> <p>Ces transparents r\u00e9sument en quelques lignes de code le minimum \u00e0 conna\u00eetre pour s'en sortir en C dans les TD de d\u00e9but d'ann\u00e9e.</p> <p>Bien qu'il existe souvent plusieurs syntaxes \u00e9quivalentes pour une m\u00eame instruction, on se limite \u00e0 une seule.</p> Th\u00e8mes abord\u00e9s <ul> <li>Variables : d\u00e9claration, affectation, affichage, saisie au clavier</li> <li>Compilation de projet en un fichier, ex\u00e9cution</li> <li>Op\u00e9rateurs arithm\u00e9tiques et boul\u00e9ens</li> <li>Expressions conditionnelles</li> <li>Boucle while</li> <li>D\u00e9clarations et appels de fonctions simples.</li> <li>D\u00e9claration de tableaux statiques \u00e0 une dimension.</li> <li>Assertions</li> </ul> <p></p> <p>\u00ab \\(\\texttt{GCC}\\) \u00bb</p>"},{"location":"C/01-MinimC/#squelette","title":"Squelette","text":"<pre><code>#include &lt;stdio.h&gt;// charger bibli. d'entr\u00e9es\u2212sorties\nint main(void){   \n    /* \n        votre code ici \n    */\n    return 0; // on renvoie un entier (car 'int main')\n}\n</code></pre> <ul> <li>Commentaires en une ligne <code>// mon commentaire</code> . ET Commentaires sur plusieurs lignes <code>/* mes commentaires */</code></li> <li>La fonction <code>main</code> renvoie un entier (en g\u00e9n\u00e9ral). Cet entier est \\(0\\) par d\u00e9faut (tout s'est bien pass\u00e9). Autres valeurs renvoy\u00e9es : code pour signaler un probl\u00e8me. </li> <li>Une et une seule fonction main par programme (en cas de code sur plusieurs fichiers, un seul contient un main).</li> </ul>"},{"location":"C/01-MinimC/#declaration-initialisation","title":"D\u00e9claration, initialisation","text":"<p>Ouvrir un \u00e9diteur de texte comme emacs ou gedit (Linux) ou blocnote (Windows) \\(\\underline{\\text{MAIS PAS UN TRAITEMENT DE TEXTE}}\\).</p> <pre><code>// dans un fichier exemple.c\n#include stdio.h&gt;// entr\u00e9es\u2212sorties\n\nint main (void){\nint i; // i d\u00e9clar\u00e9 mais de valeur non connue (d\u00e9conseill\u00e9)\nfloat x = 15.3; // d\u00e9claration et initialisation en 1 ligne\ni = 10; // i a maintenant une valeur\nx = 3.6; // changer la valeur de x\nreturn 0;\n}\n</code></pre> <ul> <li>On d\u00e9clare une variable en d\u00e9clarant d'abord le type puis le nom. Point-virgule <code>;</code> \u00e0 la fin de chaque instruction.</li> <li>On peut initialiser imm\u00e9diatement (cf <code>x</code> ) ou attendre un peu (cf <code>i</code>).</li> </ul>"},{"location":"C/01-MinimC/#compilation","title":"Compilation","text":"<p>Ouvrir un terminal :</p> <ul> <li>\u2665 Compilation avec affichage des warning (mises en garde) (option <code>-Wall</code>): <code>gcc -Wall exemple.c</code> Fichier ex\u00e9cutable produit : <code>a.out</code> (nom par d\u00e9faut)</li> <li>\u2665 Si on veut fixer le nom du fichier produit : <code>gcc -Wall initialiser.c -o toto</code></li> <li>Ex\u00e9cution.</li> </ul> <pre><code>$./toto\n</code></pre> <ul> <li>R\u00e9cup\u00e9rer la valeur renvoy\u00e9e par le main :</li> </ul> <pre><code>$echo $?\n0\n</code></pre> <p>Cette commande r\u00e9cup\u00e8re en fait le retour de la derni\u00e8re commande pass\u00e9e dans le terminal.</p> <p>Exercice</p> <p>\u00c9crire un code qui soul\u00e8ve une erreur (d'ex\u00e9cution, pas de compilation) avant le <code>return 0</code> du main. Compiler, ex\u00e9cuter et r\u00e9cup\u00e9rer la valeur renvoy\u00e9e par le programme. Vaut-elle z\u00e9ro ?</p>"},{"location":"C/01-MinimC/#types-de-base","title":"Types de base","text":"<ul> <li>Il y a trois familles de types de base : caract\u00e8res, entiers et flottants.</li> <li>Chaque famille regroupe plusieurs types qui diff\u00e9rent par leurs tailles et leurs aspects sign\u00e9s ou non sign\u00e9s.</li> <li>La liste des tailles donn\u00e9es ci-dessous est non exhaustive :<ul> <li>Entiers. Plusieurs tailles diff\u00e9rente. On se contente ici de <code>int</code> (sign\u00e9s) et <code>unsigned int</code> (non sign\u00e9s, au comportement cyclique). Au moins \\(2\\) octets (\\(16\\) bits) tr\u00e8s souvent sur \\(4\\). Pour de gros entiers, pr\u00e9ferer <code>long</code> et <code>unsigned long</code>. Taille au moins \\(4\\) octets souvent sur \\(8\\).</li> <li>Caract\u00e8res. <code>char</code> . C'est la plus petite unit\u00e9 adressable de la machine. Souvent sur un octet. La taille des autres types en est un multiple.</li> <li>Flottants : <code>float</code> (en g\u00e9n\u00e9ral \\(4\\) octets) et <code>double</code> (en g\u00e9n\u00e9ral \\(8\\) octet) et leurs versions non sign\u00e9es.</li> </ul> </li> <li>La taille des types d\u00e9pend de la machine et de l'impl\u00e9mentation. Les bonnes infos sont dans les fichiers limits.h et float.h</li> </ul>"},{"location":"C/01-MinimC/#tableaux-chaines-de-caracteres","title":"Tableaux, cha\u00eenes de caract\u00e8res","text":"<ul> <li>Dans ce document, nous abordons bri\u00e8vement la notion de tableau statique. Nous ne parlons pas des tableaux dynamiques (ou VLA) conform\u00e9ment \u00e0 l'usage en MP2I.</li> <li>Il n'y a pas de type cha\u00eene de caract\u00e8res comme le <code>string</code> de Python. Les cha\u00eenes de caract\u00e8res sont repr\u00e9sent\u00e9es<ul> <li>soit par le type <code>char *</code> ou constantes cha\u00eenes : pointeur sur un caract\u00e8re, en g\u00e9n\u00e9ral le contenu est non modifiable.</li> <li>Soit par le type <code>char[]</code> ou tableau de caract\u00e8res. Contenu modifiable.</li> </ul> </li> </ul>"},{"location":"C/01-MinimC/#types-structures","title":"Types structur\u00e9s","text":"<p>D\u00e9finis plus tard</p> <p>(cf cours Structures)</p>"},{"location":"C/01-MinimC/#affichage","title":"Affichage","text":"<pre><code>// fichier hello.c\n#include &lt;stdio.h&gt;// charger les entr\u00e9es\u2212sorties\n\nint main(void){\n    int i = 10;\n    printf(\"i=%d\\n\", i); // affichage d'un entier  %d\n    printf(\"%f\\n\", 3.14); // afficher un flottant %f\n    printf(\"coucou\\n\"); // afficher directement une cha\u00eene\n    char* salut = \"hello\"; // une constante cha\u00eene\n    printf(\"%s\\n\", salut); // afficher une cha\u00eene %s\n    return 0;\n}\n</code></pre> <p>Exemple d'appel d'affichages avec les diff\u00e9rents sp\u00e9cifieurs de formats : <code>%d,%f,%s</code> qui indiquent la nature de l'objet \u00e0 afficher.</p> <p>\u2665 Ne pas oublier de charger la biblioth\u00e8ques d'entr\u00e9es-sorties <code>&lt;stdio.h&gt;</code>.</p> <p><code>\\n</code> pour passer \u00e0 la ligne dans l'affichage.</p> <p>Et toujours le <code>return 0</code> du main.</p>"},{"location":"C/01-MinimC/#compilation-puis-execution","title":"Compilation puis ex\u00e9cution","text":"<p>Dans un terminal, entrer</p> <pre><code>$gcc \u2212Wall hello.c \u2212o hello # compilation\n$./hello # ex\u00e9cution\ni=10\n3.140000\ncoucou\nhello\n</code></pre> <ul> <li>On ex\u00e9cute le programme produit en tapant <code>./hello</code></li> <li>Noter les commentaires en bash : <code># un commentaire</code></li> </ul>"},{"location":"C/01-MinimC/#tableau-de-specificateurs-de-formats","title":"Tableau de sp\u00e9cificateurs de formats","text":"Symbole Type Impression comme %d ou %i int entier relatif %u uint entier naturel non sign\u00e9 %o int entier exprim\u00e9 en octal %x int entier exprim\u00e9 en h\u00e9xad\u00e9cimal %c char caract\u00e8re %s char et char t[] cha\u00eene de caract\u00e8res %f double flottants et doubles en notation d\u00e9cimale %e double flottant en notation scientifique %p adresses <p>A conna\u00eetre <code>%d %f %s %p</code> \u2665.</p>"},{"location":"C/01-MinimC/#saisie","title":"Saisie","text":"<pre><code>#include &lt;stdio.h&gt;// charger les entr\u00e9es\u2212sorties\n\nint main(void){\n    int i, j; // d\u00e9claration de deux entiers\n    printf(\"saisir la valeur de i\");\n    scanf(\"%d\", &amp;i);\n    printf(\"saisir la valeur de j\");\n    scanf(\"%d\", &amp;j);\n    printf(\"vous avez saisi %d et %d\\n\", i, j);\n    return 0; \n}\n</code></pre> <p><code>scanf</code> prend au minimum deux param\u00e8tres : un sp\u00e9cifieur de format (<code>%d,%f,%s</code>... ) et une adresse (celle de la variable qu'on veut renseigner). \u2665</p> <p>La saisie de cha\u00eenes de caract\u00e8res doit se faire avec prudence</p>"},{"location":"C/01-MinimC/#saisie-de-chaines-de-caracteres","title":"Saisie de cha\u00eenes de caract\u00e8res","text":"<pre><code>int main(void){\n    char s[10];\n    printf(\"saisir votre nom\\n\");\n    scanf(\"%s\", s);\n    printf(\"Bonjour %s\\n\", s);\n    return 0;\n}\n</code></pre> <p>Pour les cha\u00eenes de caract\u00e8res, tout s\u00e9parateur (comme un espace) interrompt la lecture. On peut pr\u00e9ciser qu'on veut ou ne veut pas certains caract\u00e8res.</p>"},{"location":"C/01-MinimC/#5-operateurs-sans-surprise","title":"5 op\u00e9rateurs sans surprise \u2665","text":"<p>Les op\u00e9rateurs arithm\u00e9tiques ne devraient pas surprendre les utilisateurs de \\(\\texttt{Python}\\) :</p> <ul> <li>l'addition <code>+</code></li> <li>la soustraction <code>-</code></li> <li>la multiplication <code>*</code></li> <li>la division <code>/</code> (euclidienne ou flottante)</li> <li>le modulo <code>%</code> .</li> <li>Pas d'op\u00e9rateur d'exponentiation.</li> </ul>"},{"location":"C/01-MinimC/#pas-de-type-bouleen-importe-par-defaut","title":"Pas de type boul\u00e9en import\u00e9 par d\u00e9faut","text":"<ul> <li>En \\(\\texttt{C}\\), il n'existe pas de type boul\u00e9en import\u00e9 par d\u00e9faut.</li> <li>\u00c0 la place, la valeur \\(0\\) repr\u00e9sente le boul\u00e9en <code>false</code> et toute autre valeur, <code>true</code> .</li> <li>Or, ce n'est pas l'esprit du programme d'info en CPGE. Une bonne fa\u00e7on de mettre des boul\u00e9ens dans un programme \\(\\texttt{C}\\) est alors d'importer la biblioth\u00e8que <code>#include &lt;stdbool.h&gt;</code>. \u2665</li> </ul>"},{"location":"C/01-MinimC/#operateurs-bouleens","title":"Op\u00e9rateurs boul\u00e9ens \u2665","text":"<p>Les voici :</p> Symbole Signification <code>&amp;&amp;</code> ET <code>\\|\\|</code> OU <code>!</code> NON <pre><code>#include &lt;stdio.h&gt;// charger les entr\u00e9es\u2212sorties\n#include &lt;stdbool.h&gt;// boul\u00e9ens\n\nint main(void){\n    bool b = 1==1;\n    bool c = !b;\n    printf(\"b est %d,c est %d\\n\", b, c);\n    return 0;\n}\n</code></pre> <p>Apr\u00e8s compilation puis ex\u00e9cution :</p> Rendu<pre><code>b est 1, c est 0\n</code></pre>"},{"location":"C/01-MinimC/#operateurs-bit-a-bit","title":"Op\u00e9rateurs bit-\u00e0-bit","text":"<p>Pour information</p> <ul> <li>Op\u00e9rateurs de comparaison bit-\u00e0-bit <code>&amp;, |, \u2227</code> (\\(\\texttt{ET}\\) bit-\u00e0-bit, \\(\\texttt{OU}\\) bit-\u00e0-bit, \\(\\texttt{XOR}\\) bit-\u00e0-bit)</li> <li>Et \u00e9galement des op\u00e9rateurs de d\u00e9calage <code>&gt;&gt;, &lt;&lt;</code>: division/multiplication par une puissance de \\(2\\).</li> </ul>"},{"location":"C/01-MinimC/#les-comparateurs","title":"Les comparateurs \u2665","text":"<p>On donne le tableau suivant d\u00e9j\u00e0 connu des utilisateurs de \\(\\texttt{Python}\\) :</p> Symbole Signification == est \u00e9gal \u00e0 &gt; est strictement sup\u00e9rieur \u00e0 &lt; est strictement inf\u00e9rieur \u00e0 &gt;= est sup\u00e9rieur ou \u00e9gal \u00e0 &lt;= est inf\u00e9rieur ou \u00e9gal \u00e0 != est diff\u00e9rent de <p>Comme en \\(\\texttt{Python}\\), le symbole <code>=</code> n'est pas un op\u00e9rateur de comparaison mais d'affectation.</p>"},{"location":"C/01-MinimC/#expression-conditionnelle","title":"Expression conditionnelle","text":"<pre><code>if(condition r\u00e9alis\u00e9e){\n    liste instructions\n}\nelse{\n    autre s\u00e9rie instructions\n}\n</code></pre> <ul> <li>La condition est indiqu\u00e9e entre parenth\u00e8se</li> <li>Les blocs sont \u00e9crits entre accolades.</li> <li>L'indentation ne fait pas sens en \\(\\texttt{C}\\) contrairement \u00e0 \\(\\texttt{Python}\\)</li> </ul>"},{"location":"C/01-MinimC/#si-alors-sinon","title":"Si alors sinon \u2665","text":"<p>D\u00e9tection et affichage de la parit\u00e9 d'un entier saisi</p> <pre><code>// parit\u00e9 d'un entier\nint n;\nprintf(\"entrer un nombre entier : \");\nscanf(\"%i\", &amp;n);\nif(n%2==0){\n    printf(\"votre nombre est pair  \\n\");\n}\nelse{\n    printf(\"votre nombre est impair \\n\");\n}\n</code></pre>"},{"location":"C/01-MinimC/#sinon-si","title":"Sinon si \u2665","text":"<p>Le <code>elif</code> de \\(\\texttt{Python}\\) s'\u00e9crit <code>else if</code> en \\(\\texttt{Python}\\) et se place entre <code>if</code> et <code>else</code> :</p> <p>Nombre de racines d'un trin\u00f4me de degr\u00e9 \\(2\\)</p> <pre><code>// Indication du nombre de racines d'un trin\u00f4me du 2nd degr\u00e9\n\ndouble delta;\nprintf( \"entrer la valeur du discriminant : \");\nscanf(\"%lf\", &amp;delta);\nif (delta == 0){\n    printf(\"une racine double \\n \");\n}\nelse if (delta &gt; 0){\n    printf(\"deux racines r\u00e9elles \\n\");\n}\nelse{\n    printf(\"pas de racine r\u00e9elle \\n\");\n}\n</code></pre>"},{"location":"C/01-MinimC/#boucle-while","title":"Boucle <code>while</code> \u2665","text":"Syntaxe<pre><code>while(Condition){\n    // Instructions \u00e0 r\u00e9p\u00e9ter\n}\n</code></pre> afficher les carr\u00e9s des chiffres de 0 \u00e0 9<pre><code>int cpt = 0; // compteur\nwhile(cpt &lt; 10){\n    printf(\"%d\\n\", cpt*cpt);\n    cpt = cpt+1;\n}\n</code></pre>"},{"location":"C/01-MinimC/#attention-aux-boucles-infinies","title":"Attention aux boucles infinies","text":"<pre><code>int cpt = 0; // compteur\nwhile(cpt &lt; 10){\n    printf(\"%d\\n\", cpt*cpt);\n}\n</code></pre> <p>Pour arr\u00eater : <code>CTRL + C</code></p> <p>Voici une boucle qui demande d'entrer un nombre jusqu'\u00e0 ce que l'utilisateur saisisse \\(10\\) :</p> <pre><code>int nb = 0;\n// condition entre parenth\u00e8ses\nwhile(nb != 10){\n    printf(\"entrer un nb entier : \");\n    scanf(\"%d\", &amp;nb);\n}\n</code></pre> <p>Le programme entre au moins une fois dans la boucle. Voici une trace d'ex\u00e9cution :</p> Rendu<pre><code>entrer un nb entier :12\nentrer un nb entier :10\n</code></pre>"},{"location":"C/01-MinimC/#programmation-modulaire","title":"Programmation modulaire","text":"<ul> <li>Un gros programme peut et doit \u00eatre d\u00e9coup\u00e9 en plusieurs modules (sous-parties du programme).</li> <li>Cela permet :<ul> <li>d'am\u00e9liorer la lisibilit\u00e9 (en gros : une id\u00e9e = \\(1\\) module)</li> <li>d'\u00e9viter les s\u00e9quences d'instructions r\u00e9p\u00e9titives, et cela d'autant plus facilement que la notion d'arguments permet de param\u00e9trer certains modules.</li> <li>le partage d'outils communs qu'il suffit d'avoir \u00e9crits et mis au poin une seule fois. La compilation s\u00e9par\u00e9e est ici bien pratique pour ne compiler qu'une partie du programme ind\u00e9pendamment des autres.</li> </ul> </li> </ul>"},{"location":"C/01-MinimC/#programmation-modulaire-en-textttc","title":"Programmation modulaire en \\(\\texttt{C}\\)","text":""},{"location":"C/01-MinimC/#fonctions-et-procedures","title":"Fonctions et proc\u00e9dures","text":"<ul> <li>Il n'existe qu'un seul type de module en \\(\\texttt{C}\\) : les fonctions et proc\u00e9dures</li> <li>Les arguments sont transmis par valeur en \\(\\texttt{C}\\) aux fonctions.</li> <li>Il semble donc impossible de modifier un argument transmis mais en r\u00e9alit\u00e9 certaines valeurs (pointeurs et tableaux) sont en fait des adresses : cela fournit un moyen d\u00e9tourn\u00e9 de modifier l'agument transmis.</li> <li>La compilation s\u00e9par\u00e9e se fait par fichier source (alors qu'en Fortran par exemple, elle se fait par module).</li> </ul>"},{"location":"C/01-MinimC/#declaration-de-fonction","title":"D\u00e9claration de fonction \u2665","text":"<pre><code>type_de_retour nomFonction(parametres){\n    /*corps de la fonction :\n    Ins\u00e9rez vos instructions ici */\n}\n</code></pre> <ul> <li>Avant le nom de la fonction, on indique son type de retour (comme <code>int</code> , <code>bool</code> , <code>float</code> , <code>char*</code>, ...)</li> <li>Le nom de chaque param\u00e8tre est pr\u00e9c\u00e9d\u00e9 de son type.</li> <li>Le corps de la fonction est entre accolades.</li> <li>La partie avant l'accolade est appel\u00e9e prototype de la fonction</li> </ul> <pre><code>int triple(int nombre){// ex avec un param\u00e8tre\n    return 3*nombre; \n}\n\nvoid salut(){\n    printf(\"coucou \\n \");\n}\n\nint mult(int i, int j){// ex avec 2 param\u00e8tres\n    return i*j;\n}\n</code></pre> <ul> <li>Le mot <code>return</code> est obligatoire si la valeur de retour n'est pas <code>void</code> . La valeur retourn\u00e9e doit \u00eatre conforme au type annonc\u00e9.</li> <li>Si la fonction ne retourne rien, on dit que c'est une proc\u00e9dure. Dans ce cas, le type de retour est <code>void</code>.</li> </ul>"},{"location":"C/01-MinimC/#appel-de-fonction","title":"Appel de fonction","text":"<pre><code>// fichier appel.c\nint main(void){\n    int i = 3;\n    // 2 sp\u00e9cifieurs %d :\n    printf(\"triple(%d) = %d\\n\", i, triple(i));\n    salut();\n    return 0;\n}\n</code></pre> <ul> <li>Le prototype de la fonction doit \u00eatre plac\u00e9 avant son premier appel. Mais il est possible d'\u00e9crire le corps de la fonction apr\u00e8s un ou plusieurs appels (cf plus tard). Les prototypes de <code>triple</code> et <code>salut</code> sont plac\u00e9s avant la fonction <code>main</code> qui peut ainsi appeler ces fonctions.</li> </ul>"},{"location":"C/01-MinimC/#le-mot-cle-void","title":"Le mot cl\u00e9 <code>void</code>","text":"<ul> <li><code>void</code> n'est pas un type, c'est un mot cl\u00e9.</li> <li>On l'utilise pour d\u00e9clarer qu'une fonction ne renvoie pas de valeur : <code>void f(int x)</code></li> <li>Pour les fonctions sans argument, pr\u00e9f\u00e9rer <code>int f(void)</code> , (qui signifie explicitement que <code>f</code> ne prend pas d'argument) \u00e0 <code>int f()</code> (qui indique que le nombre d'arguments de <code>f</code> n'est pas connu).</li> <li>Enfin, si <code>void</code> n'est pas un type, <code>void*</code> d\u00e9signe un pointeur vers une valeur dont on ne conna\u00eet pas le type. Les r\u00e8gles de typage de \\(\\texttt{C}\\) permettent d'utiliser une valeur de type <code>void*</code> l\u00e0 o\u00f9 une valeur d'un certain type de pointeur est attendu : <code>int *x = malloc(sizeof(int))</code> (malloc renvoie un <code>void*</code> ).</li> <li>(PI) Enfin <code>void *</code> permet le polymorphisme. Exemple : une fonction qui agit sur un tableau dont les \u00e9l\u00e9ments sont de type quelconque. Nous n'utilisons pas cette fonctionnalit\u00e9.</li> </ul>"},{"location":"C/01-MinimC/#tableaux-statiques-a-une-dimension","title":"Tableaux statiques \u00e0 une dimension","text":"<ul> <li>La taille des tableaux statiques est connue \u00e0 la compilation.</li> <li>D\u00e9claration sous la forme <code>type nom [taille]</code> dans lequel <code>taille</code> est un nombre (pas une variable, sinon c'est un tableau \u00e0 longueur variable appel\u00e9 Variable Length Array (VLA)</li> </ul> <pre><code>int t [3]; // d\u00e9claration  d'un tableau de 3 entiers.\n</code></pre> <ul> <li>Pas de VLA en MP2I/MPI !!</li> </ul> <pre><code>gcc \u2212Wall \u2212Werror=vla myfile.c # interdire VLA\n</code></pre> <ul> <li>Les cases d'un tableau de taille \\(N\\) sont indic\u00e9es de \\(0\\) \u00e0 \\(N \u22121\\). Acc\u00e8s \u00e0 la \\(i\\)-\u00e8me case : <code>t[i]</code>.</li> <li>Contrairement \u00e0 \\(\\texttt{Python}\\) il n'y a pas de fonction <code>len</code> qui donne la longueur du tableau. C'est au programmeur de retenir la taille de son tableau (voir chapitre sur les Bytes).</li> </ul>"},{"location":"C/01-MinimC/#ecrire-dans-un-tableau","title":"Ecrire dans un tableau","text":"<pre><code>int t[2]; // t1 a deux \u00e9l\u00e9ments\nt [0] = 6; t[1] = 2; // \u00e9crire dans t1\n\nint t3 [] = {1, 2, 3}// correct : t3 prend une taille de 3\n\n// La derni\u00e8re case t2[2] est initialis\u00e9e \u00e0 0 :\nint t2 [3] = {2, 6};\nt2 = {8, 9, 10} // soul\u00e8ve une erreur de compilation!\n</code></pre> <p>Un tableau n'est pas une \\(\\color{red}\\text{lvalue}\\) ! ! \u2665</p>"},{"location":"C/01-MinimC/#remplir-puis-parcourir-un-tableau","title":"Remplir puis parcourir un tableau \u2665","text":"<pre><code>int main(void){\n    int i = 0; // compteur\n    int t[5]; // tableau de 5 entiers\n    while(i &lt; 5) {// remplir\n        t[i] = 2*i; // mettre 2i dans la case i\n        i = i + 1;\n    }\n    i = 0; // remise \u00e0 z\u00e9ro du compteur\n    while(i &lt; 5) {// afficher\n        printf(\"%d, \", t[i]); i = i +1;\n    }\n    printf(\"\\n\");\n    return 0; \n}\n</code></pre> <p>Apr\u00e8s compilation et ex\u00e9cution :</p> Rendu<pre><code>$gcc \u2212Wall tab.c\n$./a.out\n0,2,4,6,8,\n</code></pre>"},{"location":"C/01-MinimC/#initialisation-de-tableau","title":"Initialisation de tableau","text":"<ul> <li>Avec <code>int t[5]</code> on d\u00e9clare un tableu de \\(5\\) entiers. Ce qui est dedans est impossible \u00e0 pr\u00e9voir.</li> <li>Pour d\u00e9clarer le contenu d'un tableau \u00e0 sa cr\u00e9ation, on peut utiliser une syntaxe \u00e9num\u00e9rative</li> </ul> <pre><code>int t[5] = {1, 5, 45, 3, 9};\n</code></pre> <ul> <li>Si on \u00e9crit <code>int t[5]={10,20}</code> , les \u00e9l\u00e9ments \\(2\\),\\(3\\),\\(4\\) sont mis par d\u00e9faut \u00e0 \\(0\\).</li> </ul> <p>Danger</p> <pre><code>int tableau[1]; // d\u00e9clare un tableau d'un entier\ntableau[10] = 5; // l'\u00e9l\u00e9ment 10 n'existe pas\nprintf(\"%d\\n\", tableau[10]);\n</code></pre> <ul> <li>Ce programme peut parfois compiler (le compilateur peut ne pas d\u00e9tecter le d\u00e9passement de capacit\u00e9) et m\u00eame s'ex\u00e9cuter.</li> <li>Ce que fait alors le processus n'est pas pr\u00e9vu par la norme (comportement ind\u00e9fini). Il peut afficher \\(5\\), s'arr\u00eater en signalant une erreur, ou, plus grave, corrompre une autre partie de la m\u00e9moire du processus, rendant tr\u00e8s difficile \u00e0 pr\u00e9voir son comportement.</li> <li>Faire tr\u00e8s attention aux d\u00e9passements de capacit\u00e9 !</li> </ul>"},{"location":"C/01-MinimC/#passer-un-tableau-en-parametre","title":"Passer un tableau en param\u00e8tre","text":"<p>En \\(\\texttt{C}\\), lorsqu'on passe un tableau en argument d'une fonction, il est prudent de fournir sa taille. Ce n'est pas obligatoire mais cela permet d'\u00e9viter d'\u00e9crire o\u00f9 il ne faut pas.</p> <pre><code>void affiche(int t[], int nb_elmts) {\n    // afficher contenu de t\n    int i = 0;\n    while(i &lt; nb_elmts){\n        printf(\"t[%d]=%d\\n\", i, t[i]);\n        i = i+1;\n    }\n    printf(\"\\n\");\n}\n\nvoid modifier(int t [], int p, int x){\n    // modifier contenu de t en position p\n    t [p] = x;\n}\n</code></pre> <p>Exemple d'appel</p> <pre><code>int main(void){\n    int t[5] = {10, 21, \u221223};\n    affiche(t, 3);\n\n    printf(\"modifions t [1] en 100\\n\");\n    modifier(t, 1, 100);\n    affiche(t, 3);\n\n    return 0;\n}\n</code></pre> <p>Exemple d'ex\u00e9cution</p> Rendu<pre><code>Apr\u00e8s compilation/ex\u00e9cution\nt[0]=10 t[1]=21 t[2]=\u221223\nmodifions t[1] en 100\nt[0]=10 t[1]=100 t[2]=\u221223\n</code></pre>"},{"location":"C/01-MinimC/#assertions","title":"Assertions","text":"<p>Pour diverses raisons on peut souhaiter interrompre un programme si une condition n'est pas r\u00e9alis\u00e9e (ex : impossibilit\u00e9 d'allouer de la m\u00e9moire). Les assertions sont alors utiles.</p> <pre><code>#include &lt;assert.h&gt;// Ent\u00eate pour utiliser une assertion\n\nint main(void){\n    int i = 0; // on veut imposer i &gt; 1\n    assert(i &gt; 1); // si i &lt;= 1 : arr\u00eat du pgm\n    printf(\"Le programme peut se poursuivre  normalement\");\n    return 0;\n}\n</code></pre> <ul> <li>Trace d'ex\u00e9cution :</li> </ul> Rendu<pre><code>a.out: assertion2.c:8: main: Assertion \u2018i &gt;1' failed.\nAbandon (core dumped}\n</code></pre>"},{"location":"C/02-ChaineCompil/","title":"Cha\u00eene de compilation","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Un cours de Christophe Rippert \u00e0 l'ENSIMAG</li> <li>Un tuto sur KOOR.fr</li> </ul> <p>Avertissment</p> <p>Nous utilisons toujours le langage \\(\\texttt{C}\\) tel que d\u00e9fini dans la norme \u00ab C99 \u00bb .</p> <p>Historique</p> <ul> <li>\\(\\texttt{C}\\) : langage de programmation imp\u00e9ratif g\u00e9n\u00e9raliste, de bas niveau (il g\u00e8re les \u00e9changes \\(\\texttt{RAM}\\)/processeur). Mais pas de tr\u00e8s bas niveau sinon il g\u00e9rerait aussi ce qui se passe dans le processeur. Toujours tr\u00e8s utilis\u00e9.</li> <li>Cr\u00e9ation d\u00e9but des ann\u00e9es \\(70\\) pour r\u00e9\u00e9crire \\(\\texttt{UNIX}\\)</li> <li>A inspir\u00e9 de nombreux langages plus modernes comme \\(\\texttt{C++}\\), \\(\\texttt{C\\#}\\), \\(\\texttt{Java}\\) et \\(\\texttt{PHP}\\) ou \\(\\texttt{Javascript}\\).</li> <li>Utilis\u00e9 par exemple pour r\u00e9aliser les bases (compilateurs, interpr\u00e9teurs...) des langages plus modernes.</li> <li>\\(\\texttt{C}\\) offre au d\u00e9veloppeur une marge de contr\u00f4le importante sur la machine (notamment sur la gestion de la m\u00e9moire)</li> </ul>"},{"location":"C/02-ChaineCompil/#compilation","title":"Compilation","text":""},{"location":"C/02-ChaineCompil/#du-fichier-source-au-langage-machine","title":"Du fichier source au langage machine","text":"<p>La traduction d'un (ou plusieurs) fichiers sources en \\(\\texttt{C}\\) vers le langage machine se fait en 2 \u00e9tapes ind\u00e9pendantes et souvent encha\u00een\u00e9es automatiquement (donc difficile \u00e0 distinguer pour le d\u00e9butant).</p> <p>Pr\u00e9traitement</p> <p>Op\u00e9ration purement textuelle \\(\\color{red}\\text{consistant par exemple \u00e0 supprimer les } \\textit{commentaires}\\)</p> <ul> <li>Compilation. En \\(3\\) sous-\u00e9tapes :<ul> <li>Compilation proprement dite</li> <li>Assemblage</li> <li>\u00c9dition de liens</li> </ul> </li> </ul> <p>Compilation proprement dite</p> <p>\\(\\color{red}\\text{Transforme le fichier g\u00e9n\u00e9r\u00e9 par le pr\u00e9processeur en }\\textit{assembleur}\\) (une suite d'instructions du microprocesseur lisibles -- avec de l'entra\u00eenement -- par un humain),</p> <p>Assemblage</p> <p>\\(\\color{red}\\text{Transforme le code assembleur en instructions binaires}\\) (donc directement compr\u00e9hensibles par le processeur) Cette instruction et la pr\u00e9c\u00e9dente sont g\u00e9n\u00e9ralement effectu\u00e9es dans la foul\u00e9e l'une de l'autre sauf pr\u00e9cision contraire pass\u00e9e en argument du compilateur. Fichier binaire produit appel\u00e9 \\(\\color{red}\\textit{fichier objet}\\text{ (ou }\\textit{module objet})\\).</p> <p>\u00c9dition de liens</p> <p>\\(\\color{red}\\text{G\u00e9n\u00e9ration des liens entre les diff\u00e9rents fichiers objets du projet}\\). En effet, un programme complexe est en g\u00e9n\u00e9ral \u00e9crit sur plusieurs fichiers diff\u00e9rents. L'\u00e9diteur de lien produit un fichier ex\u00e9cutable.</p>"},{"location":"C/02-ChaineCompil/#environnement","title":"Environnement","text":""},{"location":"C/02-ChaineCompil/#choix-pour-la-mp2i-a-thiers","title":"Choix pour la MP2I \u00e0 Thiers","text":"<ul> <li>Un \u00e9diteur de texte emacs tournant sous Linux coupl\u00e9 au compilateur \\(\\texttt{C}\\) gcc lanc\u00e9 depuis un terminal</li> <li>Avantage : s'installe sans (trop) de difficult\u00e9s pour la plupart des configurations Linux.</li> <li>Par exemple, sous Ubuntu, puisque gcc et le terminal sont fournis par d\u00e9faut, il ne reste qu'\u00e0 installer emacs :</li> </ul> <pre><code>$sudo apt\u2212get install emacs\n</code></pre>"},{"location":"C/02-ChaineCompil/#un-code","title":"Un code","text":"<pre><code>// Le fichier hello . c Mon premier code C\n\n#include &lt;stdio.h&gt;// pour communiquer avec des fichier\n#include &lt;stdlib.h&gt;// pour g\u00e9rer la m\u00e9moire\n\nint main(){\n    int i = 10;\n    printf (\u201dHello world!\\n\u201d);// affichage puis passage \u00e0 la ligne\n    printf (\u201d%i\\n\u201d,i) ;// affichage de i\n    return 0;// renvoyer 0 : c.a.d tout s'est bien pass\u00e9\n}\n</code></pre>"},{"location":"C/02-ChaineCompil/#compiler-puis-executer","title":"Compiler puis ex\u00e9cuter","text":"<pre><code>$gcc hello.c \u2212o hello\n$./hello\nHello world!\ni=10\n</code></pre>"},{"location":"C/02-ChaineCompil/#gcc","title":"GCC","text":""},{"location":"C/02-ChaineCompil/#presentation","title":"Pr\u00e9sentation","text":"<p>\\(\\texttt{GCC}\\)</p> <p>\\(\\texttt{GNU}\\) \\(\\texttt{C}\\)ompiler \\(\\texttt{C}\\)ollection, abr\u00e9g\u00e9 en \\(\\texttt{GCC}\\), est un ensemble de compilateurs cr\u00e9\u00e9s par le projet \\(\\texttt{GNU}\\). Nous l'utilisons pour \\(\\texttt{C}\\) mais il peut aussi compiler \\(\\texttt{Java}\\), \\(\\texttt{Ada}\\), \\(\\texttt{Fortran}\\)...</p> <p>Trois composantes \\(\\texttt{GCC}\\) d\u00e9signe :</p> <ul> <li>la collection compl\u00e8te de compilateurs (le \u00ab projet \\(\\texttt{GCC}\\) \u00bb )</li> <li>la partie commune \u00e0 tous les compilateurs (\u00ab \\(\\texttt{GCC}\\) \u00bb ) ;</li> <li>le compilateur \\(\\texttt{C}\\) lui-m\u00eame (le frontend <code>gcc</code> ), \u00e9crit en minuscule).</li> </ul> <p>frontend <code>gcc</code> est un une application frontale (en anglais \u00ab frontend \u00bb ), ce qui signifie que l'utilisateur interragit directement avec lui.</p>"},{"location":"C/02-ChaineCompil/#lapplication-gcc","title":"L'application <code>gcc</code> \u2665","text":"<p><code>gcc</code> permet d'appeler dans l'ordre le pr\u00e9processeur, le compilateur, l'assembleur et le linker (lieur) pour le langage \\(\\texttt{C}\\) (et aussi \\(\\texttt{C++}\\)). Op\u00e9rations r\u00e9alis\u00e9es par gcc :</p> <ul> <li>appel du pr\u00e9processeur \\(\\texttt{C}\\) (nomm\u00e9 cpp) ;</li> <li>appel du compilateur \\(\\texttt{C}\\) (nomm\u00e9 cc). Le compilateur g\u00e9n\u00e8re un fichier assembleur;</li> <li>appel de l'assembleur (as) pour g\u00e9n\u00e9rer le fichier objet ;</li> <li>appel de l'\u00e9diteur de liens (ld) pour g\u00e9n\u00e9rer l'ex\u00e9cutable ou la biblioth\u00e8que. La librairie \\(\\texttt{C}\\) standard est incluse par d\u00e9faut dans la ligne de commande de l'\u00e9dition de liens.</li> </ul>"},{"location":"C/02-ChaineCompil/#pre-processeur","title":"Pr\u00e9-processeur","text":""},{"location":"C/02-ChaineCompil/#pretraitement","title":"Pr\u00e9traitement","text":"<p>Le pr\u00e9-processeur est un module de pr\u00e9-traitement qui effectue des transformations sur le code \u00e9crit avant qu'il ne soit trait\u00e9 par le compilateur.</p> <ul> <li>Consiste en la modification du texte d'un fichier source bas\u00e9e sur l'interpr\u00e9tation des directives \u00e0 destination du pr\u00e9processeur. \u2665</li> <li>On les reconna\u00eet parce qu'elles commencent par un hastag #. Elle ne se terminent pas par un point-virgule <code>;</code> .</li> <li>Les deux directives les plus importantes sont :<ul> <li><code>#include</code> : inclusion d'autres fichiers source. R\u00e9cursif : si A inclut B qui inclut C, apr\u00e8s pr\u00e9-processing, A contient C. \u2665</li> <li><code>#define</code> : d\u00e9finition de macros ou symboles (c'est \u00e0 dire des bout de code qui seront recopi\u00e9es tels-quels dans le code \\(\\texttt{C}\\)). \u2665</li> </ul> </li> <li>D'autres directives <code>#if</code>, <code>#ifndef</code> et <code>#endif</code>, utilis\u00e9es lors de l'\u00e9criture de fichiers d'en-t\u00eate, seront pr\u00e9sent\u00e9es ult\u00e9rieurement (pour la compilation de projets sur plusieurs fichiers).</li> </ul>"},{"location":"C/02-ChaineCompil/#pre-processeur_1","title":"Pr\u00e9-processeur","text":"<ul> <li>Effectue des remplacements textuels (et non s\u00e9mantiques) : le pr\u00e9-processeur \\(\\underline{\\text{n'est pas le compilateur}}\\), il n'interpr\u00e8te pas ce qu'il manipule. Analogie : fonction Remplacer d'un traitement de texte. \u2665</li> <li>Avec <code>#define NOM val</code> , le pr\u00e9-processeur remplace chaque occurence de la chaine NOM par la valeur val dans tout le texte du fichier. \u2665</li> <li>Entrer <code>cpp hello.c hello.i</code> puis v\u00e9rifier l'explosion de la taille de hello.i.</li> </ul>"},{"location":"C/02-ChaineCompil/#compilation_1","title":"Compilation","text":""},{"location":"C/02-ChaineCompil/#compilateur","title":"Compilateur","text":"<p>Traduire le code \\(\\texttt{C}\\) en code assembleur (programme <code>cc</code>).</p> <ul> <li>Compilation s\u00e9par\u00e9e : chaque fichier source est compil\u00e9 sans regarder les autres fichiers, m\u00eame s'ils font partie du m\u00eame programme</li> <li>Le compilateur a juste besoin de connaitre les prototypes (on dit aussi signatures) de toutes les fonctions utilis\u00e9es dans le fichier compil\u00e9, mais il n'a pas besoin d'avoir \u00e0 sa disposition le code des fonctions externes.</li> <li>Les prototypes des fonctions sont d\u00e9finies dans des fichiers <code>.h</code>, qui sont inclus par le pr\u00e9-processeur (via la directive <code>#include</code>) dans le fichier \\(\\texttt{C}\\) qui les utilise.</li> <li>Entrer <code>cc -S hello.i</code> . On obtient hello.s. L'ouvrir et v\u00e9rifier par exemple la mention du registre \\(32\\) bits <code>%eax</code>, du pointeur de sommet de pile <code>%rsp</code> et du pointeur de cadre de pile <code>%rbp</code></li> </ul>"},{"location":"C/02-ChaineCompil/#lassembleur","title":"L'assembleur","text":"<ul> <li>L'assembleur <code>as</code> prend un fichier \u00e9crit en langage assembleur et le traduit en code binaire (langage machine).</li> <li>Avec <code>as -o hello.o hello.s</code>, l'assembleur produit un fichier objet <code>hello.o</code> illisible pour un humain et non encore exploitable tel quel (il manque les liens).</li> </ul>"},{"location":"C/02-ChaineCompil/#edition-de-liens","title":"\u00c9dition de liens","text":"<p>L'\u00e9diteur de lien <code>ld</code> a pour r\u00f4le de fusionner les diff\u00e9rents fichiers objets pour produire l'ex\u00e9cutable final. Il fusionne :</p> <ul> <li>les codes contenus dans les diff\u00e9rentes fonctions de tous les fichiers objets du programme, pour obtenir une seule grosse zone de code ;</li> <li>les donn\u00e9es statiques allou\u00e9es dans tous les fichiers objets du programme, pour obtenir une grosse zone de donn\u00e9es statiques commune \u00e0 tout le programme.</li> </ul> <p>Un programme \\(\\texttt{C}\\) utilise toujours d'autres fichiers objets contenus dans la biblioth\u00e8que standard libc.a. Par exemple le fichier objet contenant le code de <code>printf</code> mais aussi d'autres fichiers qui permettent de rendre le code ex\u00e9cutable.</p>"},{"location":"C/02-ChaineCompil/#edition-de-liens-ld","title":"\u00c9dition de liens <code>ld</code>","text":"<p>Dans la compilation de hello.c, l'assembleur a laiss\u00e9 un \u00ab trou \u00bb \u00e0 l'endroit de l'appel \u00e0 <code>printf</code>. C'est une indication pour ins\u00e9rer \u00e0 cet endroit un v\u00e9ritable appel \u00e0 la fonction <code>printf</code> (on trouve sur ma machine le fichier objet <code>stdio.o</code> dans l'archive /usr/lib/x86 64-linux-gnu/libc.a)</p> <p>Si on appelle dans un fichier .c une fonction mal orthographi\u00e9e ou qui n'existe pas, c'est l'\u00e9diteur de lien qui rep\u00e8re l'erreur.</p> <p>Oublions d'\u00e9crire un <code>main</code> dans le projet. Un des fichiers inclus automatiquement par l'\u00e9diteur de lien inclu un appel \u00e0 <code>main</code> lequel est cherch\u00e9 dans les fichiers sources qu'on lui donne. <code>ld</code> d\u00e9clenche une erreur.</p>"},{"location":"C/02-ChaineCompil/#retour-sur-gcc","title":"Retour sur GCC","text":""},{"location":"C/02-ChaineCompil/#fichiers-provisoires","title":"Fichiers provisoires \u2665","text":"<p>Au cours de la compilation, des fichiers provisoires sont produits. Ils sont effac\u00e9s par le compilateur quand ce dernier termine sa t\u00e2che :</p> <ul> <li>\\(\\color{blue}\\text{.c}\\) : fichier source contenant le programme (et ses commentaires) \u00e9crit par le programmeur,</li> <li>\\(\\color{blue}\\text{.i}\\) : fichiers g\u00e9n\u00e9r\u00e9s par le pr\u00e9processeur (ce sont des fichiers textes),</li> <li>\\(\\color{blue}\\text{.s}\\) : fichiers assembleurs (donc lisibles par un humain),</li> <li>\\(\\color{blue}\\text{.o}\\) : fichiers objets (binaires) produits apr\u00e8s l'assemblage.</li> </ul>"},{"location":"C/02-ChaineCompil/#bibliotheques","title":"Biblioth\u00e8ques","text":"<p>\u00ab Biblioth\u00e8que \u00bb est la traduction de l'anglais \u00ab library \u00bb . On utilise improprement en fran\u00e7ais le mot \u00ab librairie \u00bb .</p> <p>Les fichiers .a : Archives constitu\u00e9es de fichiers objets correspondant aux librairies pr\u00e9compil\u00e9es (par exemple la librairie standard d'entr\u00e9es-sorties).</p> <p>Exemple libc.a : archive contenant notamment stdio.o.</p>"},{"location":"C/02-ChaineCompil/#gcc-et-bibliotheques","title":"<code>gcc</code> et biblioth\u00e8ques","text":"<p>Option <code>-l</code> de <code>gcc</code></p> <ul> <li>Les \u00e9ventuelles librairies pr\u00e9compil\u00e9es utilis\u00e9es sont d\u00e9clar\u00e9es par la cha\u00eene -lbiblioth\u00e8queD\u00e9sir\u00e9e et se situent souvent dans un sous-r\u00e9pertoire de /usr/lib/.</li> </ul> <p>La librairie math\u00e9matique libm.a est situ\u00e9e sur mon ordinateur dans /usr/lib/x86 64-linux-gnu/</p> <p>Pour la trouver, entrer :</p> <pre><code>$find /usr/lib \u2212name libm.a # affiche localisation de libm.a\n</code></pre> <p>Un nom de librairie commence par lib. A la suite de <code>-l</code> on n'\u00e9crit que ce qui est apr\u00e8s \u00ab lib \u00bb et avant le point.</p> <p>Pour utiliser libm.a et ses fonctions dans le programme myprog : \u2665</p> <pre><code>$gcc myprog.c \u2212lm \u2212o myprog\n</code></pre>"},{"location":"C/02-ChaineCompil/#encore-plus-sur-libma","title":"Encore plus sur libm.a","text":"<p>Un certain nombre de fonctions de la librairie libm.a sont des fonctions int\u00e9gr\u00e9es du compilateur (built-in functions).</p> <p>Pour des fonctions comme <code>cos</code> , la directive <code>#include &lt;math.h&gt;</code> est toujours n\u00e9cessaire mais pas (ou pas toujours) l'option <code>-lm</code> de gcc.</p> <p>En revanche, d'autres fonctions comme <code>nextafterf</code> ne sont toujours pas des fonctions int\u00e9gr\u00e9es du compilateur et n\u00e9cessite encore l'option <code>-lm</code> de gcc. Du moins sur ma machine...</p>"},{"location":"C/02-ChaineCompil/#acces-aux-bibliotheques","title":"Acc\u00e8s aux biblioth\u00e8ques","text":"<p>Les fonctions dont les prototypes sont dans stdlib.h et stdio.h sont \u00e9crites dans la librairie libc laquelle est import\u00e9e par d\u00e9faut par <code>gcc</code> . <code>gcc truc.c</code> se comprend donc comme <code>gcc truc.c -lc</code>. L'usage de <code>-lc</code> est donc implicite.</p> <p>Les librairies pr\u00e9compil\u00e9es sont cherch\u00e9es par d\u00e9faut dans le r\u00e9pertoire /usr/lib et ses descendants.</p> <p>Mais il peut se produire qu'elles ne se trouvent pas dans ce r\u00e9pertoire usuel, on sp\u00e9cifie alors leur chemin d'acc\u00e8s par l'option `-L</p>"},{"location":"C/02-ChaineCompil/#options-de-production-de-fichiers","title":"Options de production de fichiers","text":"<p>On peut demander \u00e0 gcc de produire les fichiers interm\u00e9diaires manipul\u00e9s par les diff\u00e9rents programmes qu'il appelle si on veut les observer :</p> <ul> <li><code>gcc -E -o hello.i hello.c</code> produit le fichier en sortie du pr\u00e9-processeur,</li> <li><code>gcc -S hello.c</code> produit le fichier en sortie du compilateur (apr\u00e8s avoir appel\u00e9 aussi le pr\u00e9-processeur)</li> <li><code>gcc -c hello.c</code> produit le fichier en sortie de l'assembleur (apr\u00e8s avoir appel\u00e9 aussi le pr\u00e9-processeur et le compilateur)</li> <li><code>gcc -o hello hello.c</code> appelle tous les programmes n\u00e9cessaires pour produire directement le binaire hello.</li> </ul>"},{"location":"C/02-ChaineCompil/#application-de-gcc-a-un-format-de-fichier","title":"Application de gcc \u00e0 un format de fichier","text":"<p>Le programme <code>gcc</code> se base simplement sur l'extension du fichier qu'on lui donne pour d\u00e9terminer quelles op\u00e9rations il doit effectuer. Par exemple, si le fichier se termine par :</p> <ul> <li><code>.c</code> , il appelle dans l'ordre : le pr\u00e9-processeur, le compilateur, l'assembleur et l'\u00e9diteur de lien.</li> <li><code>.i</code> il appelle dans l'ordre : le compilateur, l'assembleur et l'\u00e9diteur de lien.</li> <li><code>.s</code> : il appelle dans l'ordre : l'assembleur et l'\u00e9diteur de lien.</li> <li><code>.o</code> : il appelle l'\u00e9diteur de lien.</li> <li><code>gcc -o hello hello.c</code> appelle tous les programmes n\u00e9cessaires pour produire directement le binaire hello. D\u00e9truit en outre les fichiers interm\u00e9diaires.</li> </ul>"},{"location":"C/02-ChaineCompil/#schema-du-processus-de-compilation","title":"Sch\u00e9ma du processus de compilation","text":"<p>Cha\u00eene de compilation pour un programme compos\u00e9 d'un programme principal <code>prog.c</code> qui utilise un module <code>mod.c</code> (Christophe Rippert).</p> <p></p> <p>crt0.o : charg\u00e9 par d\u00e9faut par <code>ld</code> ; permet de rendre le fichier objet ex\u00e9cutable</p>"},{"location":"C/02-ChaineCompil/#options","title":"Options","text":"<p>Quelques options du compilateur gcc :</p> <ul> <li><code>-c</code> : supprime l'\u00e9dition de liens ; produit un fichier objet.</li> <li><code>-E</code> : n'active que le pr\u00e9processeur (le r\u00e9sultat est envoy\u00e9 sur la sortie standard).</li> <li><code>-I nom-de-r\u00e9pertoire</code> : sp\u00e9cifie le r\u00e9pertoire dans lequel doivent \u00eatre recherch\u00e9s les fichiers en-t\u00eates \u00e0 inclure (en plus du r\u00e9pertoire courant).</li> <li><code>-L nom-de-r\u00e9pertoire</code> : sp\u00e9cifie le r\u00e9pertoire dans lequel doivent \u00eatre recherch\u00e9es les librairies pr\u00e9compil\u00e9es (en plus du r\u00e9pertoire usuel).</li> <li><code>-o nom-de-fichier</code> sp\u00e9cifie le nom du fichier produit. Par d\u00e9faut, l'ex\u00e9cutable fichier s'appelle a.out.</li> <li><code>-S</code> : n'active que le pr\u00e9processeur et le compilateur ; produit un fichier assembleur.</li> <li><code>-v</code> : pour verbose. Affiche la liste des commandes ex\u00e9cut\u00e9es par les diff\u00e9rentes \u00e9tapes de la compilation.</li> <li><code>-W</code> : imprime des messages d'avertissement (warning) suppl\u00e9mentaires.</li> <li><code>-Wall</code> imprime tous les messages d'avertissement. Attention, cela peut-\u00eatre tr\u00e8s verbeux !</li> <li>...</li> </ul> <p>Le manuel : Pour plus d'informations sur gcc, entrer :</p> <pre><code>$man gcc\n</code></pre> <p>Pour quitter la manpage, taper \\(q\\) puis \u00ab Entr\u00e9e \u00bb .</p>"},{"location":"C/03-Bytes/","title":"Bytes et tailles","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"C/03-Bytes/#definition","title":"D\u00e9finition \u2665","text":"<p>byte</p> <p>On appelle byte (ou multiplets en fran\u00e7ais) la plus petite unit\u00e9 \u00ab logiquement \u00bb adressable par un programme sur un ordinateur. Aujourd'hui, le besoin d'une structure commune pour le partage des donn\u00e9es a fait que le byte de \\(8\\) bits, ou \\(1\\) octet, s'est g\u00e9n\u00e9ralis\u00e9 en informatique</p> <p>Remarque (Wikipedia)</p> <p>Le langage \\(\\texttt{C}\\) ne peut pas r\u00e9server une quantit\u00e9 de m\u00e9moire inf\u00e9rieure \u00e0 un byte.</p>"},{"location":"C/03-Bytes/#bon-a-savoir","title":"Bon \u00e0 savoir","text":"<ul> <li>Dans les ann\u00e9es \\(70\\) et auparavant, il existait des processeurs avec des bytes de tailles tr\u00e8s variables.</li> <li>Actuellement, il existe encore des processeurs avec des tailles de bytes de \\(4\\) bits voire moins (notamment pour la programmation des automates industriels).</li> <li>Beaucoup de microprocesseurs adressent physiquement la m\u00e9moire avec des mots de plusieurs bytes afin d'augmenter les performances.</li> <li>En \\(\\texttt{C}\\), l'op\u00e9rateur unaire <code>sizeof</code> donne la taille en bytes de son op\u00e9rande. L'op\u00e9rande peut \u00eatre un sp\u00e9cificateur de type ou une expression.</li> <li>Nous prendrons \\(1\\) octet comme taille de byte pour la suite du cours.</li> </ul>"},{"location":"C/03-Bytes/#utilite-de-sizeof","title":"Utilit\u00e9 de <code>sizeof</code>","text":"<ul> <li>Il est souvent utile de conna\u00eetre la taille d'un type de donn\u00e9e (en particulier d'une structure).</li> <li>En C la taille des types primitifs est une constante exprim\u00e9e en byte. Cependant, la taille r\u00e9elle en octet du byte d\u00e9pend des machines et de l'OS. Pour assurer la portabilit\u00e9 du code, il est pr\u00e9f\u00e9rable de r\u00e9server une zone m\u00e9moire en byte plut\u00f4t qu'en octet.</li> <li>Ci-dessous, la fonction malloc alloue une zone m\u00e9moire faisant la taille (en bytes) de \\(10\\) entiers. Elle retourne un pointeur sur cette zone :</li> </ul> <pre><code>int\u2217 pointeur;\npointeur = (int\u2217) malloc(10 \u2217 sizeof(int));\n</code></pre>"},{"location":"C/03-Bytes/#taille-dun-tableau","title":"Taille d'un tableau","text":"<p>Pour un tableau de \\(5\\) entiers <code>int t[5];</code> :</p> <ul> <li>la commande <code>sizeof(t)</code> donne la taille en bytes. Aucune inclusion n'est n\u00e9cessaire pour \\(\\texttt{sizeof}\\). En revanche, sa valeur de retour est un entier de type <code>size_t</code> (lequel est d\u00e9fini dans l'ent\u00eate standard \\(\\texttt{stdio.h}\\)).</li> <li>la commande <code>sizeof (*t)</code> (ou encore <code>sizeof *t</code> ) donne la taille du type des \u00e9l\u00e9ments de <code>t</code>.On peut aussi utiliser <code>sizeof(int)</code></li> <li><code>sizeof(t[0])</code> renvoie la taille du \\(1\\)er \u00e9l\u00e9ment de <code>t</code>. C'est la taille d'un int .</li> <li>Si on ne conna\u00eet pas le nombre d'\u00e9l\u00e9ments de <code>t</code> , on le retrouve par <code>sizeof t/ sizeof *t;</code>. \\(\\color{red}\\text{Cette technique fait bien ce qu'on veut mais uniquement dans le bloc o\u00f9 t est d\u00e9clar\u00e9 !}\\) Les parenth\u00e8ses ne sont pas obligatoires avec <code>sizeof</code> s'il s'agit de d\u00e9terminer la taille d'une expression. Elles le deviennent pour le nom d'un type.</li> </ul> <p>Exercice</p> <p>Dans un fichier \\(\\texttt{taille.c}\\) :</p> <ul> <li>Directement dans le main, afficher la taille des types <code>size t, int, int*</code>.</li> <li>Directement dans le main , cr\u00e9er maintenant un tableau de \\(5\\) entiers et afficher sa taille avec la technique pr\u00e9c\u00e9dente.</li> <li>\u00c9crire une fonction <code>int tailletab (int t[])</code> qui prend en param\u00e8tre un tableau et affiche sa taille selon la technique pr\u00e9c\u00e9dente. Appeler maintenant dans le main cette fonction avec un tableau de \\(5\\) entiers et comparer avec l'affichage pr\u00e9c\u00e9dent. Expliquer.</li> </ul>"},{"location":"C/03-Bytes/#multiples-de-loctet","title":"Multiples de l'octet","text":"<ul> <li>Un octet vaut \\(8\\) bits.</li> <li>Les tailles de fichiers ou de variables sont donn\u00e9es en multiples de l'octet. Les multiples d\u00e9cimaux sont les plus utilis\u00e9s (kilo, m\u00e9ga, giga, t\u00e9ra) mais ne sont pas recommand\u00e9s par la Commission \u00e9lectrotechnique internationale.</li> <li>Une nouvelle norme \u00e0 \u00e9t\u00e9 cr\u00e9\u00e9e en \\(1988\\) pour noter les multiples de \\(2^10 = 1024\\) : les \\(\\underline{\\text{kibi}}\\) (kilo binaire), \\(\\underline{\\text{m\u00e9bi}}\\) (m\u00e9ga binaire), \\(\\underline{\\text{gibi}}\\) (giga binaire) etc.</li> <li>Certains syst\u00e8mes d'exploitation annoncent faussement les quantit\u00e9s d'octets avec un suffixe d\u00e9cimal.</li> </ul> <p>Par exemple une quantit\u00e9 de \\(32\\) \\(\\text{Go}\\) peut \u00eatre affich\u00e9e correctement comme \\(29.8\\) \\(\\text{Gio}\\) ou improprement comme \\(29.8\\) \\(\\text{Go}\\) sur certains syst\u00e8mes d'exploitations.</p>"},{"location":"C/03-Bytes/#multiples-decimaux-de-loctet","title":"Multiples d\u00e9cimaux de l'octet","text":"<p>Multiples d\u00e9cimaux de l'octet dans le SI et mauvais usage :</p> Nom Symbole Valeur en octets M\u00e9susage kilooctet \\(\\text{ko}\\) \\(10^3\\) \\(2^{10}\\) m\u00e9gaoctet \\(\\text{Mo}\\) \\(10^6\\) \\(2^{20}\\) gigaoctet \\(\\text{Go}\\) \\(10^9\\) \\(2^{30}\\) t\u00e9raoctet \\(\\text{To}\\) \\(10^{12}\\) \\(2^{40}\\) p\u00e9taoctet \\(\\text{Po}\\) \\(10^{15}\\) \\(2^{50}\\) exaoctet \\(\\text{Eo}\\) \\(10^{18}\\) \\(2^{60}\\) zettaoctet \\(\\text{Zo}\\) \\(10^{21}\\) \\(2^{70}\\) yottaoctet \\(\\text{Yo}\\) \\(10^{24}\\) \\(2^{80}\\) <p>\\(\\text{ko, Mo,Go}\\) (noter les majuscules et minuscules) \u2665</p>"},{"location":"C/03-Bytes/#multiples-binaires-de-loctet","title":"Multiples binaires de l'octet","text":"Nom Symbole Valeur en octets M\u00e9susage kibioctet \\(\\text{Kio}\\) \\(2^{10}\\) \\(1024\\) octets m\u00e9bioctet \\(\\text{Mio}\\) \\(2^{20}\\) \\(1024\\) \\(\\text{Kio}\\) gibioctet \\(\\text{Gio}\\) \\(2^{30}\\) \\(1024\\) \\(\\text{Mio}\\) t\u00e9bioctet \\(\\text{Tio}\\) \\(2^{40}\\) \\(1024\\) \\(\\text{Gio}\\) p\u00e9bioctet \\(\\text{Pio}\\) \\(2^{50}\\) \\(1024\\) \\(\\text{Tio}\\) exbioctet \\(\\text{Eio}\\) \\(2^{60}\\) \\(1024\\) \\(\\text{Pio}\\) zebioctet \\(\\text{Zio}\\) \\(2^{70}\\) \\(1024\\) \\(\\text{Eio}\\) yobioctet \\(\\text{Yio}\\) \\(2^{80}\\) \\(1024\\) \\(\\text{Zio}\\) <p>\\(\\text{Kio, Mio,Gio}\\) (noter les majuscules et minuscules) \u2665</p>"},{"location":"C/03-Bytes/#taille-dun-fichier","title":"Taille d'un fichier","text":""},{"location":"C/03-Bytes/#la-commande-du","title":"La commande <code>du</code>","text":"<ul> <li>Dans un terminal depuis le r\u00e9pertoire courant</li> </ul> <pre><code>$du \u2212h\n</code></pre> <p>Donne la taille du r\u00e9pertoire courant et ses sous-r\u00e9pertoires</p> <ul> <li>Pour avoir la taille des fichiers du r\u00e9pertoire, utiliser <code>*</code> . Option <code>-h</code> pour \u00ab Human redable \u00bb : r\u00e9sultats en Kilo-octet, Mega-octet, Giga-octect...</li> </ul> <pre><code>$du \u2212h \u2217\n</code></pre> <ul> <li>L'option <code>-s</code> permet de n'afficher que le total de la taille du r\u00e9pertoire.</li> </ul> <pre><code>$du \u2212sh\n</code></pre>"},{"location":"C/03-Bytes/#la-commande-ncdu","title":"La commande <code>ncdu</code>","text":"<p>Plus conviviale que <code>du</code> , <code>ncdu</code> permet de naviguer dans l'arborescence avec le clavier (fl\u00e8ches et retour chariot)</p> <p></p> <p>Figure \u2013 La commande <code>ncdu</code></p> <p>Entrer <code>q</code> pour quitter</p>"},{"location":"C/04-Matrices/","title":"Tableaux \u00e0 deux indices","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Cette page de CommentCaMarche.net</li> <li>\u00ab Langage C \u00bb -Claude Delannoy- Ed. Eyrolles</li> </ul>"},{"location":"C/04-Matrices/#declaration-de-tableaux-a-deux-indices","title":"D\u00e9claration de tableaux \u00e0 deux indices","text":"<ul> <li>Les tableaux multidimensionnels sont des tableaux qui contiennent des tableaux.</li> <li>Un d\u00e9clarateur de tableau est de la forme <code>decl1 [nb1]</code>. Si <code>decl1</code> est lui-m\u00eame un d\u00e9clarateur de tableau, il peut \u00eatre de la forme <code>decl2 [nb2]</code>. Ainsi, pour d\u00e9clarer un tableau de tableaux, on utilise la syntaxe <code>decl2 [nb2] [nb1]</code>.</li> </ul> <p>Exemple</p> <p>Prenons <code>int tab [5] [3];</code>. Dans ce cas :</p> <ul> <li><code>tab [4] [2]</code> est un <code>int</code></li> <li><code>tab [4]</code> est un tableau de \\(3\\) <code>int</code></li> <li><code>tab</code> est un tableau dont chaque \u00e9l\u00e9ment est lui-m\u00eame un tableau de \\(3\\) <code>int</code> .</li> </ul>"},{"location":"C/04-Matrices/#organisation-en-memoire","title":"Organisation en m\u00e9moire","text":"<p>Consid\u00e9rons int <code>tab [5][3]</code>.</p> <ul> <li>Avec cette d\u00e9claration <code>tab</code> n'est pas un tableau de pointeurs : les \u00e9l\u00e9ments du tableau sont ici \\(15\\) entiers rang\u00e9s cons\u00e9cutivement en m\u00e9moire.</li> <li>Acc\u00e8s : Pour acc\u00e9der \u00e0 l'\u00e9l\u00e9ment d'indice \\((i ,j )\\), le compilateur calcule un d\u00e9calage de \\(4 \u00d7( \\underbrace{\\color{red}3}_\\text{nb. de col} \u00d7i + j )\\) octets par rapport \u00e0 l'adresse du premier \u00e9l\u00e9ment du tableau.</li> </ul> <p>Remarque</p> <p>On observe que, pour localiser un \u00e9l\u00e9ment du tableau, la grandeur vraiement importante est le nombre de \u00ab colonnes \u00bb pas le nombre de lignes (ce mot colonne ne correspond d'ailleurs \u00e0 aucune r\u00e9alit\u00e9 informatique, mais il est bien connu des math\u00e9maticiens)</p>"},{"location":"C/04-Matrices/#debordement-dindices","title":"D\u00e9bordement d'indices","text":"<p>Consid\u00e9rons <code>int tab [5][3]</code></p> <ul> <li>Les \u00e9l\u00e9ments sont rang\u00e9s dans des emplacements contigu\u00ebs de la m\u00e9moire :</li> </ul> <pre><code>tab[0][0], tab[0][1], tab[0][2], tab[1][0], tab[1][1], tab[1][2], tab[2][1]...  \n</code></pre> <ul> <li>Ainsi <code>tab[0][5]</code> d\u00e9signe <code>tab[1][2]</code></li> <li>Et <code>tab[5][0]</code> d\u00e9signe un \u00e9l\u00e9ment juste au del\u00e0 des limites du tableau.</li> </ul>"},{"location":"C/04-Matrices/#passage-en-parametres","title":"Passage en param\u00e8tres","text":"<p>Consid\u00e9rons <code>int tab [5][3]</code></p> <ul> <li>Si on doit passer un tableau multidimensionnel en param\u00e8tre d'une fonction, il est important de communiquer au moins la deuxi\u00e8me dimension. On \u00e9crit donc <code>void f(int tab[5][3])</code> ou m\u00eame <code>void f(int tab[][3])</code> , dans la mesure o\u00f9 <code>5</code> n'a qu'une valeur informative tandis que <code>3</code> est indispensable \u00e0 la localisation des \u00e9l\u00e9ments.</li> <li>Dans le cas d'un tableau multidimensionnel dont la taille n'est pas connue \u00e0 la compilation, on utilise plut\u00f4t un tableau de pointeurs et on \u00e9crit <code>void f(int n, int m, int **tab);</code>. On fait l'hypoth\u00e8se ici que <code>tab</code> est un tableau de \\(n\\) pointeurs, chacun repr\u00e9sentant un tableau de \\(m\\) entiers.</li> </ul> <p>\\(\\color{red}\\text{Avec }\\)<code>**tab</code> \\(\\color{red}\\text{en param\u00e8tre, les \u00ab lignes \u00bb de la matrice ne sont plus contigu\u00ebs en m\u00e9moire}\\).</p>"},{"location":"C/05-Bitwise/","title":"Op\u00e9rateurs bitwise","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Une page de Dev4all (Page not found \ud83e\udea6)</li> <li>Cette page de Wikipedia</li> </ul>"},{"location":"C/05-Bitwise/#presentation","title":"Pr\u00e9sentation","text":"<p>Dans un ordinateur, les donn\u00e9es et les fichiers sont constitu\u00e9s de bits en nombre variable selon leurs types.</p> <p>En \\(\\texttt{C}\\), il existe \\(6\\) op\u00e9rateurs de gestion binaires (op\u00e9rateurs bitwise ou bit \u00e0 bit) :</p> <ul> <li><code>&amp;</code> : Op\u00e9rateur bitwise \\(\\text{AND}\\)</li> <li><code>|</code> : Op\u00e9rateur bitwise \\(\\text{OR}\\)</li> <li><code>\u2227</code> : Op\u00e9rateur bitwise \\(\\text{XOR}\\) \\((\\text{OU exclusif})\\). Not\u00e9 aussi \\(\u2295\\) en maths.</li> <li><code>~</code> : Op\u00e9rateur bitwise de compl\u00e9ment</li> <li><code>&gt;&gt;</code> : Op\u00e9rateur de redirection vers la droite</li> <li><code>&lt;&lt;</code> : Op\u00e9rateur de redirection vers la gauche</li> </ul>"},{"location":"C/05-Bitwise/#principe","title":"Principe","text":"<p>Un op\u00e9rateur bit \u00e0 bit binaire comme <code>&amp;</code> traite ses donn\u00e9es d'entr\u00e9e (deux objets de m\u00eame type) selon leur repr\u00e9sentation binaire (une s\u00e9quence de \\(0\\) et de \\(1\\)).</p> <p>Il calcule une nouvelle s\u00e9quence binaire et traduit ce r\u00e9sultat dans le format d'origine des donn\u00e9es.</p>"},{"location":"C/05-Bitwise/#loperateur","title":"L'op\u00e9rateur <code>&amp;</code>","text":"<p>Cet op\u00e9rateur binaire prend deux s\u00e9quences de bits de m\u00eame longueur et effectue un \\(\\text{ET}\\) logique bit-\u00e0-bit.</p> <p>Il calcule le \\(\\text{ET}\\) logique du premier bit des deux s\u00e9quences, puis celui des seconds bits etc. Le r\u00e9sultat est une s\u00e9quence de bits qui est interpr\u00e9t\u00e9e selon le format d'origine des s\u00e9quences d'entr\u00e9e.</p> <ul> <li>Dans la fonction main, entrons ceci :</li> </ul> <pre><code>int x = 9, y = 12;\nprintf(\"%d&amp;%d=%d\\n\", x, y, x&amp;y);\n</code></pre> <p>Apr\u00e8s compilation et ex\u00e9cution, on obtient l'affichage :</p> Rendu<pre><code>x&amp;y=8\n</code></pre> <ul> <li>L'op\u00e9rateur &amp; consid\u00e8re l'entier \\(9\\) comme \\(1001\\) et \\(12\\) comme \\(1100\\) :</li> </ul> <p>\\(\\begin{matrix} &amp; 1001 \\\\ \\&amp; &amp; 1100 \\\\ \\underline{\\kern0.8pc} &amp; \\underline{\\kern2pc} \\\\ &amp; 1000 \\\\ \\end{matrix}\\)</p> <p>Le r\u00e9sultat obtenu est \\(1000\\) qui est transform\u00e9 en int. On obtient \\(8\\).</p>"},{"location":"C/05-Bitwise/#loperateur_1","title":"L'op\u00e9rateur <code>|</code>","text":"<p>Cet op\u00e9rateur binaire fonctionne comme le pr\u00e9c\u00e9dent mais effectue un \\(\\text{OU}\\) logique bit-\u00e0-bit et non un \\(\\text{ET}\\).</p> <ul> <li>Dans la fonction main, entrons ceci :</li> </ul> <pre><code>int x = 9, y = 12;\nprintf(\"%d|%d=%d\\n\", x, y, x|y);\n</code></pre> <p>Apr\u00e8s compilation et ex\u00e9cution, on obtient l'affichage :</p> Rendu<pre><code>x|y=13\n</code></pre> <ul> <li>On fait l'op\u00e9ration :</li> </ul> <p>\\(\\begin{matrix} &amp; 1001 \\\\ | &amp; 1100 \\\\ \\underline{\\kern0.8pc} &amp; \\underline{\\kern2pc} \\\\ &amp; 1101 \\\\ \\end{matrix}\\)</p> <p>Le r\u00e9sultat obtenu est \\(1101\\) qui est transform\u00e9 en int. On obtient \\(13\\).</p>"},{"location":"C/05-Bitwise/#loperateur_2","title":"L'op\u00e9rateur <code>^</code>","text":"<p>Cet op\u00e9rateur binaire r\u00e9alise le \\(\\text{XOR}\\) bit-\u00e0-bit de ses deux op\u00e9randes.</p> <ul> <li>Dans la fonction main, entrons ceci :</li> </ul> <pre><code>int x = 9, y = 12;\nprintf(\"%d^%d=%d\\n\", x, y, x^y);\n</code></pre> <p>Apr\u00e8s compilation et ex\u00e9cution, on obtient l'affichage :</p> Rendu<pre><code>x^y=5\n</code></pre> <ul> <li>On fait l'op\u00e9ration :</li> </ul> <p>\\(\\begin{matrix} &amp; 1001 \\\\ \\^{ } &amp; 1100 \\\\ \\underline{\\kern0.8pc} &amp; \\underline{\\kern2pc} \\\\ &amp; 0101 \\\\ \\end{matrix}\\)</p> <p>Le r\u00e9sultat obtenu est \\(0101\\) qui est transform\u00e9 en int. On obtient \\(5\\).</p>"},{"location":"C/05-Bitwise/#loperateur_3","title":"L'op\u00e9rateur <code>~</code>","text":"<p>Cet op\u00e9rateur unaire inverse tous les bits de la s\u00e9quence Dans la fonction main, entrons ceci :</p> <ul> <li>Dans la fonction main, entrons ceci :</li> </ul> <pre><code>uint8_t z = 5; uint8_t t = ~z; // entiers 8 buts\nprintf(\"~%u=%u\\n\", z, t); // %u pour unsigned\n</code></pre> <p>Apr\u00e8s compilation et ex\u00e9cution, on obtient l'affichage :</p> Rendu<pre><code>~5=250\n</code></pre> <ul> <li>N'oublions pas on travialle sur \\(8\\) bits :</li> </ul> <p>\\(\\begin{matrix} \\widetilde{\\kern0.4pc} &amp; 0000 &amp; 0101 \\\\ \\underline{\\kern0.8pc} &amp; \\underline{\\kern2pc}&amp; \\underline{\\kern2pc} \\\\ &amp; 1111 &amp; 1010 \\\\ \\end{matrix}\\)</p> <p>Le r\u00e9sultat obtenu est \\(1111\\) \\(1010\\) qui est transform\u00e9 en <code>uint8_t</code> (entier non sign\u00e9). On obtient \\(250\\) c.a.d \\(255-5\\). </p> <p>Si on travaille avec des entiers sign\u00e9s cete fois ci alors </p> <pre><code>int8_t u = 5; int8_t t = ~v; // entiers 8 bits\nprintf(\"~%d=%d\\n\", u, v); // %d pour les entiers sign\u00e9s\n</code></pre> <p>Apr\u00e8s compilation et ex\u00e9cution, on obtient l'affichage :</p> Rendu<pre><code>~5=-6\n</code></pre> <ul> <li>N'oublions pas on travialle en compl\u00e9ment \u00e0 \\(2\\) sur \\(8\\) bits :</li> </ul> <p>\\(\\begin{matrix} \\widetilde{\\kern0.4pc} &amp; 0000 &amp; 0101 \\\\ \\underline{\\kern0.8pc} &amp; \\underline{\\kern2pc}&amp; \\underline{\\kern2pc} \\\\ &amp; 1111 &amp; 1010 \\\\ \\end{matrix}\\)</p> <p>Le r\u00e9sultat obtenu est \\(1111\\) \\(1010\\) qui est transform\u00e9 en <code>int8_t</code> On lui retranche \\(2^8 = 256\\) (entiers sign\u00e9s) et on obtient \\(-6\\)</p>"},{"location":"C/05-Bitwise/#loperateur_4","title":"L'op\u00e9rateur <code>&gt;&gt;</code>","text":"<p>Cet op\u00e9rateur dit de d\u00e9calage \u00e0 droite, d\u00e9cale les bits vers la droite. Les bits qui sortent \u00e0 droite sont perdus, tandis que le bit de poids fort est recopi\u00e9 \u00e0 gauche.</p> <p>Example</p> <pre><code>int32_t x = 13;\nprintf(\"%d\\n\", x &gt;&gt; 2);\n</code></pre> <p>On obtient l'affichage de \\(3\\).</p> <p>Expliquons la raison de ce r\u00e9sultat. L'\u00e9criture binaire de \\(13\\) sur \\(3\\) bits est :</p> <p>\\({\\color{red}0}0000000000000000000000000001101\\)</p> <p>On d\u00e9cale les bits de deux rangs vers la droite. La s\u00e9quence finale \\(01\\) est perdue, et on obtient (\\(3\\) en binaire) : \\({\\color{red}0}  \\overrightarrow{\\kern0.23pc0\\kern0.23pc 0\\kern0.23pc} 00000000000000000000000000011\\)</p> <ul> <li>Il a fallu combler les deux cases vides laiss\u00e9es par le d\u00e9part de \\(01\\). On a rajout\u00e9 deux z\u00e9ros \u00e0 gauche parce que le bit de poids fort de l'expression initiale est \u00e0 z\u00e9ro. Ce z\u00e9ro d\u00e9signe en fait le signe du nombre \\(13\\) : ce dernier est positif comme \\((\u22121)^0\\).</li> <li>Le r\u00e9sultat de \\(13 &gt;&gt;2\\) est donc \\({13}/{4}\\) c'est \u00e0 dire \\(3\\) (la division par \\(4\\) parce que \\(2^2 = 4\\))</li> </ul> <pre><code>int32_t x = -13;\nprintf(\"%d\\n\", x &gt;&gt; 2);\n</code></pre> <p>Cette fois-ci le r\u00e9sultat est \\(-4\\) alors qu'on se serait attendu \u00e0 \\(-3\\). </p> <ul> <li>L'\u00e9criture de \\(-13\\) en compl\u00e9ment \u00e0 \\(2\\) sur \\(32\\) bits est en effet : \\(1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 1 1\\)</li> <li>On d\u00e9cale de deux rangs vers la droite, et on ajoute la s\u00e9quence \\(11\\) \u00e0 gauche (on comble les vides par le bit de poids fort de la s\u00e9quence initiale). On se retrouve donc avec : \\(111 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0\\)</li> </ul> <p>C'est l'expression de \\(-4\\) en compl\u00e9ment \u00e0 deux sur \\(32\\) bits.</p>"},{"location":"C/05-Bitwise/#loperateur_5","title":"L'op\u00e9rateur <code>&lt;&lt;</code>","text":"<p>Cet op\u00e9rateur de d\u00e9calage vers la gauche correspond \u00e0 une multiplication par une puissance de deux.</p> <p>Consid\u00e9rons</p> <p><pre><code>int8_t x = 3;\nprintf(\"%d\\n\", x &lt;&lt; 4);\n</code></pre> - Le codage de \\(3\\) en compl\u00e9ment \u00e0 \\(2\\) sur \\(8\\) bits est \\(0000011\\). - Le d\u00e9calage de \\(4\\) rangs \u00e0 gauche produit \\(0110000\\), ce qui fait \\(48\\). - Il se trouve que \\(3 \u00d72^4 = 48\\). On a donc multipli\u00e9 \\(3\\) par \\(2^4\\) en faisant notre d\u00e9calage de \\(4\\) bits.</p>"},{"location":"C/06-Boucles/","title":"Boucles","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Openclassrooms</li> <li>\u00ab Langage C \u00bb -Claude Delannoy- Ed. Eyrolles</li> <li>\u00ab Informatique - MP2I/MPI - CPGE 1re et 2e ann\u00e9es \u00bb -Balabonski Thibaut, Conchon Sylvain, Filli\u02c6atre Jean-Christophe, Nguyen Kim, Sartre Laurent- Ed. Ellipse</li> </ul>"},{"location":"C/06-Boucles/#boucles-while","title":"Boucles <code>while</code>","text":"<p>Pour m\u00e9moire on rappelle le fonctionnement de la boucle <code>while</code> :</p> <pre><code>while(Condition){\n    // Instructions \u00e0 r\u00e9p\u00e9ter\n}\n</code></pre> <p>Voici une boucle qui demande d'entrer un nombre jusqu'\u00e0 ce que l'utilisateur saisisse \\(10\\) :</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(){\n    int nb = 0;\n    while(nb != 10){\n        printf(\"\\nentrer un nb entier : \");\n    }\n    return 0;\n}\n</code></pre>"},{"location":"C/06-Boucles/#boucle-do-while","title":"Boucle <code>do</code> ... <code>while</code>","text":"<p>Dans une boucle <code>while</code> , si la condition n'est pas r\u00e9alis\u00e9e alors le corps de la boucle n'est jamais ex\u00e9cut\u00e9.</p> <p>Une fa\u00e7on d'\u00e9viter cela est de mettre le test de sortie de boucle \u00e0 la fin :</p> <pre><code>int compteur = 0; // le compteur\ndo{\n    printf(\"le compteur vaut %i.\\n\", compteur);\n    compteur ++; // incr\u00e9mentation de 1\n}while(compteur &lt; 0); // ne pas oublier le point virgule\n</code></pre> <p>Apr\u00e8s compilation et ex\u00e9cution :</p> Rendu<pre><code>le compteur vaut 0.\n</code></pre>"},{"location":"C/06-Boucles/#boucle-for","title":"Boucle for","text":"<ul> <li>Si on souhaite parcourir tous les entiers de \\(0\\) \u00e0 \\(n \u22121\\), on peut le faire avec une boucle while (et g\u00e9rer soi-m\u00eame le compteur) :</li> </ul> <p><code>{int i = 0; while (i&lt;n){...; i = i+1; }}</code></p> <ul> <li>Une boucle <code>for(declaration, test, mise \u00e0 jour)</code> permet de faire la m\u00eame chose et g\u00e8re la mise \u00e0 jour :</li> </ul> <p><code>for (int i = 0; i&lt;n; i = i+1) {...;}</code></p> <ul> <li>Incr\u00e9mentation : On peut \u00e9crire <code>i+=1</code> \u00e0 la place de <code>i=i+1</code> , ou m\u00eame <code>i++</code> .</li> <li>D\u00e9cr\u00e9mentation : <code>i--</code></li> </ul>"},{"location":"C/06-Boucles/#complements","title":"Compl\u00e9ments","text":"<p>La boucle <code>for</code> a une forme non limit\u00e9e \u00e0 l'exemple du transparent pr\u00e9c\u00e9dent.</p> <ul> <li>Pour une variable \\(x\\) d\u00e9clar\u00e9e hors de la boucle, on peut \u00e9crire :</li> </ul> <pre><code>int x = 3 ; ...\nfor(; x != 1; x=f(x)){...}\n</code></pre> <ul> <li>Et si <code>start</code>, <code>stop</code>, <code>step</code> sont \\(3\\) fonctions d\u00e9finies par ailleurs</li> </ul> <pre><code>for(start(); tests(); step()){...}\n</code></pre>"},{"location":"C/06-Boucles/#operateurs-dincrementation","title":"Op\u00e9rateurs d'incr\u00e9mentation","text":"<ul> <li><code>i++</code> est une expression qui renvoie la valeur de la variable \\(i\\) \\(\\underline{\\text{avant}}\\) son incr\u00e9mentation.</li> <li><code>++i</code> est une expression qui incr\u00e9mente \\(i\\) \\(\\underline{\\text{puis}}\\) renvoie la valeur de la variable \\(i\\).</li> </ul> <pre><code>int n = 3;\nwhile (n\u2212\u2212 &gt; 0) printf(\"n=%d\", n);\n</code></pre> <p>affiche \\(\\texttt{n=2,n=1,n=0}\\). On compare en effet successivement \\(3,2,1,0\\) avec \\(0\\) car <code>n-- &gt; 0</code> d\u00e9cr\u00e9mente apr\u00e8s la comparaison.</p> <ul> <li>Mais</li> </ul> <pre><code>int n = 3;\nwhile (n\u2212\u2212 &gt; 0) printf(\"n=%d\", n);\n</code></pre> <ul> <li>Moyen m\u00e9motechnique : mettre le <code>--</code> le plus loin possible de l'op\u00e9rateur de comparaison.</li> <li>Avec <code>--n&gt;0</code> on comprend que  <ul> <li>d'abord on d\u00e9cr\u00e9mente et</li> <li>ensuite on compare.</li> </ul> </li> <li>Avec <code>0&lt;n--</code> on comprend que<ul> <li>d'abord on compare et</li> <li>ensuite on d\u00e9cr\u00e9mente.</li> </ul> </li> <li>Mais de toute fa\u00e7on, je d\u00e9conseille fortement d'utiliser ces op\u00e9rateurs dans d'autres instructions.</li> </ul>"},{"location":"C/06-Boucles/#danger-des-operateurs-dincrementation","title":"Danger des op\u00e9rateurs d'incr\u00e9mentation","text":"<ul> <li>L'ordre d'\u00e9valuation des op\u00e9randes (de gauche \u00e0 droite ?) ou des arguments d'un appel de fonction n'est pas sp\u00e9cifi\u00e9 en \\(\\texttt{C}\\).<ul> <li>Il faut donc se m\u00e9fier des appels comme <code>f(x++,x)</code> car la norme ne dit pas si le second param\u00e8tre est affect\u00e9 ou non par l'incr\u00e9mentation (\u00e7a peut d\u00e9pendre des impl\u00e9mentations !).</li> <li>Si <code>x=3</code> , cet appel peut \u00eatre compris <code>f(3,3)</code> ou <code>f(3,4)</code>.</li> </ul> </li> <li>Nous r\u00e9servons alors sagement les expressions comme <code>i++</code> et <code>i--</code> \u00e0 la partie \u00ab incr\u00e9mentation \u00bb des boucles, sans les inclures dans d'autres expressions.</li> </ul>"},{"location":"C/06-Boucles/#les-instructions-break-et-continue","title":"Les instructions <code>break</code> et <code>continue</code>","text":"<ul> <li>L'instruction <code>break</code> permet de sortir d'une boucle ; <code>continue</code> de passer \u00e0 l'it\u00e9ration suivante.</li> <li>Ces instructions ne concernent que le bloc d'instruction courante.</li> <li>Si, par exemple, <code>break</code> est utilis\u00e9e dans une double boucle imbriqu\u00e9e, il ne permet de sortir que de la boucle interne.</li> </ul>"},{"location":"C/06-Boucles/#break","title":"<code>break</code>","text":"<pre><code>    int i, j;\n    for(i = 0; i &lt; 4 ; i++){\n        printf(\"\\ni = %d,\", i);\n        for(j = 0; j &lt; 5 ; j++){\n            if(j == 2) break; // quitter la boucle interne\n            printf(\"j = %d,\", j);\n        }// f o r j\n    }// for i\n    printf(\"\\nbye\\n\");\n</code></pre> <p>Produit l'affichage</p> Rendu<pre><code>i = 0, j = 0,j = 1,\ni = 1, j = 0,j = 1,\ni = 2, j = 0,j = 1,\ni = 3, j = 0,j = 1,\nbye\n</code></pre>"},{"location":"C/06-Boucles/#continue","title":"<code>continue</code>","text":"<p>Le code suivant :</p> <pre><code>int i;\nfor(i = 0; i &lt; 5 ; i++){\n    if(i == 3) continue; // passer \u00e0 l'it\u00e9ration suivante\n    // cette instruction est ignor\u00e9e lorsque i == 3\n    printf(\"i = %d\\n\", i);\n}\nprintf(\"bye\\n\");\n</code></pre> <p>produit l'affichage</p> Rendu<pre><code>i = 0\ni = 1\ni = 2\ni = 4\nbye\n</code></pre>"},{"location":"C/07-array_size/","title":"Taille d'un tableau en \\(\\texttt{C}\\)","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Pour d\u00e9terminer la dimension d'un tableau <code>t</code> en C, le cours conseille d'utiliser la fonction <code>sizeof</code> et un quotient :</p> <pre><code>sizeof t / sizeof \u2217t;\n</code></pre> <p>Le rapport du total de bytes occup\u00e9s par le tableau sur la taille de son premier \u00e9l\u00e9ment donne en effet le nombre d'\u00e9l\u00e9ments.</p> <p>Toutefois, cette m\u00e9thode marche bien dans le bloc d'instructions o\u00f9 est d\u00e9fini le tableau mais n'est pas robuste vis \u00e0 vis du passage d'un tableau en param\u00e8tres. Consid\u00e9rons le code :</p> <pre><code># include &lt;stdio.h&gt;\n\nint tailletab (int t[]){ // taille d'un tableau, vraiment ?\nreturn sizeof t / sizeof \u2217t;\n}\n\nint main(){\n    int t[5] = { 1 , 2 , 3 , 4, 5};\n    printf(\"taille t : %ld bytes \\n\", (sizeof t / sizeof \u2217t ));\n    printf(\"taille tab(t) = %d bytes \\n\", tailletab(t));\n    printf(\"sizeof(int)=%ld bytes \\n\", sizeof(int));\n    printf(\"sizeof(int\u2217 )=%ld bytes\\n\", sizeof(int\u2217 ));\n    return 0;\n}\n</code></pre> <p>Apr\u00e8s compilation et ex\u00e9cution, on obtient :</p> <pre><code>$ ./a.out\ntaille t : 5 bytes\ntailletab(t) = 2 bytes\nsizeof(int) = 4 bytes\nsizeof(int* ) = 8 bytes\n</code></pre> <p>Notre m\u00e9thode par quotient indique bien le nombre d'\u00e9l\u00e9ments de <code>t</code> (\\(5\\) bytes) dans le bloc d'instructions o\u00f9 il est d\u00e9clar\u00e9. Le quotient calcule le nombre de bytes occup\u00e9s par <code>t</code> (\\(5 \u00d74\\) bytes) divis\u00e9e par la taille de <code>*t</code> , c'est \u00e0 dire la taille du premier \u00e9l\u00e9ment de <code>t</code>\\(^{1.}\\) . Or, un entier occupe \\(4\\) bytes. Ainsi \\(20/4\\) donne \\(5\\), ce qu'on veut.</p> <p>Remarque</p> <p>\\(\\color{blue}1.\\) On peut pr\u00e9f\u00e9rer \u00e9crire <code>sizeof t[0]</code> plut\u00f4t que <code>sizeof *t</code> : \u00e7a revient au m\u00eame.</p> <p>Mais lorsqu'on passe <code>t</code> en param\u00e8tre de la fonction <code>tailletab</code> , on trouve que la taille de <code>t</code> est \\(2\\) bytes.</p> <p>Que s'est-il pass\u00e9 ?</p> <p>Les arguments sont transmis par valeurs en C. Ce qui fait qu'une fonction travaille en fait avec des copies des arguments.</p> <p>Dans le cas particulier d'un tableau pass\u00e9 en argument d'une fonction, celle-ci travaille en fait avec un pointeur sur le premier \u00e9l\u00e9ment\\(^{2.}\\).</p> <p>Remarque</p> <p>\\(\\color{blue}2.\\) Les autres \u00e9l\u00e9ments du tableau (mais pas leur nombre) sont accessibles dans la fonction car ils occupent des     positions contigu\u00ebs en m\u00e9moire</p> <p>Dans l'appel <code>tailletab(t)</code>, <code>t</code> est donc un objet de type <code>int*</code> , un pointeur sur <code>t[0]</code>. La taille d'un pointeur (donc d'une adresse) est \\(8\\) bytes. Ainsi la taille calcul\u00e9e est :</p> <pre><code>taille de int\u2217 / taille de t[0]\n</code></pre> <p>soit \\(8/4\\) donc \\(2\\) bytes.</p> <p>Il n'est donc JAMAIS possible de transmettre \u00e0 une fonction tous les \u00e9l\u00e9ments d'un tableau et donc d'en conna\u00eetre la taille.</p> <p>On retient \u2665</p> <p>On peut obtenir la dimension d'un tableau <code>t</code> dans le bloc o\u00f9 il a \u00e9t\u00e9 d\u00e9clar\u00e9 en calculant le quotient :</p> <pre><code>sizeof t / sizeof t[0]\n</code></pre> <p>Attention</p> <p>Dans le bloc de d\u00e9claration, <code>sizeof t</code> d\u00e9signe bien le nombre de bytes occup\u00e9s par le tableau (il est connu du compilateur).</p> <p>Mais cette m\u00e9thode ne fonctionne plus lorsque le tableau est pass\u00e9 en argument d'une fonction.</p> <p>Cette derni\u00e8re travaille en fait non avec <code>t</code> , mais avec un pointeur sur son premier \u00e9l\u00e9ment. Ainsi <code>sizeof t</code> d\u00e9signe la taille d'une adresse, laquelle est une quantit\u00e9 fixe.</p>"},{"location":"C/08-Pointeurs/","title":"Les pointeurs","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Ce cours de OpenClassRoom (Renvoie sur une page vide  \u00af\\(\u30c4)/\u00af )</li> <li>Un autre de Zeste de savoir</li> <li>Un cours d'Anne Canteaut</li> <li>Et toujours Wikipedia</li> </ul>"},{"location":"C/08-Pointeurs/#pointeurs","title":"Pointeurs","text":""},{"location":"C/08-Pointeurs/#acces-a-la-memoire","title":"Acc\u00e8s \u00e0 la m\u00e9moire","text":"<ul> <li>Un entier naturel cod\u00e9 en binaire peut-\u00eatre vu comme :<ul> <li>ce qu'il est : un nombre destin\u00e9 par exemple \u00e0 faire l'objet d'op\u00e9rations arithm\u00e9tiques,</li> <li>une adresse m\u00e9moire. Dans ce cas l'utilisation arithm\u00e9tique du nombre n'est pas ce qui nous int\u00e9resse.</li> </ul> </li> <li>Dans les processeurs ont donc \u00e9t\u00e9 cr\u00e9\u00e9s des registres d'adresses et dans les langages de programmation, un type d\u00e9di\u00e9.</li> <li>Pointeurs : Apparus dans \\(\\texttt{Aigol 68}\\). Le langage \\(\\texttt{C}\\) y a ajout\u00e9 l'arithm\u00e9tique des pointeurs : quand on incr\u00e9mente un tel pointeur, il n'est en fait pas forc\u00e9ment incr\u00e9ment\u00e9 de un, mais de la taille du type point\u00e9. Cette arithm\u00e9tique (hors programme) permet donc de se d\u00e9placer dans la m\u00e9moire.</li> <li>L'utilisation des pointeurs permet d'avoir acc\u00e8s \u00e0 la m\u00e9moire. On peut se d\u00e9placer de case m\u00e9moire en case m\u00e9moire. Avantage : optimisations sur l'utilisation de la m\u00e9moire ou la performance.</li> </ul>"},{"location":"C/08-Pointeurs/#syntaxe","title":"Syntaxe","text":""},{"location":"C/08-Pointeurs/#declaration","title":"D\u00e9claration","text":"<ul> <li>Syntaxe :</li> </ul> <pre><code>1 type *nom du pointeur;\n</code></pre> <ul> <li>L'ast\u00e9risque peut \u00eatre entour\u00e9e d'espaces et plac\u00e9e n'importe o\u00f9 entre le type et l'identificateur.</li> </ul> <pre><code>int *ptr ; //autoris\u00e9\nint *ptr ; //autoris\u00e9\nint *ptr ; //autoris\u00e9\n</code></pre>"},{"location":"C/08-Pointeurs/#initialisation","title":"Initialisation","text":"<ul> <li>Comme les autres variables, un pointeur ne poss\u00e8de pas de valeur par d\u00e9faut. pour lui en attribuer une, on utilise l'op\u00e9rateur d'adressage (ou de r\u00e9f\u00e9rencement) <code>&amp;</code>.</li> <li>D\u00e9claration puis affectation</li> </ul> <pre><code>int a = 10;\nint *p;\np = &amp;a;\n</code></pre> <ul> <li>D\u00e9claration et affectation dans la foul\u00e9e</li> </ul> <pre><code>int a = 10;\nint *p = &amp;a;\n</code></pre> <ul> <li>Savoir faire : d\u00e9claration et initialisation d'un pointeur dans un type donn\u00e9 \u2665</li> </ul>"},{"location":"C/08-Pointeurs/#affichage-des-adresses","title":"Affichage des adresses","text":"<p>Avec :</p> <pre><code>int a =10;\nint *p = &amp;a;\nprintf (\"a=%d, &amp;a=%p, &amp;p=%p\\n\", *p, p, &amp;p);\n</code></pre> <p>On obtient :</p> Rendu<pre><code>a=10, &amp;a=0x7ffc7aaa612c, &amp;p=0x7ffc7aaa6130\n</code></pre> nom adresse valeur \\(p\\) \\(\\text{0x7ffc7aaa6130}\\) \\(\\text{0x7ffc7aaa612c}\\) ... \\(a\\) \\(\\text{0x7ffc7aaa612c}\\) \\(10\\)"},{"location":"C/08-Pointeurs/#indirection","title":"Indirection \u2665","text":"<p>L'op\u00e9rateur d'indirection (ou de d\u00e9r\u00e9f\u00e9rencement) <code>*</code> prend un pointeur comme op\u00e9rande et se place juste avant celui-ci. On acc\u00e8de ainsi \u00e0 la valeur de l'objet r\u00e9f\u00e9renc\u00e9 par le pointeur, aussi bien pour la lire que pour la modifier.</p> <pre><code>int a = 3;\nint *p = &amp;a;// '*' sert \u00e0 la d\u00e9claration\nprintf (\"a=%d\\n\", *p);// '*' sert au d\u00e9r\u00e9f\u00e9rencement\n*p = 20;// '*' sert au d\u00e9r\u00e9f\u00e9rencement\nprintf (\"a=%d\\n\", a);// a a \u00e9t\u00e9 modifi\u00e9\n</code></pre> <p>On obtient</p> Rendu<pre><code>a=3\na=20\n</code></pre>"},{"location":"C/08-Pointeurs/#les-differentes-casquettes-de","title":"Les diff\u00e9rentes casquettes de <code>*</code>","text":"<p>L'op\u00e9rateur <code>*</code> sert au moins \u00e0 trois choses distinctes :</p> <ul> <li>\u00e0 la d\u00e9claration de pointeurs : <code>int *p = &amp;i</code>;</li> <li>Au d\u00e9r\u00e9f\u00e9rencement : <code>*p=20; // i prend la valeur 20</code></li> <li>\u00e0 la multiplication <code>3*5</code>;</li> </ul>"},{"location":"C/08-Pointeurs/#pointeurs-et-constantes","title":"Pointeurs et constantes","text":"<p>Pour info :</p> <ul> <li>La r\u00e8gle du mot-cl\u00e9 const est qu'il s'applique sur ce qui est imm\u00e9diatement \u00e0 sa gauche, et que s'il n'y a rien \u00e0 gauche alors \u00e7a s'applique sur l'\u00e9l\u00e9ment imm\u00e9diatement \u00e0 droite</li> <li>Un pointeur peut \u00eatre d\u00e9clar\u00e9 constant :</li> </ul> <pre><code>int *const ptr ; /*Un pointeur constant sur int. non ct */\n</code></pre> <p>L'\u00e9toile est entre le type et le mot cl\u00e9 <code>const</code></p> <ul> <li>Un pointeur peut pointer sur une constante</li> </ul> <pre><code>int const *ptr ; /*Pointeur sur int constant. */\n</code></pre> <p>L'\u00e9toile est entre le mot cl\u00e9 <code>const</code> et le nom du pointeur</p> <ul> <li>Pointeur constant sur objet constant.</li> </ul> <pre><code>int const *const ptr ; /*Pointeur constant sur int ct . */\nconst int *const ptr ; /*Pointeur ct sur int ct . */\n</code></pre>"},{"location":"C/08-Pointeurs/#piege-a-la-declaration","title":"Pi\u00e8ge \u00e0 la d\u00e9claration","text":"<ul> <li>On l'a vu <code>int* p;</code> et <code>int *p;</code> sont compris de la m\u00eame fa\u00e7on par le compilateur.</li> <li><code>int *p;</code> permet au lecteur de savoir que <code>*p</code> est un entier. La forme avec l'\u00e9toile coll\u00e9e au nom est pr\u00e9f\u00e9rable.</li> <li><code>int* x,y</code>; ne d\u00e9clare pas deux pointeurs sur entier mais un pointeur sur entier et un entier. On le comprend mieux en \u00e9crivant <code>int *x,y;</code></li> </ul>"},{"location":"C/08-Pointeurs/#utilite","title":"Utilit\u00e9","text":""},{"location":"C/08-Pointeurs/#utilite_1","title":"Utilit\u00e9\u2665","text":"<ul> <li>On peut utiliser les pointeurs pour faire des effets de bords en les passant en param\u00e8tres de fonctions. Ex : passer un pointeur sur une variable x en param\u00e8tre de f , permet d'avoir acc\u00e8s au contenu de x et donc de le modifier (voir \\(2\\) slides suivants).</li> <li>Les pointeurs sont une des fa\u00e7ons de contourner l'obligation qu'une fonction \\(\\texttt{C}\\) ne renvoie qu'une seule valeur. L'autre fa\u00e7on courante \u00e9tant l'utilisation de structure (ou enregistrement).</li> <li>On peut les utiliser aussi pour stocker des adresses m\u00e9moires allou\u00e9es dynamiquement (i.e. au run time) par l'application.</li> </ul>"},{"location":"C/08-Pointeurs/#consequence-du-passage-par-valeur","title":"Cons\u00e9quence du passage par valeur","text":"<pre><code>int incremente( int y){\n    y = y+1;\n    return y;\n}\nint main(){\n    int y =3;\n    printf (\"y=%d,incremente(y)=%d\", y,incremente(y));\n    printf (\"; y=%d\\n\",y);\n    return 0;\n}\n</code></pre> Rendu<pre><code>y=3,incremente(y)=4; y=3\n</code></pre> <ul> <li>Le contenu de la variable y de main n'a pas \u00e9t\u00e9 modifi\u00e9 par l'appel de incremente. On dit que le passage de l'argument se fait par valeur, ce qui signifie que c'est une copie de y qui est pass\u00e9e en param\u00e8tre de la fonction. Pour changer y on utilisera son adresse, c'est \u00e0 dire un pointeur.</li> </ul> <pre><code>int incremente(int *y){\n    *y = *y+1;\n}\nint main(){\n    int y =3;\n    printf (\"y=%d\\n\", y);\n    incremente(&amp;y);\n    printf (\"Arp\u00e8s incremente(y) : y=%d\\n\",y);\n    return 0;\n}\n</code></pre> <p>Apr\u00e8s compilation/ex\u00e9cution :</p> Rendu<pre><code>$./a.out$\ny=3\nApr\u00e8s incremente(y) : y=4\n</code></pre>"},{"location":"C/08-Pointeurs/#pointeurs-dans-dautres-langages","title":"Pointeurs dans d'autres langages","text":"<ul> <li>Dans les langages de plus haut niveau (ex : \\(\\texttt{OCAML}\\)), l'utilisation des pointeurs est supprim\u00e9e, au profit des r\u00e9f\u00e9rences et des tableaux dynamiques g\u00e9r\u00e9s par le compilateur.</li> <li>On y gagne en simplicit\u00e9, on \u00e9vite de nombreux bugs mais on perd certaines possibilit\u00e9s d'optimisation.</li> </ul>"},{"location":"C/08-Pointeurs/#retourner-plusieurs-valeurs","title":"\u00ab Retourner \u00bb plusieurs valeurs","text":""},{"location":"C/08-Pointeurs/#passage-de-pointeurs-en-parametres","title":"Passage de pointeurs en param\u00e8tres","text":"<ul> <li>On contourne l'obligation faite aux fonctions C de ne retourner qu'une seule valeur.</li> </ul> <p>On veut appliquer \u00e0 un point une translation de vecteur donn\u00e9 et r\u00e9cup\u00e9rer le r\u00e9sultat.</p> <ul> <li>On ne peut pas retourner un tuple de coordon\u00e9es comme en \\(\\texttt{Python}\\) au \\(\\texttt{OCaml}\\).</li> <li>Solution : utiliser des pointeurs sur les coordonn\u00e9es du r\u00e9sultat.</li> </ul> <pre><code>void translate (double x, double y, double vx, double vy,\n        double *rx, double *ry)\n</code></pre> <p>applique une translation de vecteur \\(V (v_x,v_y)\\) \u00e0 un point \\(A(x ,y )\\) et met les coordonn\u00e9es du r\u00e9sultat \\(R(r_x,r_y)\\) dans deux variables. Les coordonn\u00e9es de \\(A\\) et \\(V\\) sont pass\u00e9es en param\u00e8tres. Pour le r\u00e9sultat, ce sont adresses de ses coordonn\u00e9es qui sont pass\u00e9es en param\u00e8tres.</p> <pre><code>void translate (double x, double y, double vx, double vy,\n        double *rx, double *ry){\n    // translation de vecteur V(vx,vy)\n    *rx = x + vx;\n    *ry = y + vy;\n}// fin translate\n\nint main(void){\n    double x = 3, y = 6;// coordonn\u00e9es du point A(x,y)\n    double rx , ry ; // r\u00e9 sultat de la translation\n    translate (x , y,1,2,&amp; rx,&amp;ry) ; // translater A de (1,2)\n    printf (\"rx=%.1f ry=%.1f\\n\",rx,ry);\n    return EXIT SUCCESS;\n} // fin main\n</code></pre> <p>On obtient</p> Rendu<pre><code>x=4.0 y=8.0\n</code></pre>"},{"location":"C/08-Pointeurs/#pointeur-textnull-mot-cle-textvoid","title":"Pointeur \\(\\text{NULL}\\), mot cl\u00e9 \\(\\text{void}\\)","text":""},{"location":"C/08-Pointeurs/#pointeur-nul","title":"Pointeur nul","text":"<ul> <li>Un pointeur nul est un pointeur contenant une adresse invalide. Cette adresse invalide d\u00e9pend du syst\u00e8me d'exploitation, mais elle est la m\u00eame pour tous les pointeurs nuls. Ainsi, deux pointeurs nuls ont une valeur \u00e9gale.</li> <li>La constante <code>NULL</code> est d\u00e9finie dans l'en-t\u00eate <code>&lt;stddef.h&gt;</code></li> </ul> <pre><code>int *p = NULL; /*Un pointeur nul */\n</code></pre> <ul> <li>Le pointeur <code>NULL</code> est souvent utilis\u00e9 comme marqueur de fin dans une structure d\u00e9finie r\u00e9cursivement (exemple : listes cha\u00een\u00e9es).</li> <li>Il sert aussi \u00e0 indiquer que quelque chose s'est mal pass\u00e9 (ex <code>malloc</code>)</li> </ul>"},{"location":"C/08-Pointeurs/#le-mot-cle-void","title":"Le mot cl\u00e9 <code>void</code>","text":"<ul> <li><code>void</code> n'est pas un type, c'est un mot cl\u00e9. Plus pr\u00e9cis\u00e9ment, c'est un type dit \u00ab incomplet \u00bb , c'est \u00e0 dire que sa taille n'est pas calculable et qu'il n'est pas utilisable dans des expressions.</li> <li>On l'utilise pour d\u00e9clarer qu'une fonction ne renvoie pas de valeur : <code>void f(int x)</code></li> <li>Pour les fonctions sans argument, pr\u00e9ferer <code>int f(void)</code> (qui signifie explicitement que <code>f</code> ne prend pas d'argument) \u00e0 <code>int f()</code> qui indique que le nombre d'arguments de <code>f</code> n'est pas connu.</li> <li><code>void *</code> d\u00e9signe un pointeur vers une valeur dont on ne conna\u00eet pas le type (c'est un pointeur g\u00e9n\u00e9rique). Un pointeur sur <code>void</code> est consid\u00e9r\u00e9 comme un pointeur g\u00e9n\u00e9rique : il peut r\u00e9f\u00e9rencer n'importe quel type.</li> </ul> <pre><code>void *malloc( size t memorySize );//prototype de malloc\n</code></pre> <ul> <li>Les r\u00e8gles de typage du \\(\\texttt{C}\\) permettent d'utiliser <code>void*</code> l\u00e0 o\u00f9 une valeur d'un certain type de pointeur est attendu. On peut donc \u00e9crire</li> </ul> <pre><code>int *p = malloc( siezof ( int )) ; // alocation d'un pointeur sur le tas.\n</code></pre> <ul> <li>Enfin <code>void *</code> permet le polymorphisme. Exemple : une fonction qui agit sur un tableau dont les \u00e9l\u00e9ments sont de type quelconque. Nous n'utilisons pas cette fonctionnalit\u00e9.</li> <li>Le sp\u00e9cifieur de format <code>%p</code> de <code>printf</code> attend un pointeur sur n'importe quel type et affiche sa valeur (donc une adresse), que le pointeur pointe sur un objet de type <code>int, double, char...</code></li> </ul> <pre><code>int a =10;\nint *p= &amp;a;\nprintf (\"adresse=\\%p\",p); // affichage d'une adresse\n</code></pre>"},{"location":"C/08-Pointeurs/#valeur-de-retour","title":"Valeur de retour","text":""},{"location":"C/08-Pointeurs/#pointeur-comme-valeur-retournee","title":"Pointeur comme valeur retourn\u00e9e","text":"<ul> <li>Une fonction peut retourner un pointeur.</li> <li>Cependant : l'objet r\u00e9f\u00e9renc\u00e9 par le pointeur retourn\u00e9 doit toujours exister au moment de son utilisation.</li> <li>Il faut se poser la question :<ul> <li>l'adresse retourn\u00e9e est-elle celle d'une variable locale \u00e0 la fonction (donc g\u00e9r\u00e9e automatiquement dans la pile d'ex\u00e9cution) ? Si c'est le cas, cette adresse peut servir dans d'autres contextes d'ex\u00e9cution et son contenu risque d'\u00e9chapper au programmeur distrait.</li> <li>l'adresse retourn\u00e9e d\u00e9signe-t-elle une zone m\u00e9moire allou\u00e9e sur le tas ? Si c'est le cas, il faut bien penser \u00e0 la lib\u00e9rer par la suite.</li> </ul> </li> </ul> <pre><code>int *ptr(void){ // retourne un pointeur sur int\n    int n;\n    return &amp;n;\n}\nint main(void){\n    int *p = ptr() ;\n    *p = 10;\n    printf (\"%d\\n\", *p);\n    return 0;\n}\n</code></pre> <p>On obtient</p> Rendu<pre><code>$./a.out\nErreur de segmentation (core dumped)\n</code></pre> <ul> <li>Le probl\u00e8me vient de la ligne</li> </ul> <pre><code>int n; // dans ptr ()\n</code></pre> <ul> <li>Les variables locales comme <code>n</code> de <code>ptr</code> se voient allouer un emplacement en m\u00e9moire de fa\u00e7on dynamique lors de l'ex\u00e9cution du programme. Le segment de m\u00e9moire dans lequel sont stock\u00e9es les variables temporaires est appel\u00e9 segment de pile</li> <li>Leur emplacement en m\u00e9moire est lib\u00e9r\u00e9 \u00e0 la fin de l'ex\u00e9cution d'une fonction secondaire comme <code>ptr</code>.</li> <li>Donc la fonction ptr renvoie une adresse qui n'est plus pertinente et qui sera utilis\u00e9e par d'autres appels \u00e0 d'autres fonctions. On dit que c'est un pointeur fant\u00f4me</li> </ul>"},{"location":"C/08-Pointeurs/#mot-cle-static","title":"Mot cl\u00e9 static","text":"<ul> <li>On modifie juste la ligne \\(3\\) du code pr\u00e9c\u00e9dent :</li> </ul> <pre><code>static int n;// dans ptr\n</code></pre> <p>On obtient</p> Rendu<pre><code>$./a.out\n10\n</code></pre> <ul> <li>Une variable locale d\u00e9clar\u00e9e <code>static</code> occupe toujours la m\u00eame adresse en m\u00e9moire \u00e0 chaque appel de la fonction. On verra plus tard que la partie de la m\u00e9moire (allou\u00e9e au programme) qui contient les variables statiques (comme d'ailleurs les variables globales) est appel\u00e9e segment de donn\u00e9es.</li> <li>Cette solution n'est pas d'un grand int\u00e9r\u00eat sauf si on a absolument besoin que l'adresse retourn\u00e9e soit toujours la m\u00eame ! On pr\u00e9f\u00e8re l'allocation dynamique (voir plus loin).</li> </ul>"},{"location":"C/08-Pointeurs/#pointeur-sur-pointeur","title":"Pointeur sur pointeur","text":"<ul> <li>Un pointeur p a une adresse qu'on r\u00e9cup\u00e8re avec <code>&amp;p</code></li> <li>Dans le <code>main</code>, \u00e9crivons :</li> </ul> <pre><code>int a = 10;\nint *pa = &amp;a;// pointeur sur int\nint **pp = &amp;pa;// pointeur sur pointeur sur int\nprintf (\"a =%d,*pa=%d,**pp=%d\\n\", a,*pa,**pp);\nprintf (\"pa=%p,*pp=%p\\n\",pa,*pp);\n</code></pre> <ul> <li>Avec <code>*pp</code> on r\u00e9cup\u00e8re l'adresse de a et avec <code>**pp</code> , la valeur de a.</li> <li>Apr\u00e8s compilation/ex\u00e9cution :</li> </ul> Rendu<pre><code>$./a.out\na =10,*pa=10,**pp=10\npa=0x7ffc67074a04,*pp=0x7ffc67074a04\n</code></pre>"},{"location":"C/08-Pointeurs/#dangers","title":"Dangers","text":""},{"location":"C/08-Pointeurs/#complexification-du-code","title":"Complexification du code","text":"<ul> <li>Tr\u00e8s puissante, l'utilisation de pointeurs rend plus difficile le travail du d\u00e9veloppeur.</li> <li>\u2665 Si on ne fait pas attention avec les pointeurs, le programme peut acc\u00e9der \u00e0 une zone m\u00e9moire qui ne lui est pas allou\u00e9e ou dans laquelle il ne peut pas \u00e9crire. Le processeur via le syst\u00e8me d'exploitation engendre alors une erreur de segmentation (segmentation fault) qui provoque une exception voire plante l'application.</li> <li>\u2665 Si c'est le programmeur qui g\u00e8re les allocations en m\u00e9moire, il ne doit pas oublier de lib\u00e9rer apr\u00e8s usage la zone allou\u00e9e sous peine de fuite de m\u00e9moire : Il s'agit d'un bug qui r\u00e9sulte d'une occupation croissante non contr\u00f4l\u00e9s ou non d\u00e9sir\u00e9e de la m\u00e9moire. DANGER : saturation possible de la RAM.</li> </ul>"},{"location":"C/08-Pointeurs/#un-exemple-de-segmentation-fault","title":"Un exemple de segmentation fault","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;// contient EXIT SUCCESS\n\nint main(){\n    int *variable entiere ; // d\u00e9 claration d'un pointeur\n    printf (\" saisir une valeur : \") ;\n    scanf (\"%d\", variable entiere ) ;\n    return (EXIT SUCCESS);// indique que tout s'est bien pass\u00e9\n}\n</code></pre> Rendu<pre><code>$./a.out\nentrer une valeur : 23\nErreur de segmentation (core dumped)\n</code></pre> <ul> <li>Explication : le pointeur <code>variable_entiere</code> n'est pas initialis\u00e9 donc contient n'importe quoi (possiblement, une adresse interdite en \u00e9criture). Quand <code>scanf</code> veut acc\u00e8der \u00e0 cette adresse l'OS le lui refuse.</li> </ul>"},{"location":"C/08-Pointeurs/#allocation-dynamique","title":"Allocation dynamique","text":""},{"location":"C/08-Pointeurs/#allouer-de-la-memoire","title":"Allouer de la m\u00e9moire \u2665","text":"<p>Trois mani\u00e8res pour l'allocation de m\u00e9moire dans un programme :</p> <ul> <li>Statiquement, au cours de la compilation lorsque le compilateur lit des mots cl\u00e9s comme <code>const</code> ou <code>static</code> dans le code source. Adresses m\u00e9moires connues \u00e0 l'initialisation de la m\u00e9moire du programme. Ces adresses correspondent \u00e0 ce qu'on appelle le segment de donn\u00e9es du programme.</li> <li>Dynamiquement, au cours de l'ex\u00e9cution :<ul> <li>soit de fa\u00e7on automatique sur la pile d'ex\u00e9cution : variables locales d\u00e9clar\u00e9es dans un bloc d'instructions,</li> <li>soit \u00e0 la demande sur le tas : en utilisant des fonctions d'allocation de la m\u00e9moire.</li> </ul> </li> <li>Il y a donc trois zones de donn\u00e9es distinctes pour le programme. On affinera leur description dans un cours \u00e0 venir.</li> </ul> segment de donn\u00e9es var. globales ou var. locales statiques pile d'ex\u00e9cution var. locales tas allocation dynamique par <code>malloc</code>"},{"location":"C/08-Pointeurs/#allouer-de-lespace","title":"Allouer de l'espace","text":"<ul> <li>Un pointeur non initialis\u00e9 est \u00e9gal \u00e0 la constante symbolique <code>NULL</code> de <code>&lt;stddef.h&gt;</code>. Le test <code>p == NULL</code> permet de savoir si le pointeur \\(p\\) pointe vers un objet.</li> <li>On a vu comment initialiser un pointeur en lui affectant l'adresse d'une autre variable <code>int * p =&amp;a</code>;</li> <li>Pour affecter directement une valeur \u00e0 <code>*p</code>, il faut d'abord r\u00e9server \u00e0 <code>*p</code> un espace-m\u00e9moire de taille ad\u00e9quate avec <code>malloc</code> de <code>&lt;stdlib.h&gt;</code>.</li> <li>L'adresse de cet espace-m\u00e9moire est la valeur de <code>p</code></li> <li>Cette op\u00e9ration est appel\u00e9e allocation dynamique</li> </ul>"},{"location":"C/08-Pointeurs/#la-fonction-malloc","title":"La fonction <code>malloc</code>","text":"<ul> <li>Syntaxe</li> </ul> <pre><code>void* malloc( size t size ) ; // allocation en nb de bytes\n</code></pre> <ul> <li>La valeur retourn\u00e9e est l'adresse du premier octet de la zone m\u00e9moire allou\u00e9e. Si l'allocation n'a pu se r\u00e9aliser (par manque de m\u00e9moire libre), la valeur de retour est la constante NULL.</li> <li>Toute utilisation de <code>malloc</code> doit \u00eatre suivie plus tard d'une lib\u00e9ration de l'espace r\u00e9serv\u00e9</li> </ul> <pre><code>void free (void *ptr) ;\n</code></pre> <p>Le seul param\u00e8tre \u00e0 passer est l'adresse du premier octet de la zone allou\u00e9e et aucune valeur n'est retourn\u00e9e une fois cette op\u00e9ration r\u00e9alis\u00e9e.</p> <p>Exemple \u2665</p> <ul> <li>R\u00e9server \\(32\\) octets et les lib\u00e9rer imm\u00e9diatement.</li> </ul> <pre><code>#include &lt;stdlib.h&gt;// tir\u00e9 de Wikipedia\nint main(){\n    int *pointeur = malloc(8 * sizeof(int)) ; //8x4 octets\n\n    if (pointeur == NULL)\n        printf(\"L' allocation n'a pu \u00ea tre r\u00e9 alis \u00e9e\\n\");\n    else {\n        printf(\" allocation : succ\u00e8s\\n\") ;\n        printf(\" valeur de p=%p\\n\",p);\n        free(pointeur) ; //Lib\u00e9ration des 32 octets\n        pointeur = NULL; // Invalidation du pointeur\n    }...\n}\n</code></pre> Rendu<pre><code>allocation : succ\u00e8s; valeur de pointeur=0x55fb8de5f260\n</code></pre>"},{"location":"C/08-Pointeurs/#allocation-dynamique-vs-automatique","title":"Allocation dynamique vs automatique \u2665","text":"<pre><code>int i = 3;\nint *p;\n\np = (int*)malloc( sizeof ( int )) ; // alloc . dyn. sur le tas\n*p = i ; // attention : p ne pointe pas sur i\n\nint *r=&amp;i;// alloc . auto. sur la pile\n\nprintf (\" i =%d,*p=%d, *r=%d\\n\",i,*p,*r);\nprintf (\"p=%p, r=%p\\n\",p,r);\n\nfree (p) ;\n</code></pre> <p><code>p</code> ne pointe pas sur <code>i</code> mais <code>r</code> si. Modifier <code>*p</code> ne modifie pas <code>i</code>, mais modifier <code>*r</code> modifie <code>i</code></p>"},{"location":"C/08-Pointeurs/#assertions-rappel","title":"Assertions (rappel)","text":"<p>Pour diverses raisons on peut souhaiter interrompre un programme si une condition n'est pas r\u00e9alis\u00e9e (ex : impossibilit\u00e9 d'allouer de la m\u00e9moire). Les assertions sont alors utiles.</p> <p>Exemple d'assertion</p> <pre><code>#include &lt;assert.h&gt;\n\nint main(){\n    int i = 0; // on veut imposer i &gt; 1\n    assert (i &gt; 1); // si i &lt;= 1 : arr\u00eat du pgm\n    printf(\"poursuite du pgm\");\n    return 0;\n}\n</code></pre> <p>Trace d'ex\u00e9cution :</p> Rendu<pre><code>a.out: assertion2.c:8: main: Assertion \u2018i &gt;1\u2018 failed.\nAbandon (core dumped}\n</code></pre> <ul> <li>On la vu que les assertions servent \u00e0 se prot\u00e9ger d'un comportement aberrant en arr\u00eatant le programmme.</li> <li>Elles servent aussi en phase de conception d'un programme :<ul> <li>Il faut en effet compiler r\u00e9guli\u00e8rement (d\u00e8s qu'on ajoute un bloc d'instructions ?)</li> <li>Si l'\u00e9criture du programme n'est pas encore termin\u00e9e : ajouter des assertions dans les branches non \u00e9crites des instructions conditionnelles. Cela permet de compiler (donc de v\u00e9rifier la syntaxe) et de tester les branches compl\u00e9t\u00e9es.</li> </ul> </li> </ul> <pre><code>int f ( int x){\n    assert (x&gt;0);// on quitte le pgm si x&lt;=0\n    // bloc de code compl\u00e8tement \u00e9crit\n    // ne concernant que x&gt;0 et \u00e0 tester\n    ...\n    return NimporteQuoi;\n}\n</code></pre>"},{"location":"C/08-Pointeurs/#assertion-et-bon-fonctionnement-dune-allocation","title":"Assertion et bon fonctionnement d'une allocation","text":""},{"location":"C/08-Pointeurs/#exemple-dassertion","title":"Exemple d'assertion","text":"<ul> <li>Pour diverses raisons, l'allocation dynamique peut \u00e9chouer. Le pointeur est alors \u00e9gal au pointeur <code>NULL</code>. On devrait toujours tester si l'allocation s'est bien d\u00e9roul\u00e9e.</li> <li>Il est plus prudent d'arr\u00eater l'ex\u00e9cution du programme en cas d'\u00e9chec d'allocation. On peut utiliser une assertion.</li> </ul> <pre><code>int t [3] = {1.,2.,3.};\nint *copy = NULL;// on veut copier t dans copy\n\n/*Allocation de la m\u00e9moire */\ncopy = (int *) malloc( 3 *sizeof ( int ) ) ;\nassert ( copy != NULL ); // si \u00e9chec, arr \u00ea ter le pgm\n</code></pre>"},{"location":"C/08-Pointeurs/#hors-programme","title":"(Hors programme)","text":""},{"location":"C/08-Pointeurs/#arithmetique-des-pointeurs","title":"Arithm\u00e9tique des pointeurs","text":"<p>Les op\u00e9rations valides sur les pointeurs sont :</p> <ul> <li>l'addition d'un entier \u00e0 un pointeur. Le r\u00e9sultat est un pointeur de m\u00eame type que le pointeur de d\u00e9part;</li> <li>la soustraction d'un entier \u00e0 un pointeur. Le r\u00e9sultat est un pointeur de m\u00eame type que le pointeur de d\u00e9part;</li> <li>la diff\u00e9rence de deux pointeurs pointant tous deux vers des objets de m\u00eame type. Le r\u00e9sultat est un entier.</li> </ul> <pre><code>int main(){\n    int i = 3;\n    int *p1, *p2;\n    p1 = &amp;i;\n    p2 = p1 + 1;\n    printf (\"p1 = %p \\t p2 = %p \\t p2\u2212p1=%ld\\n\",p1,p2,p2\u2212p1);\n    return 0;\n}\n</code></pre> <p>On obtient</p> Rendu<pre><code>p1 = 0x7fff37e6dc34 p2 = 0x7fff37e6dc38 p2\u2212p1=1\n</code></pre> <p>La diff\u00e9rence entre les adresses est \\(4\\), c'est \u00e0 dire la taille d'un <code>int</code>. l'expression <code>p2 - p1</code> d\u00e9signe en fait un entier dont la valeur est \u00e9gale \u00e0 <code>(p2 - p1)/sizeof(int)</code>.</p> <pre><code>int main(){\n    double i = 3.;\n    double *p1, *p2;\n    p1 = &amp;i;\n    p2 = p1 \u2212 1;\n    printf (\"p1 = %p \\t p2 = %p \\t p2\u2212p1=%ld\\n\",p1,p2,p2\u2212p1);\n    return 0;}\n</code></pre> <p>On obtient</p> Rendu<pre><code>$./a.out\np1 = 0x7ffcadcfc8e0 p2 = 0x7ffcadcfc8d8 p2\u2212p1=\u22121\n</code></pre> <p>La diff\u00e9rence entre les adresses est</p> <p>\\(e0_{16} \u2212d8_{16} = 14_{10} \u00d716_{10} + 0 \u2212(13_{10} \u00d716_{10} + 8_{10}) = 8_{10}\\)</p> <p>C'est la taille d'un <code>double</code></p>"},{"location":"C/08-Pointeurs/#pointeur-et-tableaux","title":"Pointeur et tableaux","text":""},{"location":"C/08-Pointeurs/#tableaux","title":"Tableaux \u2665","text":"<p>(Rappel)</p> <ul> <li>D\u00e9claration de tableaux :</li> </ul> <pre><code>//type nomDuTableau[taille] ;\nint tableau [4] ; // tableau de 4 entiers\n</code></pre> <p>D\u00e9claration et initialisation :</p> <pre><code>int tableau [4] = {1,2,3,4}; // les 4 elts de tab sont initialis \u00e9s\nfloat tib [5] = {1.1,2.1}// seuls 2 elts de tib sont initialis \u00e9s\n</code></pre> <p>Acc\u00e8s aux \u00e9l\u00e9ments comme en Python avec <code>tab[i]</code></p> <pre><code>tab [1] = 23;// l'elt 1 de tab vaut 23\nprintf (\"tab[%d]=%d\",1,tab[1]);\n</code></pre>"},{"location":"C/08-Pointeurs/#acces-aux-elements-dun-tableau","title":"Acc\u00e8s aux \u00e9l\u00e9ments d'un tableau","text":"<p>(Rappel) Consid\u00e9rons <code>int tab[2]</code>;</p> <ul> <li>Un nom de tableau comme tab d\u00e9signe, apr\u00e8s d\u00e9claration, par convention un pointeur constant sur le premier bloc de son premier \u00e9l\u00e9ment.</li> <li>On peut utiliser un pointeur initialis\u00e9 \u00e0 <code>tab</code> pour parcourir les \u00e9l\u00e9ments du tableau par arithm\u00e9tique des pointeurs (hors programme en CPGE).</li> <li>Pour acc\u00e9der \u00e0 <code>tab[2]</code>, le syst\u00e8me ajoute \u00e0 l'adresse du (premier bloc) de <code>tab[0]</code> le produit \\(2*4\\)<ul> <li>le nombre \\(2\\) pour la position dans le tableau,</li> <li>le nombre \\(4\\) pour la taille d'un <code>int</code> (\\(4\\) octets / <code>int</code>).</li> </ul> </li> </ul>"},{"location":"C/08-Pointeurs/#passage-dun-tableau-en-parametre-dune-fonction","title":"Passage d'un tableau en param\u00e8tre d'une fonction \u2665","text":"<p>(Rappel)</p> <ul> <li>La fonction ci-dessous affiche les \u00e9l\u00e9ments d'un tableau</li> </ul> <pre><code>void affiche ( int *tableau , int tailleTableau ){\n    for (int i = 0; i &lt; tailleTableau; i ++)\n        printf (\"%d\\n\", tab[i ]) ;\n}\n</code></pre> <ul> <li>Les tableaux sont en fait pass\u00e9s en param\u00e8tre comme des copies de pointeur sur leur \\(1\\)er \u00e9l\u00e9ment.</li> </ul> <p>Exemple de main</p> <pre><code>int main(){\n    int tab [4] = {1, 2, \u221212};\n    // afficher le contenu du tableau\n    affiche (tab , 4) ;\n    return 0;\n}\n</code></pre>"},{"location":"C/08-Pointeurs/#notion-de-lvalue","title":"Notion de lvalue","text":"<ul> <li>Une lvalue (left value) est une expression d\u00e9signant un objet modifiable.</li> <li>Les expressions qui sont des lvalue :<ul> <li>identificateur de variable :<ul> <li>N'ayant pas re\u00e7u le qualifieur <code>const</code></li> <li>Autre qu'un nom de tableau</li> <li>dans le cas d'une variable de type structure ou union, celle-ci ne doit pas comporter de champs constant.</li> </ul> </li> <li>Expression de la forme <code>*p</code> ou <code>*(adr)</code> : <code>p</code> (resp. <code>adr</code>) \u00e9tant une variable (resp.expression) de type pointeur sur un objet non constant.</li> <li>\u00e9l\u00e9ment de tableau :<ul> <li>autre que tableau (cas des tableaux multi-indice)</li> <li>autre que structure ou union avec champ constant</li> </ul> </li> <li>Champ de structure ou d'union : m\u00eame pr\u00e9cisions que pour les tableaux</li> </ul> </li> </ul>"},{"location":"C/08-Pointeurs/#un-tableau-nest-pas-une-lvalue","title":"Un tableau n'est pas une lvalue","text":"<ul> <li>Consid\u00e9rons : <code>int tab[4];</code> Un nom de tableau comme <code>tab</code> utilis\u00e9 plus loin dans le programme d\u00e9signe en fait un pointeur constant (non modifiable) dont la valeur est l'adresse du (premier bloc du) <code>tab[0]</code>. Apr\u00e8s d\u00e9claration, <code>tab</code> a pour valeur <code>&amp;tab[0]</code>.</li> <li><code>tab=tab2</code> soul\u00e8ve une erreur \u00e0 la compilation (les noms de tableau ne sont pas des lvalue).</li> </ul>"},{"location":"C/08-Pointeurs/#les-fonctions-dallocation-en-cpge","title":"Les fonctions d'allocation en CPGE","text":"<p>(D'apr\u00e8s Koors) <code>malloc</code> de <code>&lt;stdlib.h&gt;</code></p> <pre><code>void *malloc(size_t memorySize);\n</code></pre> <ul> <li>Cette fonction permet d'allouer un bloc de m\u00e9moire dans le tas (heap en anglais).</li> <li>Attention : la m\u00e9moire allou\u00e9e dynamiquement n'est pas automatiquement relach\u00e9e. Il faudra donc, apr\u00e8s utilisation, lib\u00e9rer ce bloc de m\u00e9moire via un appel \u00e0 la fonction <code>free</code></li> </ul> <p>(D'apr\u00e8s Koors)</p> <p><code>calloc</code>de <code>&lt;stdlib.h&gt;</code></p> <pre><code>void *calloc ( size t elementCount, size t elementSize ) ;\n</code></pre> <p>Cette fonction alloue un bloc de m\u00e9moire en initialisant tous ces octets \u00e0 la valeur \\(0\\). Bien que relativement proche de la fonction <code>malloc</code>, deux aspects les diff\u00e9rencient :</p> <ul> <li>L'initialisation : <code>calloc</code> met tous les octets du bloc \u00e0 la valeur \\(0\\) alors que malloc ne modifie pas la zone de m\u00e9moire.</li> <li>Les param\u00e8tres d'appels : <code>calloc</code> requi\u00e8re deux param\u00e8tres (le nombre d'\u00e9l\u00e9ments cons\u00e9cutifs \u00e0 allouer et la taille d'un \u00e9l\u00e9ment) alors que <code>malloc</code> attend la taille totale du bloc \u00e0 allouer.</li> </ul>"},{"location":"C/08-Pointeurs/#la-fonction-de-liberation","title":"La fonction de lib\u00e9ration","text":"<ul> <li>free de stdlib.h</li> </ul> <pre><code>void free ( void *pointer ) ;\n</code></pre> <ul> <li>La fonction <code>free</code> lib\u00e8re un bloc de m\u00e9moire allou\u00e9 dynamiquement dans le tas (le heap, en anglais), via un appel \u00e0 la fonction malloc (ou tout autre fonction d'allocation m\u00e9moire)</li> <li>ne jamais d\u00e9sallouer avec la fonction <code>free</code> un bloc de m\u00e9moire obtenu autrement que par une fonction d'allocation comme <code>malloc</code>, <code>calloc</code></li> </ul>"},{"location":"C/08-Pointeurs/#squelette-dallocation","title":"Squelette d'allocation \u2665","text":"<ul> <li>Puisqu'un nom de tableau d\u00e9signe un pointeur constant :<ul> <li>On ne peut pas cr\u00e9er de tableaux dont la taille est une variable du programme (sauf \u00e0 utiliser des VLA),</li> <li>On ne peut pas cr\u00e9er de tableaux bidimensionnels dont les lignes n'ont pas toutes le m\u00eame nombre d'\u00e9l\u00e9ments.</li> </ul> </li> <li>Plut\u00f4t que de d\u00e9clarer les tableaux comme des pointeurs constants, on peut manipuler des pointeurs allou\u00e9s dynamiquement</li> </ul> <pre><code>#include &lt;stdlib.h&gt;// exemple Anne Canteaut\nint main(){\n    int n;// la valeur sera par exemple saisie avec un scanf\n    int *tab;\n    ...\n    tab = (int*)malloc(n * sizeof(int)) ;\n    // cases de tab non initialis \u00e9es\n    ...\n    free(tab) ;\n}\n</code></pre> <p>Avec <code>calloc</code>, le principe est le m\u00eame mais en plus les cases du tableau sont initialis\u00e9es \u00e0 \\(0\\) :</p> <pre><code>#include &lt;stdlib.h&gt; // exemple Anne Canteaut\nint main(){\n    int n; // la valeur sera par exemple saisie avec un scanf\n    int *tab;\n    ...\n    tab = (int*)calloc(n, sizeof(int)); // syntaxe diff\u00e9rente\n    // cases de tab initialis\u00e9es \u00e0 0\n    ...\n    free(tab);\n}\n</code></pre> <p>Dans tous les cas, les \u00e9l\u00e9ments de <code>tab</code> sont manipul\u00e9s avec l'op\u00e9rateur d'indexation <code>[]</code> , exactement comme pour les tableaux.</p> <p>Commentaire</p> <ul> <li>Dans le transparent pr\u00e9c\u00e9dent, <code>tab</code> n'est pas un tableau statique, c'est un pointeur.</li> <li>Mais on l'utilise comme un tableau : en particulier <code>tab[2]</code> d\u00e9signe l'\u00e9l\u00e9ment situ\u00e9 \u00e0 l'adresse <code>&amp;tab[0]+2*4</code></li> <li>de plus, <code>tab</code> n'est pas un pointeur constant : c'est une lvalue. On peut \u00e9crire par exemple <code>tab++</code> ou <code>tab = &amp;n</code></li> </ul>"},{"location":"C/08-Pointeurs/#tableau-vs-pointeur","title":"Tableau VS pointeur \u2665","text":"<p>Les deux diff\u00e9rences principales entre un tableau et un pointeur sont</p> <ul> <li>un pointeur devrait toujours \u00eatre initialis\u00e9, soit par une allocation dynamique, soit par affectation d'une expression adresse, par exemple <code>p = &amp;i</code>;</li> <li>un tableau n'est pas une <code>lvalue</code> ; il ne peut donc pas figurer \u00e0 gauche d'un op\u00e9rateur d'affectation. En particulier, un tableau ne supporte pas l'arithm\u00e9tique (on ne peut pas \u00e9crire <code>tab++;</code>).</li> </ul>"},{"location":"C/08-Pointeurs/#tableaux-a-plusieurs-dimensions","title":"Tableaux \u00e0 plusieurs dimensions \u2665","text":"<ul> <li>Un tableau \u00e0 deux dimensions est, par d\u00e9finition, un tableau de tableaux. Apr\u00e8s la d\u00e9claration, le nom du tableau est utilis\u00e9 comme un pointeur constant vers un pointeur constant.</li> <li>D\u00e9claration, initialisation et usage d'un tableau bi-dimensionnel :</li> </ul> <pre><code>int main(){\n    int mat[2][3]={{1,20,300},{4,50,600}};\n    for (int i = 0; i &lt; 2; i++){\n        for (int j = 0 ; j &lt; 3; j++) {printf(\"%3d\", mat[i][j]);}\n            printf (\"\\n\");\n    }\n    return 0;\n}\n</code></pre> <ul> <li> <p>Attention : les \u00e9l\u00e9ments de mat (\\(6\\) ici) sont rang\u00e9s cons\u00e9cutivement en m\u00e9moire. Il n'y a pas de \u00ab grille \u00bb dans la m\u00e9moire.</p> </li> <li> <p>Avec l'exemple pr\u00e9c\u00e9dent, on obtient</p> </li> </ul> Rendu<pre><code>10 2 300\n400 500 6\n</code></pre> <ul> <li>Avec</li> </ul> <pre><code>int mat[N][M];\n</code></pre> <ul> <li> <ul> <li><code>mat</code> est utilis\u00e9 comme un pointeur (constant) qui pointe vers un pointeur (constant) de type pointeur d'entiers. Le tableau <code>mat</code> est une adresse invariante \u00e9gale \u00e0 celle du premier \u00e9l\u00e9ment : <code>&amp;mat[0][0]</code>.</li> <li>De m\u00eame <code>mat[i]</code> , pour <code>i</code> entre \\(0\\) et <code>N-1</code>, est un pointeur constant vers un objet de type entier, qui est le premier \u00e9l\u00e9ment de la \u00ab ligne \u00bb d'indice <code>i</code>. <code>mat[i]</code> a donc une valeur constante qui est \u00e9gale \u00e0 <code>&amp;mat[i][0]</code>.</li> <li><code>mat, mat[0]</code> et <code>&amp;mat[0][0]</code> d\u00e9signent la m\u00eame adresse.</li> </ul> </li> </ul> <p>Exercice</p> <p>(Hors programme) Utiliser la propri\u00e9t\u00e9 de contigu \u0308\u0131t\u00e9 en m\u00e9moire pour \u00e9crire une fonction void display(int n, int m, int t[n][m]) qui affiche sur une ligne tous les coefficients du tableau bi-dimensionnel t. Une seule boucle est autoris\u00e9e.</p> <p>Dans main, \u00e9crivons :</p> <pre><code>int t =[3][2] = {{1, 2}, {3, 4}, {5, 6}};\ndisplay (3, 2, t);\n</code></pre> <p>Apr\u00e8s compilation/ex\u00e9cution :</p> Rendu<pre><code>1,2,3,4,5,6,\n</code></pre>"},{"location":"C/08-Pointeurs/#allocation-dynamique-de-matrice","title":"Allocation dynamique de \u00ab matrice \u00bb \u2665","text":"<ul> <li>On d\u00e9clare un pointeur qui pointe sur un objet de type <code>type *</code> (deux dimensions) de la m\u00eame mani\u00e8re qu'un pointeur avec</li> </ul> <pre><code>type **nom\u2212du\u2212pointeur;\n</code></pre> <p>Le squelette du programme devient :</p> <pre><code>int k, n;\nint **tab;\n...\n//tab. de k pointeurs d'entiers\ntab = (int**)malloc(k * sizeof(int *));\nfor ( int i = 0; i &lt;k; i ++)\n    // tab. de n entiers\n    tab [i] = (int*)malloc(n * sizeof(int)) ;\n    ....\nfor (int i = 0; i &lt; k; i++)\n    free (tab[i]); // lib\u00e9ration espaces des lignes\nfree (tab); // lib\u00e9ration espace\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n\nint main(){\n    int n=2, m=3;\n    int **tab;\n    tab = (int**)malloc(n *sizeof(int *)) ;\n    for (int i = 0; i &lt; n; i++){\n        tab [i] = (int*)malloc(m * sizeof(int)) ; // tab. d'entiers\n        for (int j = 0; j &lt; m; j++)// on peut s'en passer avec calloc\n            tab [i][j] = 0;\n}\n...\n\nfor (int i = 0; i &lt; n; i++)\n    free (tab[i]); // lib\u00e9ration espaces des lignes\nfree (tab); // lib\u00e9ration espace\nreturn 0;\n}\n</code></pre>"},{"location":"C/08-Pointeurs/#tableaux-statiques-2d-vs-pointeur-de-pointeur","title":"Tableaux statiques 2D VS pointeur de pointeur","text":"<ul> <li>Consid\u00e9rons le pointeur de pointeur utilis\u00e9 comme un tableau \u00e0 deux dimensions dans le transparent pr\u00e9c\u00e9dent : <code>int ** tab = malloc(2 * sizeof(int *))</code>. Chaque \u00ab ligne \u00bb est d\u00e9clar\u00e9e par <code>tab[i] = (int*)malloc(3 * sizeof(int));</code> .</li> <li>Consid\u00e9rons un tableau statique \u00e0 deux dimensions : <code>int t[2][3]</code> .</li> <li>Dans <code>tab</code>, les \u00e9l\u00e9ments sont rang\u00e9s par \u00ab lignes \u00bb , deux \u00ab lignes \u00bb n'\u00e9tant pas n\u00e9cessairement cons\u00e9cutives en m\u00e9moire.</li> <li>Dans <code>t</code>, les \u00e9l\u00e9ments sont tous contigus en m\u00e9moire. Le dernier octet du dernier \u00e9l\u00e9ment de la \u00ab ligne \\(i\\) \u00bb est voisin du premier octet du premier \u00e9l\u00e9ment de la \u00ab ligne \\(i\\) + 1 \u00bb .</li> </ul>"},{"location":"C/08-Pointeurs/#passage-en-parametre","title":"Passage en param\u00e8tre","text":"<p>Les deux d\u00e9clarations suivantes ne sont pas \u00e9quivalentes :</p> <pre><code>void foo(int n, int m, int **tab) ;\nvoid moo(int n, int m, int t[n][m]);\n</code></pre> <ul> <li>Pour acc\u00e9der \u00e0 <code>t[i][j]</code>, <code>moo</code> calcule <code>*(t + i * m + j)</code>. Rappel : le nom d'un tableau est un alias vers la localisation en m\u00e9moire de ce tableau : c.a.d. <code>&amp;t[0][0]</code>.</li> <li>Pour acc\u00e9der \u00e0 <code>tab[i][j]</code>, <code>foo</code> calcule <code>*(*(tab + i) + j)</code> (observer le double d\u00e9r\u00e9f\u00e9rencement).</li> <li>Les appels <code>foo(2,3,t)</code> et <code>moo(2,3,tab)</code> risquent tous deux de mener \u00e0 une erreur de segmentation (seg fault).<ul> <li>Dans <code>foo(2,3,t)</code>, la fonction traite <code>t+i</code> comme une adresse \u00e0 d\u00e9r\u00e9f\u00e9rencer ; ce qu'elle n'est pas.</li> <li>Dans <code>moo(2,3,tab)</code>, la fonction consid\u00e8re que les \u00e9l\u00e9ments <code>tab[i][m-1]</code> et <code>tab[i+1][0]</code> sont contigus; ce qu'ils ne sont pas.</li> </ul> </li> </ul>"},{"location":"C/08-Pointeurs/#allocation-dynamique-de-matrice-suite","title":"Allocation dynamique de matrice (suite)","text":"<p>Pour cr\u00e9er un tableau \u00e0 3 dimensions, utiliser un pointeur vers un objet de type <code>type **</code> :</p> <pre><code>type ***nom\u2212du\u2212pointeur;\n</code></pre>"},{"location":"C/08-Pointeurs/#chaine-de-caracteres","title":"Cha\u00eene de caract\u00e8res","text":"<ul> <li>Une cha\u00eene de caract\u00e8res est un tableau \u00e0 une dimension d'objets de type char, se terminant par le caract\u00e8re nul <code>'\\0'</code>.</li> <li>On peut donc manipuler toute cha\u00eene de caract\u00e8res \u00e0 l'aide d'un pointeur sur un objet de type <code>char</code>.</li> <li>Les constantes cha\u00eenes sont not\u00e9es entre doubles quotes comme <code>\"hello\"</code> mais le caract\u00e8re de fin de cha\u00eene n'appara\u00eet pas explicitement.</li> <li>Les constantes cha\u00eenes sont toujours plac\u00e9es en m\u00e9moire statique. Elles sont immuables.</li> <li>Le caract\u00e8re immuable permet au compilateur d'allouer une seule occurrence de chaque cha\u00eene distincte. En clair, dans</li> </ul> <pre><code>printf(\"hello\");\nprintf(\"hello\");\n</code></pre> <p>les deux occurrences de hello sont stock\u00e9es au m\u00eame endroit en m\u00e9moire.</p>"},{"location":"C/08-Pointeurs/#les-chaines-de-caracteres-comme-tableaux-de-char","title":"Les cha\u00eenes de caract\u00e8res comme tableaux de <code>char</code> \u2665","text":"<p>D\u00e9claration comme pointeur (constant):</p> <pre><code>char chaine [5] ;\n</code></pre> <ul> <li>Le mot <code>hello</code> est d\u00e9clar\u00e9 et initialis\u00e9 avec</li> </ul> <pre><code>char chaine [6] = {'h', 'e', 'l', 'l', 'o', '\\0'};\n</code></pre> <ul> <li>Le caract\u00e8re <code>'\\0'</code> repr\u00e9sente la fin du mot. Sa pr\u00e9sence est \\(\\underline{\\text{imp\u00e9rative}}\\). Ainsi \u00ab hello \u00bb n\u00e9cessite \\(6\\) caract\u00e8res. Les guillemets sont simples.</li> <li><code>\"h\"</code> repr\u00e9sente la cha\u00eene de caract\u00e8res <code>{'h',\\0}</code> et <code>'h'</code> ben... le caract\u00e8re \u00ab <code>h</code> \u00bb !</li> <li>Initialisation plus rapide :</li> </ul> <pre><code>char chaine [] = \"Salut\";// taille automatiqu. calcul \u00e9e\n// caract\u00e8re de fin de cha\u00eene automatiquement ajout\u00e9.\n// Observer les doubles quote.\n// chaine est de lg 6 ! !\n</code></pre>"},{"location":"C/08-Pointeurs/#acces-aux-elements","title":"Acc\u00e8s aux \u00e9l\u00e9ments \u2665","text":"<p>Comme en \\(\\texttt{Python}\\), l'acc\u00e8s aux constituants de la cha\u00eene se fait avec l'op\u00e9rateur <code>[]</code>. - Lecture :</p> <pre><code>char chaine[] = \"hello\";\nint i =0;\nwhile(chaine[i] !='\\0'){ // lecture\n    printf(\"%c\", chaine[i]);\n    i++;\n}\n</code></pre> <p>Affiche \u00ab hello \u00bb .</p> <ul> <li>Modification :</li> </ul> <pre><code>i = 0;\nwhile(chaine [i] !='\\0'){// codage de C\u00e9sar\n    chaine [i] = chaine[i]+1;\n    i++;\n}\n</code></pre> <p>La cha\u00eene est devenue <code>ifmmp</code></p>"},{"location":"C/08-Pointeurs/#affichage-et-saisie-au-clavier","title":"Affichage et saisie au clavier \u2665","text":"<p>Le sp\u00e9cifieur de format <code>%s</code> vaut pour <code>printf</code> et <code>scanf</code> :</p> <pre><code>int main(){\n    char chaine [] = \"hello\";\n    printf (\"%s\\n\", chaine);\n    printf (\" entrer un mot de 5 lettres sans espace : \") ;\n    scanf (\"%s\", chaine) ;// chaine est un pointeur\n    printf (\"%s\\n\", chaine);\n    return 0;\n}\n</code></pre> <p>On obtient :</p> Rendu<pre><code>hello\nentrer un mot de 5 lettres sans espace : salut\nsalut\n</code></pre>"},{"location":"C/08-Pointeurs/#longueur","title":"Longueur","text":"<p>On dispose d'un moyen pour calculer la longueur d'une cha\u00eene de caract\u00e8res : on it\u00e8re jusqu'\u00e0 tomber sur le caract\u00e8re nul <code>'\\0'</code>.</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main(){\n    int i ;\n    char *chaine ;\n\n    chaine = \"toto et gogo\";\n    for ( i = 0; chaine [ i ] !='\\0'; i ++);    // observer le \";\"\n\n    printf (\"nombre de caracteres = %d\\n\",i);\n    return 0;\n}\n</code></pre> <ul> <li>Avec cette m\u00e9thode, la complexit\u00e9 est \\(\\underline{\\text{lin\u00e9aire}}\\) : il y a \\(n\\) \u00e9tapes pour calculer la longueur (si \\(n = |\\textbf{chaine}|\\)).</li> <li>Un autre moyen de calculer la longueur d'une cha\u00eene de caract\u00e8res est d'utiliser la fonction <code>strlen</code> de <code>&lt;string.h&gt;</code>.</li> <li>Son protototype est le suivant</li> </ul> <pre><code>size t strlen ( const char *theString ) ;\n</code></pre> <ul> <li>Elle prend donc en param\u00e8tre un pointeur sur un <code>char</code> constant (on ne modifie pas la cha\u00eene).</li> <li>On l'utilise ainsi</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(){\n    ...\n    printf (\"nombre de caracteres = %zu\\n\", strlen(chaine)) ;\n    ...}\n</code></pre> <ul> <li>Mais la complexit\u00e9 reste lin\u00e9aire !</li> </ul>"},{"location":"C/08-Pointeurs/#comparer","title":"Comparer","text":"<ul> <li><code>int strcmp(const char *first, const char *second);</code> de <code>string.h</code></li> <li>Compare les deux cha\u00eenes <code>first</code>, <code>second</code></li> <li>Si la valeur de retour est nulle, les cha\u00eenes sont \u00e9gales</li> <li>Si la valeur renvoy\u00e9e est n\u00e9gative, le premier caract\u00e8re qui ne correspond pas a une valeur inf\u00e9rieure dans <code>first</code> que dans <code>second</code></li> <li>Si la valeur renvoy\u00e9e est positive, le premier caract\u00e8re qui ne correspond pas a une valeur sup\u00e9rieure dans <code>first</code> que dans <code>second</code>.</li> <li>La variante <code>strncmp(first,second,n)</code> ne compare que les \\(n\\) premiers caract\u00e8res des cha\u00eenes.</li> <li><code>first==second</code> ne doit \u00eatre utilis\u00e9 que pour des cha\u00eenes de caract\u00e8res litt\u00e9rales (dans le doute, on \u00e9vite !)</li> </ul>"},{"location":"C/08-Pointeurs/#convertir-en-entier","title":"Convertir en entier","text":"<ul> <li><code>int atoi(const char *theString);</code> de strlib</li> <li>Cette fonction permet de transformer une cha\u00eene de caract\u00e8res, repr\u00e9sentant une valeur enti\u00e8re comme <code>\"12356\"</code> , en une valeur num\u00e9rique de type int . Le terme d'\u00ab atoi \u00bb est un acronyme signifiant : ASCII to integer.</li> <li>Retourne la valeur \\(0\\) si la cha\u00eene de caract\u00e8res ne contient pas une repr\u00e9sentation de valeur num\u00e9rique. Il n'est donc pas possible de distinguer la cha\u00eene <code>\"0\"</code> d'une cha\u00eene ne contenant pas un nombre entier. L'utilisation de la fonction <code>strtol</code> permet bien de distinguer les deux cas.</li> </ul>"},{"location":"C/08-Pointeurs/#modifier-une-constante-chaine","title":"Modifier une constante cha\u00eene","text":"<ul> <li>La norme n'indique pas si les constantes cha\u00eenes comme <code>\"hello\"</code> sont modifiables ou non. Juste qu'elles sont plac\u00e9es en m\u00e9moire statique.</li> <li>Pour imposer un caract\u00e8re immuable ind\u00e9pendamment des impl\u00e9mentations, pr\u00e9f\u00e9rer :</li> </ul> <pre><code>const char *a = \"hello\";\n</code></pre>"},{"location":"C/08-Pointeurs/#concatenation","title":"Concat\u00e9nation \u2665","text":"<ul> <li>Pour concat\u00e9ner deux cha\u00eenes de caract\u00e8res, allouer \u00e0 une troisi\u00e8me cha\u00eene autant de place que la somme des longueurs.</li> <li>Parcourir l'une apr\u00e8s l'autre les deux cha\u00eenes et entrer leurs caract\u00e8res dans le r\u00e9sultat.</li> </ul> <pre><code>int main(){// exemple Anne Canteaut\n    char *chaine1, *chaine2, *res ; // 3 pointeurs\n\n    chaine1 = \"chaine \";\n    chaine2 = \"de caracteres \";\n    size_t lgc1 = strlen(chaine1) , lgc2 = strlen(chaine2);\n    res = (char*)malloc((lgc1 + lgc2 + 1) * sizeof(char));\n    for (int i = 0; i &lt; lgc1; i++)\n        res[i] = chaine1[i];\n    for (int i = lgc1; i &lt; lgc1 + lgc2; i++)\n        res[i] = chaine2[i \u2212lgc1];\n    res[lgc1 + lgc2] = \"\\0\";\n    printf(\"%s\\n\", res); free(res);\n    return 0;\n}\n</code></pre>"},{"location":"C/08-Pointeurs/#tableau-de-constantes-chaines","title":"Tableau de constantes cha\u00eenes","text":"<ul> <li>Une constante cha\u00eene est convertie par le compilateur en un pointeur sur son premier caract\u00e8re. On peut donc facilement constituer un tableau de constantes cha\u00eenes.</li> <li>On peut bien s\u00fbr toujours initialiser individuellement :</li> </ul> <pre><code>char *jour [7] ;\njour [0] = \"lundi\";\njour [1] = \"mardi\"; ...\n</code></pre> <ul> <li>Mais on peut aussi profiter de la syntaxe d'initialisation des tableaux en \u00e9crivant directement :</li> </ul> <p><code>C lineums=\"1\" char *jour [7] = {\"lundi\",\"mardi\" ,...}</code></p>"},{"location":"C/09-Structures/","title":"D\u00e9finition de types (Structures)","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Ce Wiki de Wikipedia</li> <li>Ce cours de OpenClassRoom</li> <li>Ce cours d'Anne Canteaut</li> </ul>"},{"location":"C/09-Structures/#structures","title":"Structures","text":""},{"location":"C/09-Structures/#definition","title":"D\u00e9finition","text":"<p>Structure</p> <p>Une structure est, comme un tableau, un objet de type agr\u00e9g\u00e9, c'est \u00e0 dire constitu\u00e9 d'un ensemble de valeurs.</p> <ul> <li>Mais \u00e0 la diff\u00e9rence d'un tableau, ces valeurs peuvent \u00eatre de types diff\u00e9rents.</li> <li>Par ailleurs, le rep\u00e9rage d'un objet dans la structure se fait, non plus selon un indice, mais par ce qu'on appelle un nom de champ, c'est \u00e0 dire un identificateur.</li> <li>On ne peut pas parcourir les champs d'une structure au moyen d'une boucle (alors qu'on le fait pour les tableaux).</li> <li>Une structure est donc une suite finie d'objets de type diff\u00e9rents (les champs ou membres). Le nombre de ces diff\u00e9rents champs est limit\u00e9 \u00e0 \\(127\\) soit \\(2^7 \u22121\\).</li> </ul> <p>Exemple d'utilisation</p> <p>Une structure permet d'accro\u00eetre la clart\u00e9 des programmes en rassemblant dans un m\u00eame objet des informations poss\u00e9dant un lien. Par exemple :</p> <ul> <li>Les diff\u00e9rentes informations associ\u00e9es \u00e0 une personne : nom, pr\u00e9nom, adresse, sexe, num\u00e9ro de SS...</li> <li>les diff\u00e9rentes informations associ\u00e9es \u00e0 un point du plan : ses coordonn\u00e9es, et, s'il s'agit d'un pixel, ses composantes RVB.</li> </ul>"},{"location":"C/09-Structures/#un-mot-sur-les-unions-hors-programme","title":"Un mot sur les unions (Hors programme)","text":"<ul> <li>Une union est un moyen artificiel de consid\u00e9rer un m\u00eame objet avec diff\u00e9rents types.</li> <li>A chaque type se trouve associ\u00e9, comme pour les structures, un nom de champs.</li> <li>Mais dans une structure, les champs ne s'excluent pas l'un, l'autre : ils sont juxtapos\u00e9s. Dans une union, les champs ne peuvent cooexister en m\u00eame temps : ils sont superpos\u00e9s.</li> <li>Les unions s'utilisent :<ul> <li>pour interpr\u00e9ter de fa\u00e7ons diff\u00e9rentes un m\u00eame motif binaire.</li> <li>pour \u00e9conomiser de la m\u00e9moire en faisant occuper \u00e0 des instants diff\u00e9rents un m\u00eame emplacement par des informations de types diff\u00e9rents.</li> </ul> </li> <li>L'union a un caract\u00e8re peu portable et reste limit\u00e9e \u00e0 des utilisations particuli\u00e8res.</li> </ul>"},{"location":"C/09-Structures/#definire-de-nouveaux-types","title":"D\u00e9finire de nouveaux types","text":"<p>Les unions et structures peuvent \u00eatre consid\u00e9r\u00e9s comme des types d\u00e9finis par le programmeur.</p>"},{"location":"C/09-Structures/#modele-et-declaration","title":"Mod\u00e9le et d\u00e9claration","text":"<p>Un mod\u00e8le de structure est la description d'une structure :</p> <pre><code>struct modele {\n    type 1 membre 1;\n    type 2 membre 2;\n    ...\n    type n membre n;\n};// ce point virgule est imp\u00e9ratif !!\n</code></pre> <ul> <li>Une fois le mod\u00e8le d\u00e9clar\u00e9, on d\u00e9clare un objet de ce type avec :</li> </ul> <pre><code>struct modele objet ;\n</code></pre> <ul> <li>Cette syntaxe qui d\u00e9clare dans la foul\u00e9e le type <code>modele</code> et un objet <code>representant</code> de ce type est \u00e9galement possible :</li> </ul> <pre><code>struct modele {\n    type 1 membre 1;\n    type 2 membre 2;\n    ...\n    type n membre n;\n} representant ;\n</code></pre> <p>On d\u00e9finit une structure <code>temps</code> qui mod\u00e9lise un triplet (heure,minute,secondes) :</p> <pre><code>struct temps {\n    unsigned int heures ;\n    unsigned int minutes;\n    double secondes;\n};// ce point virgule est imp\u00e9 ratif !!\n</code></pre> <p>La d\u00e9claration d'un objet de type <code>temps</code> se fait ainsi :</p> <pre><code>1 struct temps t;\n</code></pre>"},{"location":"C/09-Structures/#affectation","title":"Affectation","text":"<p>Il reste \u00e0 affecter les diff\u00e9rents champs d'un objet <code>obj</code> de type structur\u00e9 modele. Il y a deux possibilit\u00e9s :</p> <ul> <li>Syntaxe de type tableau <code>struct modele obj = {v1, ..., vn }</code> pour une d\u00e9claration/affectation simultan\u00e9e. Les types de \\(v_1,...,v_n\\) sont ceux des champs de <code>modele</code> et respecte l'ordre des champs dans la structure.</li> <li>Syntaxe point\u00e9e <code>obj.membre 1 = v1</code> ,..., <code>obj.membre n = vn</code></li> </ul> <ul> <li>Affichage d'une structure de temps :</li> </ul> <pre><code>void affichage ( struct temps t){\n    printf (\"temps=%uh %umin %fs\\n\",t.heures,t.minutes,t.secondes);\n}\n</code></pre> <ul> <li>Affectation</li> </ul> <pre><code>void main() {\n    struct temps t1 = { 1, 45, 30.560 };//Syntaxe type tableau\n    affiche (t1) ;\n    struct temps t2;\n    t2.heures = 5;//Syntaxe de type point\u00e9e\n    t2.minutes = 23;\n    t2.secondes = 10.06;\n    affiche (t2) ;\n}\n</code></pre> <p>On obtient :</p> Rendu<pre><code>temps =1h 45min 30.560000s\ntemps =5h 23min 10.060000s\n</code></pre>"},{"location":"C/09-Structures/#alias-de-structure","title":"Alias de structure","text":"<ul> <li>L'\u00e9criture <code>struct temps t</code> est un peu lourde. Il est plus agr\u00e9able de faire des d\u00e9clarations sous la forme temps t.</li> <li>Pour cel\u00e0, on utilise l'instruction <code>typedef</code> dont voici la syntaxe :</li> </ul> <pre><code>typedef struct nomModele nomAlias;\nstruct nomModele{\n// les diff \u00e9 rents champs et leurs types\n};\n</code></pre> <ul> <li><code>typedef</code> indique que nous cr\u00e9ons un alias de structure, <code>struct nomModele</code> est le nom de la structure et <code>nomAlias</code> celui de son alias</li> </ul> <pre><code>typedef struct temps time;\nstruct temps {\n    unsigned int heures ;\n    unsigned int minutes;\n    double secondes;\n    };// ce point virgule est imp\u00e9 ratif !!\n</code></pre> <ul> <li>Fonction d'affichage</li> </ul> <pre><code>void affiche (time t){\n    printf (\"temps=%ih %imin %fs\\n\",t.heures,t.minutes,t.secondes);\n}\n</code></pre> <ul> <li>Affectation</li> </ul> <pre><code>void main() {\n    time t2 ;\n    t2.heures = 5;\n    t2.minutes = 23;\n    t2.secondes = 10.06;\n    affiche(t2);\n}\n</code></pre>"},{"location":"C/09-Structures/#pointeur-de-structure","title":"Pointeur de structure","text":"<ul> <li>D\u00e9claration sans surprise d'un pointeur sur notre type structur\u00e9 <code>temps</code> :</li> </ul> <pre><code>time t ;\ntime\u2217p = &amp;t;// ou time \u2217p = &amp;t\n</code></pre> <ul> <li>Il y a en revanche un peu de sucre syntaxique; on peut affecter les champs de l'objet sur lequel pointe le pointeur de deux fa\u00e7ons :`</li> </ul> <pre><code>(\u2217p1). heures = 12;// fa\u00e7on classique , noter la parenth\u00e8se\np1\u2212&gt;minutes = 41;// fa\u00e7on plus \u00e9l\u00e9gante\np1\u2212&gt;secondes = 23.56;\n</code></pre> <ul> <li><code>*p1.heures = 15</code>; produit une erreur de compilation.</li> </ul>"},{"location":"C/09-Structures/#initialisation-selective","title":"Initialisation s\u00e9lective","text":"<ul> <li>On peut recourir \u00e0 une initialisation s\u00e9lective en nommant bien les champs. Dans ce cas, l'ordre des membres n'a pas d'importance (comme pour le passage des param\u00e8tres nomm\u00e9s en \\(\\texttt{Python}\\)) :</li> </ul> <pre><code>time t = { .secondes = 30.560, . minutes = 45,\n    .heures = 1 };\n</code></pre> <ul> <li>On peut aussi m\u00e9langer les plaisirs :</li> </ul> <pre><code>time t = { .minutes = 45, 30.560 };\n</code></pre> <ul> <li>Il manque la valeur pour les heures : par d\u00e9faut, elle vaut 0. Ensuite on a une initialisation s\u00e9lective des minutes, puis on revient \u00e0 l'initialisation s\u00e9quentielle pour les secondes.</li> <li>L'initialisation s\u00e9quentielle reprend automatiquement \u00e0 la derni\u00e8re initialisation s\u00e9lective.</li> <li>A retenir : Si certains membres d'une structure ne se voient pas attribuer de valeurs durant l'initialisation d'une variable, ils seront initialis\u00e9s \u00e0 z\u00e9ro ou, s'il s'agit de pointeurs, seront des pointeurs nuls.</li> </ul>"},{"location":"C/09-Structures/#structure-et-memoire-hors-programme","title":"Structure et m\u00e9moire (Hors programme)","text":"<p>Les diff\u00e9rents champs d'une structure sont contigus en m\u00e9moire.</p> <ul> <li>Dans certaines impl\u00e9mentations, les int sont align\u00e9s sur des adresses multiples de 4 (leur premier octet est n\u00e9cessairement sur une adresse multiple de \\(4\\)).</li> <li>Consid\u00e9rons, dans une telle impl\u00e9mentation, la d\u00e9claration</li> </ul> <pre><code>struct essai { int n;// 4 octets\n    char c ;// 1 octet\n    int p; // 4 octets\n};// voir ci \u2212dessous le stockage en m\u00e9moire :\n</code></pre> <p>\\(\\!\\underbrace{\\!\\square\\!\\square\\!\\square\\!\\square\\!}_{\\!n\\!}\\underbrace{\\!\\square\\!}_{\\!c\\!}\\square\\!\\square\\!\\square\\!\\underbrace{\\square\\!\\square\\!\\square\\!\\square\\!}_p\\)</p> <p>On remarque l'utilisation d'octets de remplissage entre les champs <code>.c</code> et <code>.p</code>. Donc la taille de la structure est \\(12\\) octets et non \\(9\\).</p>"},{"location":"C/09-Structures/#structures-et-tableaux-de-structures","title":"Structures et tableaux de structures","text":"<p>Supposons que notre impl\u00e9mentation impose aux <code>int</code> de commencer \u00e0 des adresses multiples de 4.</p> <ul> <li>Rappel : Les diff\u00e9rents champs d'une structure sont contigus en m\u00e9moire.</li> <li>Consid\u00e9rons</li> </ul> <pre><code>struct essai { int n;// 4 octets\n    char c ;// 1 octet\n};\n</code></pre> <ul> <li>En th\u00e9orie, \\(5\\) octets suffisent pour repr\u00e9senter un objet de type essai. Mais un tel objet peut se retrouver dans un tableau...</li> <li>La r\u00e8gle de contgu\u00eft\u00e9 entre deux \u00e9l\u00e9ments successifs d'un tableau impose la violation de la r\u00e8gle des adresses en multiple de \\(4\\).</li> <li>Pour cette raison, les objets de type <code>essai</code> font \\(4+1+3\\) soit \\(8\\) octets DANS cette impl\u00e9mentation.</li> </ul>"},{"location":"C/09-Structures/#structure-et-memoire","title":"Structure et m\u00e9moire \u2665","text":"<ul> <li>On le voit, la taille des objets structur\u00e9s d\u00e9pend de l'impl\u00e9mentation.</li> <li>Pour se simplifier la vie : on consid\u00e8re en CPGE que la taille d'un type structur\u00e9 est la somme des tailles de ses diff\u00e9rents champs.</li> </ul>"},{"location":"C/09-Structures/#affectation-et-retour-par-copie","title":"Affectation et retour par copie","text":"<ul> <li>Affectation par copie :</li> </ul> <pre><code>struct S s= {...}; //d\u00e9claration et initialisation de s\nstruct S t ; // t non initialis\u00e9e\nt = s; // t re\u00e7oit une copie de s\n</code></pre> <ul> <li>Retour d'une valeur structur\u00e9e :</li> </ul> <pre><code>struct S f (...) {\n    ...\n    struct S t = ... ;// t est initialis\u00e9e\n    return t ; // t est copi\u00e9 dans l'emplacement\n    // qui accueille le retour de la fonction\n}\n</code></pre>"},{"location":"C/09-Structures/#un-mot-sur-le-passage-de-structures-en-parametres","title":"Un mot sur le passage de structures en param\u00e8tres","text":"<ul> <li>En \\(\\texttt{C}\\), le passage des arguments s'effectue par valeur. Cela signifie que la fonction travaille avec une copie de l'argument. Si l'argument est de grande taille, on utilise donc beaucoup de m\u00e9moire pour stocker une information redondante.</li> <li>Il est pr\u00e9ferable de passer en param\u00e8tre des fonctions, non pas une structure, mais un pointeur sur cette structure. Ce pointeur sert de \u00ab poign\u00e9e \u00bb \u00e0 l'objet et sa taille est fixe quelle que soit la structure point\u00e9e.</li> <li>Dans le m\u00eame soucis de r\u00e9duire le trafic dans la m\u00e9moire, on ne renvoie pas une structure mais, de pr\u00e9f\u00e9rence, un pointeur sur cette structure.</li> </ul>"},{"location":"C/09-Structures/#declaration-anticipee","title":"D\u00e9claration anticip\u00e9e","text":"<p>La norme autorise qu'on d\u00e9clare un nom de structure sans sa description :</p> <pre><code>struct enreg ; // enreg est un nom de structure\n// sa description sera donn\u00e9e plus tard\n</code></pre> <p>Dans la port\u00e9e de l'identificateur de structure, il est permis de fournir plus tard la description du type :</p> <pre><code>struct enreg ;// d\u00e9 claration du type\n...\nstruct enreg {char c ; int n;}; // description du type\n</code></pre>"},{"location":"C/09-Structures/#dependance-mutuelle","title":"D\u00e9pendance mutuelle","text":"<p>La d\u00e9claration anticip\u00e9e est indispensable en cas de d\u00e9pendance mutuelle entre \\(2\\) structures.</p> <pre><code>struct machin; // d\u00e9claration anticip\u00e9e\nstruct chose {... // definition normale de chose\n    ...\n    struct machin \u2217adm;// pointeur sur objet type machin\n};\nstruct machin {... // def. tardive de machin\n    ...\n    struct chose \u2217adc;// pointeur sur objet type chose\n}\n</code></pre>"},{"location":"C/09-Structures/#fonctions-mutuellement-recursives","title":"Fonctions mutuellement r\u00e9cursives","text":"<p>Il n'y a pas que pour les d\u00e9pendances mutuelles entre structures que la d\u00e9claration anticip\u00e9e est indispensable.</p> <ul> <li>La d\u00e9claration anticip\u00e9e est indispensable en cas de r\u00e9cursion mutuelle entre deux fonctions.</li> </ul> <p>Exercice comme exemple</p> <p>\u00c9crire deux fonctions mutuellement r\u00e9cursives bool pair(unsigned) et bool impair(unsigned) .</p> <p>Remarque de M.Noyer</p> <p>Il faut vraiment que je place ce transparent ailleurs que dans le cours sur les structures !</p> <p>(Voir la page OCaml pour un exemple)</p>"},{"location":"C/09-Structures/#type-enumere","title":"Type \u00e9num\u00e9r\u00e9","text":""},{"location":"C/09-Structures/#presentation","title":"Pr\u00e9sentation","text":"<p>Il s'agit de d\u00e9finir un type par la liste exhaustive de ses habitants.</p> <pre><code>enum couleur = {rouge, vert, bleu};\n</code></pre> <p>En fait, les valeurs repr\u00e9sent\u00e9es sont des entiers. V\u00e9rifions le avec :</p> <pre><code>enum couleur {rouge, vert , bleu};\n\nvoid main(){\n    enum couleur c;\n    c = bleu;\n    printf (\"c = %d\\n\",c);\n}\n</code></pre> <p>Apr\u00e8s compilation/ex\u00e9cution :</p> Rendu<pre><code>c = 2\n</code></pre> <p>On comprend que <code>rouge</code> est repr\u00e9sent\u00e9 par d\u00e9faut par \\(0\\), <code>vert</code> par \\(1\\) et <code>bleu</code> par \\(2\\).</p>"},{"location":"C/09-Structures/#modifier-les-valeurs-par-defaut","title":"Modifier les valeurs par d\u00e9faut","text":"<ul> <li>Il est possible de modifier les valeurs par d\u00e9faut lors de la d\u00e9claration :</li> </ul> <pre><code>enum couleur {rouge=11, vert=17, bleu=23};\n</code></pre> <ul> <li>Alors, la s\u00e9quence :</li> </ul> <pre><code>enum couleur c; c = bleu;\nprintf (\"c = %d\\n\",c);\n</code></pre> <ul> <li>Affiche</li> </ul> Rendu<pre><code>c=23\n</code></pre>"},{"location":"C/10-Conditions/","title":"Compl\u00e9ment sur les expressions conditionnelles","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Zestedesavoir</li> <li>\u226a Langage \\(\\texttt{C}\\) \u226b(Claude Delannoy) Eyrolles</li> </ul>"},{"location":"C/10-Conditions/#choix-en-cascade","title":"Choix en cascade","text":"<p>Consid\u00e9rons les choix en cascades suivants, dans lesquels les instructions concern\u00e9es peuvent \u00eatre des instructions simples (c.a.d suivies d'un point-virgule) ou des blocs :</p> <pre><code>if (x &gt;1) instruction 1\nelse if (x!=0) instruction 2\nelse if (x &lt;1) instruction 3\nelse instruction 4\n</code></pre> <p>On peut trouver cette pr\u00e9sentation un peu lourde (pas moi). Dans ce cas, le branchement multiple <code>switch</code> a ses avantages.</p>"},{"location":"C/10-Conditions/#branchement-multiple","title":"Branchement multiple","text":"<pre><code>switch (x){\n    case constante\u22121:\n        sequence_d_instructions_1\n        break;\n    case constante\u22122:\n        sequence_d_instructions_2\n        break;\n    ...\n    case constante\u2212n:\n        sequence_d_instructions_n\n        break;\n    default:\n        sequence_d_instructions_par_defaut\n        break;\n}\n</code></pre> <p>Dans ce qui pr\u00e9c\u00e8de <code>x</code> est une expression de type entier (ou caract\u00e8re) mais pas un flottant.</p>"},{"location":"C/10-Conditions/#observations","title":"Observations","text":"<ul> <li>Parenth\u00e8ses autour de <code>x</code>.</li> <li><code>case yyy:</code>, <code>case yyy :</code>, <code>case yyy :</code> sont valides. Il faut que <code>yyy</code> soit une expression CONSTANTE (par exemple <code>12</code> ou une variable d\u00e9clar\u00e9e constante)</li> <li>Il est conseill\u00e9 de mettre <code>break</code> \u00e0 la fin d'une liste d'instructions.</li> <li>Le cas par d\u00e9faut n'est pas obligatoire.</li> </ul> <pre><code>char note;\n\nprintf (\"Quelle note as\u2212tu obtenue ?\"); scanf(\"%c\", &amp;note);\n\nswitch(note){\n    /\u2217 Si la note est comprise entre E et C \u2217/\n    case 'E': case 'D': case 'C':\n        printf (\"No comment.\\n\");\n        break;\n    /\u2217 Si la note est comprise entre B et A \u2217/\n    case 'B':\n    case 'A':\n        printf (\"C'est correct voire mieux\\n\");\n        break;\n\n    default:\n        printf (\"Euh... note improbable ...\\n\");\n        break;\n}\n</code></pre>"},{"location":"C/10-Conditions/#operateur-ternaire","title":"Op\u00e9rateur ternaire","text":"<p>L'op\u00e9rateur conditionnel ou op\u00e9rateur ternaire est un op\u00e9rateur particulier dont le r\u00e9sultat d\u00e9pend de la r\u00e9alisation d'une condition. Son deuxi\u00e8me nom lui vient du fait qu'il est le seul op\u00e9rateur du langage \\(\\texttt{C}\\) \u00e0 n\u00e9cessiter \\(3\\) op\u00e9randes : une condition et deux expressions.</p> <pre><code>(condition) ? expression si vrai : expression si faux\n</code></pre> <pre><code>int heure;\n\nscanf(\"%d\", &amp;heure);\n\n(heure &gt;8 &amp;&amp; heure &lt;20) ?\nprintf (\" Il fait jour.\\n\") : printf (\" Il fait nuit.\\n\");\n</code></pre>"},{"location":"C/11-CompilSeparee/","title":"Compilation s\u00e9par\u00e9e","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Ce cours d'Anne Canteault sur la compilation s\u00e9par\u00e9e.</li> <li>Ce chapitre sur les directives pr\u00e9processeur d'un cours de OpenClassRoom</li> <li>Ce tutoriel sur les Makefile</li> </ul>"},{"location":"C/11-CompilSeparee/#objectif-et-principe","title":"Objectif et principe","text":"<ul> <li>Plut\u00f4t que de mettre tout le code dans un seul fichier, on le distribue dans plusieurs endroits : des modules.</li> <li>Dans un fichier donn\u00e9, on met par exemple des outils de calculs math\u00e9matiques, dans un autre des fonctions de manipulation de cha\u00eenes de caract\u00e8res etc.</li> <li>Cela permet de bien organiser un projet, d'am\u00e9liorer la lisibilit\u00e9 du code et de faciliter la maintenance : en cas de changement de quelques lignes de code seulement, on n'a pas besoin de tout recompiler mais seulement les fichiers concern\u00e9s.</li> </ul>"},{"location":"C/11-CompilSeparee/#rappel-sur-les-directives-de-preprocesseur","title":"Rappel sur les directives de pr\u00e9processeur","text":""},{"location":"C/11-CompilSeparee/#la-directive-include","title":"La directive <code>include</code>","text":"<ul> <li>La syntaxe pour inclure l'interface d'un fichier de biblioth\u00e8que est de placer son nom entre chevrons comme dans <code>&lt;stdio.h&gt;</code>.</li> <li>Pour tout autre fichier, et en particulier pour NOS FICHIERS PERSONNELS, on \u00e9crit son nom entre guillements ; par exemple <code>#include \"produit.h\"</code>.</li> <li>Dans tous les cas, le pr\u00e9processeur ins\u00e8re le contenu du fichier cible \u00e0 la place du <code>#include nomDuFichier</code></li> </ul>"},{"location":"C/11-CompilSeparee/#rappels-sur-la-directive-define","title":"Rappels sur la directive <code>define</code>","text":"<ul> <li>Lorsqu'il lit <code>#define TOTO Tata</code> , le pr\u00e9processeur remplace toute occurrence du premier mot par le second (mais pas dans les commentaires ni les expressions entre guillemets).</li> <li>On peut effectuer des calculs arithm\u00e9tiques en utilisant des constantes introduites par cette directive.</li> </ul> <pre><code>#define LARGEUR 60\n#define LONGUEUR 80\n#define AIRE ( LARGEUR \u2217LONGUEUR)\n</code></pre> <p>Hors programme.</p> <p>On peut se servir de <code>#define</code> pour d\u00e9finir des macros sans param\u00e8tre</p> <pre><code>#define HELLO ()    printf(\"Salut ! \\n\");\\\n                    printf(\"Hi !\\n\");\\\n                    printf(\"Hallo !\\n\");\n\nvoid main(){\n    HELLO();\n}\n</code></pre> <ul> <li>Observer les passages \u00e0 la ligne avec un antislash \u00ab \\ \u00bb comme en \\(\\texttt{Python}\\)</li> <li>Apr\u00e8s compilation et ex\u00e9cution :</li> </ul> Rendu<pre><code>Salut !\nHi !\nHallo !\n</code></pre> <p>On peut se servir de <code>#define</code> pour d\u00e9finir des macros Avec param\u00e8tres :</p> <pre><code>#include &lt;stdio.h&gt;\n#define APPRECIATION(nom, note)\\\n        if(note &lt; 10)\\\n            printf(\"%s, vous n\\'avez pas la moyenne.\\n\" , nom ) ; \\\n        else\\\n            printf(\"%s, vous \u00eates re\u00e7u !\\n\", nom);\n\nvoid main(){\n    APPRECIATION(\"Dupont\", 8);\n    APPRECIATION(\"Durand\", 18);\n}\n</code></pre> <ul> <li>Apr\u00e8s compilation et ex\u00e9cution :</li> </ul> Rendu<pre><code>Dupont, vous n'avez pas la moyenne .\nDurand, vous \u00eates re\u00e7u !\n</code></pre>"},{"location":"C/11-CompilSeparee/#definitions-sans-valeurs-de-substitutions","title":"D\u00e9finitions sans valeurs de substitutions \u2665","text":"<p>Parfois, on \u00e9crit juste :</p> <pre><code>#define NOM_DU_FICHIER\n</code></pre> <p>Cette d\u00e9claration, combin\u00e9e avec l'usage des conditions de pr\u00e9processeur (comme <code># ifndef</code>) permet d'\u00e9viter les inclusions infinie (lorsqu'un fichier <code>A</code> importe un fichier <code>B</code> qui importe <code>A</code>).</p>"},{"location":"C/11-CompilSeparee/#compilation-separee_1","title":"Compilation s\u00e9par\u00e9e","text":""},{"location":"C/11-CompilSeparee/#un-projet-en-deux-fichiers","title":"Un projet en deux fichiers","text":"<ul> <li>Dans un \\(1\\)er fichier \\(\\texttt{main.c}\\) :</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n#include \"produit.h\" // observer la syntaxe\n\nint main(void){\n    int a, b, c;\n    scanf(\"%d\", &amp;a); scanf(\"%d\", &amp;b);\n    printf(\"\\n le produit vaut %d\\n\", produit(a, b));\n    return 0;\n}\n</code></pre> <ul> <li>Dans un \\(2\\)nd fichier \\(\\texttt{produit.h}\\) (qui n'est pas vraiment un fichier d'en-t\u00eate).</li> </ul> <pre><code>int produit(int a, int b){\n    return (a \u2217 b);\n}\n</code></pre>"},{"location":"C/11-CompilSeparee/#compilation-en-une-fois","title":"Compilation en une fois","text":"<ul> <li>On peut compiler ce projet \u00e0 \\(2\\) fichiers en une seule fois avec la commande <code>gcc main.c -o main</code></li> <li>Le pr\u00e9processeur va juste regrouper (en les concat\u00e9nant et en supprimant les commentaires) les deux fichiers en un seul et produira l'ex\u00e9cutable \u00e0 partir de ce fichier concat\u00e9n\u00e9.</li> <li>Le seul avantage de cette d\u00e9marche est de rendre le code plus lisible mais on n'a rien gagn\u00e9 en terme de maintenance du projet.</li> </ul>"},{"location":"C/11-CompilSeparee/#introduction-dun-fichier-den-tete","title":"Introduction d'un fichier d'en-t\u00eate","text":"<ul> <li>S\u00e9parons les prototypes des corps des fonctions de \\(\\texttt{produit.h}\\).</li> <li>On cr\u00e9e pour cela un fichier d'interface \\(\\texttt{produit.h}\\) contenant les prototypes et un fichier \\(\\texttt{produit.c}\\) contenant les codes.</li> <li>Dans le fichier \\(\\texttt{produit.c}\\), incluons l'en-t\u00eate :</li> </ul> <pre><code>#include \"produit.h\"\nint produit(int a, int b){return( a \u2217 b );}\n</code></pre> <ul> <li>Toutes les fonctions de produit.c destin\u00e9es \u00e0 \u00eatre appel\u00e9es par d'autres fichiers que produit.c lui-m\u00eame devraient avoir leur prototype list\u00e9 dans \\(\\texttt{produit.h}\\).</li> <li>Comme de plus les interfaces list\u00e9es dans produit.h correspondent \u00e0 des fonctions dont le code est \u00e9crit ailleurs, on peut l'indiquer explicitement par le mot cl\u00e9 <code>extern</code>.</li> <li>Le fichier d'en-t\u00eate \\(\\texttt{produit.h}\\) contient donc :</li> </ul> <pre><code>extern int produit(int, int);\n</code></pre>"},{"location":"C/11-CompilSeparee/#mot-cle-extern-pour-les-fonctions","title":"Mot cl\u00e9 <code>extern</code> pour les fonctions","text":"<ul> <li>Pour une fonction les deux d\u00e9clarations suivantes sont \u00e9quivalentes <code>extern int fct(char c, float x)</code> et <code>int fct(char c, float x)</code>.</li> <li>La fonction sera utilisable dans les \\(2\\) cas \u00e0 l'ext\u00e9rieur du fichier source. Son nom devient ce qu'on appelle un identificateur externe, c'est \u00e0 dire qu'il est accessible \u00e0 l'\u00e9diteur de lien.</li> <li>Le mot <code>static</code> emp\u00eache que l'identificateur de la fonction soit utilis\u00e9 \u00e0 l'ext\u00e9rieur du fichier source o\u00f9 elle est d\u00e9finie. On parle alors de fonction cach\u00e9e ou priv\u00e9e.</li> </ul> <p><code>static int fct(char c, float x)...</code></p>"},{"location":"C/11-CompilSeparee/#mot-cle-extern-pour-les-variables","title":"Mot cl\u00e9 <code>extern</code> pour les variables","text":"<ul> <li>Le mot cl\u00e9 extern devrait \u00eatre r\u00e9serv\u00e9 aux red\u00e9claration</li> <li>Une d\u00e9claration contenant une initialisation constitue toujours une d\u00e9finition. <code>int x = 2;</code> et <code>extern int x = 2;</code> sont \u00e9quivalents. <code>extern</code> ne sert \u00e0 rien.</li> <li>Une d\u00e9claration avec extern sans initialisation constitue toujours une red\u00e9claration (donc jamais une d\u00e9finition) d'une variable pouvant , \u00e9ventuellement, \u00eatre d\u00e9finie ailleurs (donc dans le m\u00eame fichier source ou un autre). <code>extern int a</code>; fait r\u00e9f\u00e9rence \u00e0 une variable <code>a</code> d\u00e9finie ailleurs.</li> <li>On retient la r\u00e8gle suivante de bonne pratique :<ul> <li>Dans les d\u00e9finitions on n'utilise jamais <code>extern</code> et on s'interdit les d\u00e9clarations multiples au sein d'un m\u00eame fichier. On peut ou non initialiser.</li> <li>Dans les red\u00e9clarations On utilise syst\u00e9matiquement <code>extern</code> et on s'abstient de toute initialisation.</li> </ul> </li> </ul>"},{"location":"C/11-CompilSeparee/#introduction-dun-fichier-den-tete_1","title":"Introduction d'un fichier d'en-t\u00eate","text":"<p>Fabriquons le fichier objet relatif au \\(\\texttt{main.c}\\) :</p> <pre><code>gcc \u2212c main.c\n</code></pre> <p>Fabriquons le fichier objet relatif au \\(\\texttt{produit.c}\\) :</p> <pre><code>gcc \u2212c produit.c\n</code></pre> <p>Compilons l'ensemble</p> <pre><code>gcc main.o produit.o \u2212o prod\n</code></pre> <p>Remarquons qu'on peut toujours compiler tout en m\u00eame temps :</p> <pre><code>gcc produit.c main.c \u2212o prod\n</code></pre>"},{"location":"C/11-CompilSeparee/#importation-unique","title":"Importation unique","text":"<ul> <li>Comme on le constate, le fichier d'en-t\u00eate est import\u00e9 deux fois :<ul> <li>une premi\u00e8re fois par \\(\\texttt{produit.c}\\),</li> <li>une seconde fois par \\(\\texttt{main.c}\\)</li> </ul> </li> <li>Dans le fichier ex\u00e9cutable g\u00e9n\u00e9r\u00e9 par \\(\\texttt{gcc}\\), l'inclusion appara\u00eet donc deux fois.</li> <li>Pour \u00e9viter cela, on cr\u00e9e une constante <code>PRODUIT_H</code>.</li> <li>Cette constante, partag\u00e9e par tout le projet, est d\u00e9finie la premi\u00e8re fois qu'on inclue le fichier \\(\\texttt{produit.h}\\).</li> <li>La seconde fois qu'on importe le fichier d'en-t\u00eate, la constante est d\u00e9j\u00e0 d\u00e9finie et on se d\u00e9brouille pour emp\u00eacher une nouvelle inclusion des prototypes de \\(\\texttt{produit.c}\\).</li> <li>Il y a une convention de nommage pour cette constante : nom du fichier d'en-t\u00eate mis en majuscules (mais sans l'extension \\(\\texttt{.h}\\)) ; le tout suivi de \\(\\_\\texttt{H}\\).</li> </ul>"},{"location":"C/11-CompilSeparee/#ifndef","title":"<code>ifndef</code>","text":"<ul> <li>L'id\u00e9e est de mettre tous les prototypes et d\u00e9clarations diverses de \\(\\texttt{produit.h}\\) dans la branche positive d'une instruction conditionnelle du pr\u00e9processeur.</li> <li>Si la condition est v\u00e9rifi\u00e9e, alors ces prototypes et d\u00e9clarations sont bien ajout\u00e9s au fichier g\u00e9n\u00e9r\u00e9. Sinon, ils sont ignor\u00e9s.</li> <li>Le fichier produit.h devient alors :</li> </ul> <pre><code>#ifndef PRODUIT_H // si PRODUIT_H non d\u00e9j\u00e0 d\u00e9clar\u00e9e\n\n#define PRODUIT_H // ... alors on la d\u00e9clare ! ...\n\n// Et on liste les prototypes \u00e0 inclure dans les autres fichiers:\n\nint produit(int, int);\n\n#endif // FIN instruction conditionnelle\n</code></pre> <ul> <li>Dans le fichier \\(\\texttt{produit.h}\\) on a ajout\u00e9 l'instruction de pr\u00e9processing <code>#ifndef PRODUIT_H</code> dont l'esprit est de signifier \u00ab si la constante PRODUIT_H n'a pas d\u00e9j\u00e0 \u00e9t\u00e9 d\u00e9clar\u00e9e alors voici les  prototypes \u00e0 inclure : ... \u00bb.</li> <li>et on compile en \\(3\\) temps :</li> </ul> <pre><code>gcc \u2212c main.c\ngcc \u2212c produit.c\ngcc main.o produit.o \u2212o prod\n</code></pre>"},{"location":"C/11-CompilSeparee/#makefile","title":"Makefile","text":""},{"location":"C/11-CompilSeparee/#presentation","title":"Pr\u00e9sentation","text":"<ul> <li>Il ne rentre pas dans les comp\u00e9tences exigibles des \u00e9tudiants de CPGE qu'ils sachent \u00e9crire un \\(\\texttt{Makefile}\\). C'est toutefois un outil tr\u00e8s pratique pour automatiser la compilation d'un projet et optimiser le temps pass\u00e9 pour cette op\u00e9ration.</li> <li>On ne donne ici que quelques rudiments de cette technique qui n\u00e9cessiterait un manuel \u00e0 part enti\u00e8re. Consulter par exemple developpez.com pour plus d'informations.</li> </ul>"},{"location":"C/11-CompilSeparee/#syntaxe","title":"Syntaxe","text":"<p>Un Makefile est constitu\u00e9 d'un ensemble de r\u00e8gles de la forme :</p> <pre><code>cible : dependance\ncommandes\n</code></pre>"},{"location":"C/11-CompilSeparee/#utilisation","title":"Utilisation","text":"<p>Supposons qu'on ait cr\u00e9\u00e9 le fichier Makefile dans le r\u00e9pertoire courant. Il y a deux possibilit\u00e9s d'appel :</p> <ul> <li>Ex\u00e9cution de la premi\u00e8re r\u00e8gle rencontr\u00e9e : Cela s'obtient tr\u00e8s facilement en tapant dans un terminal :</li> </ul> <pre><code>$ make\n</code></pre> <ul> <li>Ex\u00e9cution d'une r\u00e8gle sp\u00e9cifique : Il suffit de saisir dans un terminal.</li> </ul> <pre><code>$ make nomDeLaRegle\n</code></pre>"},{"location":"C/11-CompilSeparee/#evaluation-des-regles","title":"\u00c9valuation des r\u00e8gles","text":"<p>L'\u00e9valuation d'une r\u00e8gle se fait en plusieurs \u00e9tapes :</p> <ul> <li>Analyse des d\u00e9pendances : si une d\u00e9pendance est la cible d'une autre r\u00e8gle du Makefile, cette r\u00e8gle est pr\u00e9alablement \u00e9valu\u00e9e.</li> <li>Ex\u00e9cution des commandes : Apr\u00e8s analyse des d\u00e9pendances, si<ul> <li>la cible ne correspond pas \u00e0 un fichier existant</li> <li>ou si un fichier d\u00e9pendance est plus r\u00e9cent que la r\u00e8gle, les diff\u00e9rentes commandes sont ex\u00e9cut\u00e9es.</li> </ul> </li> </ul>"},{"location":"C/11-CompilSeparee/#un-makefile-minimum","title":"Un Makefile minimum","text":"<pre><code>prod : produit.o main.o\n        gcc \u2212o prod produit.o main.o\n\nproduit.o : produit.c\n        #compilation sans lien, avec messages d'erreur et optimisation\n        gcc \u2212o produit.o \u2212c produit.c \u2212Wall \u2212O3\n\nmain.o : main.c\n        #compilation sans lien, avec messages d'erreur et optimisation\n        gcc \u2212o main.o \u2212c main.c \u2212Wall \u2212O3\n</code></pre> <ul> <li>La commande \\(\\texttt{make}\\) lanc\u00e9e dans un terminal depuis le r\u00e9pertoire courant cherche \u00e0 r\u00e9aliser la premi\u00e8re r\u00e8gle rencontr\u00e9e : \\(\\texttt{prod}\\).</li> <li>Il y a deux d\u00e9pendances \\(\\texttt{produit.o}\\) et \\(\\texttt{main.o}\\) qui sont d'ailleurs des r\u00e8gles.</li> </ul>"},{"location":"C/11-CompilSeparee/#dependances-de-la-regle-textttprod","title":"D\u00e9pendances de la r\u00e8gle \\(\\texttt{prod}\\)","text":"<ul> <li>On commence par ex\u00e9cuter la r\u00e8gle \\(\\texttt{produit.o}\\) (\\(1\\)ere d\u00e9pendance de la r\u00e8gle \\(\\texttt{prod}\\)). L'unique d\u00e9pendance de cette r\u00e8gle est un fichier \\(\\texttt{produit.c}\\) qui n'est pas une r\u00e8gle. Le Makefile ex\u00e9cute la commande de cette r\u00e8gle \\(\\texttt{produit.o}\\) si une des conditions suivantes est r\u00e9alis\u00e9e :<ul> <li>le fichier \\(\\texttt{produit.o}\\) n'existe pas dans le r\u00e9pertoire courant,</li> <li>ou bien le fichier \\(\\texttt{produit.c}\\) est plus r\u00e9cent que \\(\\texttt{produit.o}\\). Cela signifie que \\(\\texttt{produit.c}\\) a \u00e9t\u00e9 modifi\u00e9 depuis la derni\u00e8re cr\u00e9ation du module objet \\(\\texttt{produit.o.}\\) Il faut donc reconstruire ce dernier.</li> </ul> </li> <li>Si une des deux conditions ci-dessus est v\u00e9rifi\u00e9e, on ex\u00e9cute la commande <code>gcc -o produit.o -c produit.c -Wall -O3</code> (compilation sans \u00e9dition de lien \\(\\texttt{-c}\\), avec Warnings \\(\\texttt{-Wall}\\) et optimisation compl\u00e8te \\(\\texttt{-O3}\\)).</li> <li>Une fois cette r\u00e8gle ex\u00e9cut\u00e9e, on lance la r\u00e8gle \\(\\texttt{main.o}\\) qui fonctionne sur le m\u00eame principe.</li> </ul>"},{"location":"C/11-CompilSeparee/#execution-de-la-premiere-regle","title":"Ex\u00e9cution de la premi\u00e8re r\u00e8gle","text":"<ul> <li>Toutes les d\u00e9pendances de prod \u00e9tant construites, on ex\u00e9cute la commande associ\u00e9e \u00e0 la r\u00e8gle \\(\\texttt{prod}\\) si :<ul> <li>l'un des fichiers objets \\(\\texttt{.o}\\) n'existe pas dans le r\u00e9pertoire courant,</li> <li>ou l'un des fichiers objets \\(\\texttt{.o}\\) est plus r\u00e9cent que \\(\\texttt{prod}\\).</li> </ul> </li> <li>Dans ce cas, c'est la commande \\(\\texttt{gcc -o prod produit.o main.o}\\) qui est lanc\u00e9e</li> </ul>"},{"location":"C/11-CompilSeparee/#nettoyage-et-regeneration","title":"Nettoyage et r\u00e9g\u00e9n\u00e9ration","text":"<p>Avec le Makefile pr\u00e9c\u00e9dent, on ne peut pas cr\u00e9er plusieurs ex\u00e9cutables, ni supprimer les fichiers interm\u00e9diaires \\(\\texttt{.o}\\) (ils restent sur le disque dur) ni forcer la r\u00e9g\u00e9n\u00e9ration compl\u00e8te du projet.</p> <ul> <li>En effet, les fichiers objets \\(\\texttt{produit.o}\\) et \\(\\texttt{main.o}\\) sont rest\u00e9s sur le disque dur. Lorsqu'on relance la commande \\(\\texttt{make}\\), on obtient le message suivant :</li> </ul> <pre><code>make : &lt;&lt; prod &gt;&gt; est \u00e0 jour.\n</code></pre> <p>On rajoute alors trois r\u00e8gles qui portent, par convention, les noms \\(\\texttt{all}\\), \\(\\texttt{clean}\\), \\(\\texttt{mrproper}\\) :</p> <ul> <li>\\(\\texttt{all}\\) : on la fait suivre de la ou des r\u00e8gles de construction d'ex\u00e9cutables ; pour nous c'est seulement \\(\\texttt{prod}\\).</li> <li>\\(\\texttt{clean}\\) : on d\u00e9cide ici de lui faire supprimer tous les fichiers objets (mais ce pourrait \u00eatre d'autres types de fchiers).</li> <li>\\(\\texttt{mrproper}\\) : un nettoyage complet. Le Makefile engendre un fichier ex\u00e9cutable \\(\\texttt{prod}\\) et des fichiers objets. On d\u00e9clare \\(\\texttt{clean}\\) comme d\u00e9pendance, ce qui a pour effet de supprimer les fichiers objets. Puis il reste \u00e0 supprimer le fichier ex\u00e9cutable \\(\\texttt{prod}\\).</li> </ul>"},{"location":"C/11-CompilSeparee/#makefile-plus-complet","title":"Makefile plus complet","text":"<pre><code>all : prod\n\nprod : produit.o main.o\n        gcc \u2212o prod produit.o main.o\n\nproduit.o : produit.c\n        gcc \u2212o produit.o \u2212c produit.c \u2212W \u2212O3\n\nmain.o : main.c\n        gcc \u2212o main.o \u2212c main.c \u2212W \u2212O3\n\nclean :\n        rm \u2212rf \u2217.o\n\nmrproper : clean\n        rm prod\n</code></pre>"},{"location":"C/12-EntreeSorties/","title":"Lecture \u00e9criture dans des fichiers : langage \\(\\texttt{C}\\)","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Un cours du site OpenClassRoom</li> <li>Un cours de Anne Canteaut</li> </ul>"},{"location":"C/12-EntreeSorties/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"C/12-EntreeSorties/#manipuler-un-fichier","title":"Manipuler un fichier","text":"<ul> <li>Les acc\u00e8s \u00e0 un fichier du disque dur se font par l'interm\u00e9diaire d'un buffer (ou m\u00e9moire tampon). Cela permet de limiter le nombre d'acc\u00e8s aux p\u00e9riph\u00e9riques (disque dur, cl\u00e9 USB etc).</li> <li>Pour manipuler un fichier, il faut :<ul> <li>l'adresse o\u00f9 il est stock\u00e9 dans la m\u00e9moire tampon,</li> <li>la position de la t\u00eate de lecture dans le fichier,</li> <li>le mode d'acc\u00e8s (lecture ou \u00e9criture) etc.</li> </ul> </li> <li>Ces informations sont contenues dans une structure <code>FILE</code> d\u00e9finie dans <code>stdio.h</code>. Cependant, on ne manipule pas directement les objets de ce type, seulement un pointeur sur ces objets.</li> <li>Un objet de type <code>FILE *</code> est appel\u00e9 un flot de donn\u00e9es (ou stream en anglais).</li> <li>La fonction qui permet l'acc\u00e8s \u00e0 un fichier est <code>fopen</code>. Elle est d\u00e9crite dans <code>stdio.h</code>.</li> </ul>"},{"location":"C/12-EntreeSorties/#sequence-des-operations","title":"S\u00e9quence des op\u00e9rations","text":"<ul> <li>Ouverture du fichier dans le mode d\u00e9sir\u00e9 (read, write..) avec <code>fopen</code>. On r\u00e9cup\u00e8re un flot de donn\u00e9es.</li> <li>V\u00e9rification du succ\u00e8s de l'ouverture : le flot doit \u00eatre diff\u00e9rent de <code>NULL</code>.</li> <li>Manipulation proprement dite en cas de succ\u00e8s d'ouverture. On utilise des fonctions d\u00e9crites plus loin.</li> <li>Annulation de la liaison entre le flot et le fichier par la fonction <code>fclose</code>.</li> </ul>"},{"location":"C/12-EntreeSorties/#prototype","title":"Prototype","text":"<pre><code>FILE\u2217 fopen(const char\u2217 restrict filename,\n            const char\u2217 restrict accessMode);\n</code></pre> <p>On indique un nom de fichier et un type d'acc\u00e8s (lecture/\u00e9criture et texte/binaire). On r\u00e9cup\u00e8re un flot.</p> <ul> <li>Arguments :<ul> <li>\\(\\color{blue}\\text{filename}\\) : d\u00e9finit le nom du fichier \u00e0 ouvrir. On peut sp\u00e9cifier un chemin absolu ou relatif. Pour plus de portabilit\u00e9, \\(\\underline{\\text{pr\u00e9f\u00e9rer les chemins relatifs}}\\). En fonction du syst\u00e8me d'exploitation consid\u00e9r\u00e9, le nom du fichier sera sensible \u00e0 la casse (diff\u00e9rences entre minuscules et majuscules) ou non.</li> <li>\\(\\color{blue}\\text{accessMode}\\) : mode d'ouverture du fichier.</li> </ul> </li> </ul>"},{"location":"C/12-EntreeSorties/#note","title":"Note","text":"<p>On pr\u00e9cise le sens du mot cl\u00e9 <code>restrict</code> utilis\u00e9 dans le prototype de la fonction <code>fopen</code>.</p> <ul> <li>A partir du standard \\(\\text{C99}\\), le mot cl\u00e9 <code>restrict</code> est une d\u00e9claration d'intention faite par le programmeur pour le compilateur au moment de la d\u00e9claration d'un pointeur.</li> <li>Il indique que, pour la dur\u00e9e de vie du programme, seul le pointeur (ou une valeur qui en est issue directement comme <code>pointeur+1</code>) sera utilis\u00e9 pour acc\u00e9der \u00e0 l'objet sur lequel il pointe.</li> <li>Une telle d\u00e9claration peut permettre au compilateur d'optimiser le code.</li> <li>Si la d\u00e9claration d'intention n'est pas respect\u00e9e, le comportement du compilateur est Undefined Behaviour.</li> <li>C'est au programmeur de s'assurer que la d\u00e9claration d'intention est bien respect\u00e9e, pas au compilateur.</li> </ul>"},{"location":"C/12-EntreeSorties/#modes-douverture","title":"Modes d'ouverture","text":"<p>Il faut faire figurer ces modes entre guillements (par exemple <code>\"r\"</code>).</p> <ul> <li>\\(\\color{blue}\\text{r}\\) : ouverture d'un fichier texte en lecture,</li> <li>\\(\\color{blue}\\text{w}\\) : ouverture d'un fichier texte en \u00e9criture avec \u00e9crasement,</li> <li>\\(\\color{blue}\\text{a}\\) : ouverture d'un fichier texte en \u00e9criture \u00e0 la fin,</li> <li>\\(\\color{blue}\\text{rb,wb,ab}\\) : ouverture d'un fichier binaire en lecture, \u00e9criture ou ajout</li> <li>\\(\\color{blue}\\text{r+}\\) : ouverture d'un fichier texte en lecture/\u00e9criture (\u00e9quivalent \u00e0 w+),</li> <li>\\(\\color{blue}\\text{a+}\\) ouverture d'un fichier texte en lecture/ et \u00e9criture \u00e0 la fin,</li> <li>\\(\\color{blue}\\text{r+b}\\) ouverture d'un fichier binaire en lecture/\u00e9criture (\u00e9quivalent \u00e0 w+b).</li> <li>\\(\\color{blue}\\text{a+b}\\) : \u00e0 votre avis ?</li> </ul> <p>Si le mode contient :</p> <ul> <li>la lettre <code>r</code>, le fichier doit exister.</li> <li>la lettre <code>w</code>, le fichier peut ne pas exister. Dans ce cas, il est cr\u00e9\u00e9. Si le fichier existe d\u00e9j\u00e0, son ancien contenu sera perdu.</li> <li>la lettre <code>a</code>, le fichier peut ne pas exister. Dans ce cas, il est cr\u00e9\u00e9. Si le fichier existe d\u00e9j\u00e0, les ouvelles donn\u00e9es sont ajout\u00e9es \u00e0 la fin du fichier.</li> </ul>"},{"location":"C/12-EntreeSorties/#flots-standard","title":"Flots standard","text":"<p>Trois flots standard peuvent \u00eatre utilis\u00e9s en \\(\\texttt{C}\\) sans qu'il soit n\u00e9cessaire de les ouvrir ou de les fermer :</p> <ul> <li>\\(\\color{blue}\\text{stdin}\\) : (standard input) : unit\u00e9 d'entr\u00e9e (par d\u00e9faut, le clavier),</li> <li>\\(\\color{blue}\\text{stdout}\\) : unit\u00e9 de sortie (par d\u00e9faut, l'\u00e9cran),</li> <li>\\(\\color{blue}\\text{stderr}\\) : unit\u00e9 d'affichage des messages d'erreur (par d\u00e9faut, l'\u00e9cran).</li> </ul> <p>Remarque</p> <ul> <li>On peut r\u00e9d\u00e9finir ces flots.</li> <li>Le plus souvent, on ne modifie pas <code>stderr</code> pour pouvoir lire \u00e0 l'\u00e9cran les messages d'erreurs et les mises en garde (WARNING).</li> </ul>"},{"location":"C/12-EntreeSorties/#fermeture","title":"Fermeture","text":"<ul> <li>La fonction fclose ferme un flot et coupe la liaison avec le fichier qu'il pointe :</li> </ul> <pre><code>int fclose (FILE \u2217stream);\n</code></pre> <ul> <li>Lors de la fermeture d'un flot :<ul> <li>le buffer en m\u00e9moire associ\u00e9 est automatiquement synchronis\u00e9 (<code>fflush</code> si le flot est ouvert en \u00e9criture), et est lib\u00e9r\u00e9 automatiquement (ce n'est pas le programmeur qui le lib\u00e8re).</li> <li>Les op\u00e9rations d'\u00e9critures sont souvent enregistr\u00e9es en m\u00e9moire-tampon puis toutes effectu\u00e9es dans le fichier cible \u00e0 la fermeture du flot</li> </ul> </li> <li>Si la fermeture se d\u00e9roule<ul> <li>sans erreur : la valeur \\(0\\) est retourn\u00e9e.</li> <li>avec erreur : la constante EOF de <code>stdlib.h</code> est retourn\u00e9e. Du fait de l'utilisation de EOF, il est utile d'importer <code>stdlib.h</code>.</li> </ul> </li> </ul>"},{"location":"C/12-EntreeSorties/#ecriture","title":"\u00c9criture","text":""},{"location":"C/12-EntreeSorties/#3-fonctions-decriture","title":"\\(3\\) fonctions d'\u00e9criture","text":"<ul> <li>\\(\\color{blue}\\textbf{fputc}\\) : \u00e9crit un caract\u00e8re dans le fichier (UN SEUL caract\u00e8re \u00e0 la fois),</li> <li>\\(\\color{blue}\\textbf{fputs}\\) : \u00e9crit une cha\u00eene dans le fichier ;</li> <li>\\(\\color{blue}\\textbf{fprintf}\\) : \u00e9crit une cha\u00eene \u00ab format\u00e9e \u00bb dans le fichier, fonctionnement quasi-identique \u00e0 <code>printf</code>.</li> </ul> <p>Seule <code>fprintf</code> est explicitement au programme.</p>"},{"location":"C/12-EntreeSorties/#ecriture-par-chaine-formatee","title":"Ecriture par cha\u00eene format\u00e9e","text":"<pre><code>int fprintf(FILE \u2217restrict stream,\n            const char \u2217restrict format, ... ) ;\n</code></pre> <p>\u00c9crit une cha\u00eene de caract\u00e8res format\u00e9e sur un flot. La cha\u00eene pass\u00e9e en argument n'est pas modifi\u00e9e. Les arguments de printf sont d'abord le flot, puis la cha\u00eene \u00e0 formater et enfin ses arguments.</p> <pre><code>int main(void){\n    FILE\u2217flot = fopen(\"test3. txt \", \"w\");\n    if (flot != NULL){\n        int a=1, b=2, c=5;\n        fprintf(flot, \"Est\u2212ce que %d+%d=%d?\\n\", a, b, c);\n        fclose(flot);\n    }\n    else printf(\"PB\\n\");\n}\n</code></pre> <p>Apr\u00e8s compilation puis ex\u00e9cution du pgm ; la lecture de test3.txt donne :</p> Rendu<pre><code>Est-ce que 1+2=5?\n</code></pre>"},{"location":"C/12-EntreeSorties/#sortie-standard-et-printf","title":"Sortie standard et <code>printf</code>","text":"<p><code>printf(...)</code> \u00e9crit sur le flux de sortie standard stdout. <code>printf(...)</code> est \u00e9quivalent \u00e0 <code>fprintf(stdout,...)</code></p>"},{"location":"C/12-EntreeSorties/#lire","title":"Lire","text":""},{"location":"C/12-EntreeSorties/#lecture-par-chaine-formatee","title":"Lecture par cha\u00eene format\u00e9e","text":"<ul> <li>Prototype :</li> </ul> <pre><code>int fscanf (FILE\u2217 restrict stream,\n            const char\u2217 restrict format, ...);\n</code></pre> <ul> <li> <ul> <li>\\(\\color{blue}\\text{stream}\\) : repr\u00e9sente le flot sur lequel les extractions de valeurs devront \u00eatre r\u00e9alis\u00e9es.</li> <li>\\(\\color{blue}\\text{format}\\) : repr\u00e9sente le format \u00e0 utiliser pour d\u00e9coder la cha\u00eene de caract\u00e8res.</li> </ul> </li> <li> <p>les descripteurs de format sont communs \u00e0 scanf ou fscanf.</p> </li> <li>Cette fonction <code>fscanf</code> s'emploie souvent lorsque le fichier \u00e0 lire est \u00e9crit selon des r\u00e8gles pr\u00e9cises (voir plus loin).</li> <li>Valeur de retour : le nombre de param\u00e8tres qui ont pu \u00eatre extraits ou bien <code>EOF</code>.</li> </ul> <p>Consid\u00e9rons un fichier coordonn\u00e9es.txt dans le r\u00e9pertoire courant. Chaque ligne de ce fichier contient le nom d'un point du plan suivi de ses \\(2\\) coordonn\u00e9es :</p> <pre><code>P1 10.3 2.1\nP2 13.2 12.0\n</code></pre> <p>Le code ci-dessous boucle sur toutes les lignes du fichier et r\u00e9cup\u00e8re le nom, la premi\u00e8re puis la seconde coordonn\u00e9e du point d\u00e9crit. Ces valeurs sont mises en contenu d'une cha\u00eene de caract\u00e8res et de deux variables d\u00e9cimales.</p> <pre><code>int main(void){\n    char chain [100];\n    float x , y;\n    FILE\u2217 flot = fopen(\"coordonn\u00e9es.txt\", \"r\");\n    if (flot != NULL){\n        while (fscanf(flot, \"%s %g %g\",chaine, &amp;x, &amp;y) != EOF){\n            //%g pour optimiser l'affichage des float\n            printf (\"point %s, x=%g, y=%g\\n\", chaine, x, y);\n        }\n        fclose (flot);\n    }// fin if\n    else printf (\"PB\\n\");\n}// fin main\n</code></pre> <p>Apr\u00e8s compilation et ex\u00e9cution, on obtient</p> Rendu<pre><code>point P1 , x=10.3 , y=2.1\npoint P2 , x=13.2 , y=12\n</code></pre>"},{"location":"C/12-EntreeSorties/#entree-standard-et-scanf","title":"Entr\u00e9e standard et <code>scanf</code>","text":"<ul> <li><code>scanf(...)</code> lit sur le flux d'entr\u00e9e standard stdin.</li> <li><code>scanf(...)</code> est \u00e9quivalent \u00e0 <code>fscanf(stdin,...)</code></li> </ul>"},{"location":"C/12-EntreeSorties/#ligne-de-commandes","title":"Ligne de commandes","text":""},{"location":"C/12-EntreeSorties/#arguments-dun-programme","title":"Arguments d'un programme","text":"<ul> <li>Les arguments de la ligne de commande d'un programme \\(\\texttt{C}\\) sont pass\u00e9s \u00e0 la fonction <code>main</code> sous forme de deux param\u00e8tres : un entier donnant le nombre d'\u00e9l\u00e9ments sur la ligne de commande; un tableau de cha\u00eenes de caract\u00e8res.</li> </ul> <pre><code>int main(int argc , char\u2217\u2217argv) {...\n}\n</code></pre> <ul> <li>Le nom du programme est le premier argument de la ligne de commande.</li> <li>Les arguments sont exclusivement des cha\u00eenes de caract\u00e8res. Si on pr\u00e9voit de prendre des arguments num\u00e9riques, il faut utiliser une fonction comme <code>atoi</code> (ASCII to integer) :</li> </ul> <pre><code>#include &lt;stdlib.h&gt;\nint atoi(const char\u2217 theString);\n</code></pre> <p>Transforme une cha\u00eene de caract\u00e8res, repr\u00e9sentant une valeur enti\u00e8re, en une valeur num\u00e9rique de type <code>int</code> .</p> <p>Le programme suivant lit deux entiers en ligne de commande, affiche son propre nom, les entiers saisis et enfin leur produit.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;assert.h&gt;\n\nint main(int argc , char \u2217\u2217argv){\n    assert (argc == 3);\n    printf (\"programme %s\\n\",argv[0]);//nom du pgm\n    int a = atoi(argv [1]) , b= atoi(argv [2]) ; // entiers saisis\n    int p = a\u2217b;\n    printf (\"%d \u2217%d = %d\\n\", a, b, p);\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>Attention</p> <p>La fonction <code>atoi</code> retourne \\(0\\) si la cha\u00eene de caract\u00e8res ne contient pas une repr\u00e9sentation de valeur num\u00e9rique. Il n'est donc pas possible de distinguer la cha\u00eene <code>\"0\"</code> d'une cha\u00eene ne contenant pas un nombre entier. Pr\u00e9f\u00e9rer <code>strtol</code> dans ce cas.</p> <ul> <li>On compile avec <code>gcc -Wall commande.c -o produit</code></li> <li>Ex\u00e9cution :</li> </ul> Rendu<pre><code>$./produit 10 3\nprogramme ./produit\n10 \u22173 = 30\n</code></pre>"},{"location":"C/13-hasard/","title":"Hasard en \\(\\texttt{C}\\)","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <p>Adapt\u00e9 du site developpez.com.</p> <p>Les nombres al\u00e9atoires (ou plut\u00f4t pseudo-al\u00e9atoires car le hasard n'existe pas en informatique) ne sont pas au programme. La biblioth\u00e8que \\(\\texttt{stdlib}\\) fournie deux fonctions <code>rand</code> et <code>srand</code> dont nous nous contentons.</p> <p>La seconde sert \u00e0 initialiser une graine (un nombre utilis\u00e9 par la suite dans la production de nombres pseudo-al\u00e9atoires). Elle n'est appel\u00e9e qu'une fois par programme.</p> <p>La premi\u00e8re fonction utilise la graine pour calculer des nombres. Les nombres produits vivent entre \\(0\\) et <code>RAND_MAX</code> dont la valeur est d\u00e9finie dans \\(\\texttt{stdlib}\\). Sur ma machine, ce maximum vaut \\(2^{31} \u22121\\). Affichez le sur la v\u00f4tre.</p> <p>Par d\u00e9faut, la gra\u00eene est de \\(1\\) (c'est en particulier ce qu'il se passe si on n'appelle pas <code>srand</code> explicitement). Compiler et ex\u00e9cuter le code suivant plusieurs fois :</p> <pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nint my_rand(void);\n\nint main ( void) {\n    int i ;\n\n    for (i = 0; i &lt; 10; i++){\n        printf(\"%d\\n\", my_rand());\n    }\n    return (EXIT_SUCCESS) ;\n}\n\nint my_rand(void){\n    return (rand()) ;\n}\n</code></pre> <p>On observe que la s\u00e9quence des nombres est toujours identique, ce qui n'est pas bien vu pour des nombres al\u00e9atoires. Cela vient de la graine : elle vaut toujours \\(1\\).</p> <p>Remarque</p> <p>Lorsqu'on est en phase de d\u00e9buggage d'un projet n\u00e9cessitant du hasard, il est utile d'obtenir toujours les m\u00eames valeurs par rand . On laisse donc la graine \u00e0 une valeur connue. En phase d'exploitation, on choisit une graine moins pr\u00e9visible comme expliqu\u00e9 ci-dessous.</p> <p>Utilisons une autre valeur : le temps courant. On l'obtient en incluant l'en-t\u00eate <code>&lt;time.h&gt;</code> et en appelant <code>time(NULL)</code>. L'usage du pointeur <code>NULL</code> signifie simplement qu'on ne stocke pas la valeur produite \u00e0 une adresse particuli\u00e8re : on se contente juste de la calculer.</p> <p>Changeons le code de <code>my_rand</code> :</p> <pre><code>int my_rand(void){\n    static int first = 0;\n\n    if (first == 0){\n        srand(time(NULL));\n        first = 1;\n    }\n    return (rand());\n}\n</code></pre> <p>Remarque</p> <p>La variable <code>first</code> est statique : elle a une adresse fixe qui ne d\u00e9pend pas du nombre d'appel \u00e0 <code>myrand</code> . Au premier ou au \\(100\\)\u00e8me appel, l'adresse de cette variable est la m\u00eame.</p> <p>Au premier appel, <code>first</code> vaut \\(0\\). On rentre alors dans la branche positive du <code>if</code> . La graine est initialis\u00e9e avec la valeur courante du temps (nombre de secondes depuis le \\(1\\)er janvier \\(1970\\) \u00e0 priori) et n'est plus jamais modifi\u00e9e puisque <code>first</code> est diff\u00e9rent de \\(0\\).</p> <p>Tous les appels \u00e0 <code>rand</code> utilisent alors cette graine initiale.</p> <p>Compiler. Relancer plusieurs fois le programme. On constate que deux lancement du programme effectu\u00e9s dans la m\u00eame seconde donnent le m\u00eame r\u00e9sultat : c'est normal, le temps courant (donc la graine) est le m\u00eame. Mais deux appels s\u00e9par\u00e9s de plus d'une seconde donnent deux r\u00e9sultats diff\u00e9rents. Nous nous en contentons.</p> <p>Le probl\u00e8me maintenant c'est que les nombres produits sont dans l'intervalle entre \\(0\\) et <code>RAND_MAX</code>.</p> <p>Pour un entier \\(n\\), on peut ramener le nombre al\u00e9atoire produit dans \\([\\![0, n-1]\\!]\\) en prenant le modulo selon \\(n\\) : <code>nb_produit % n</code> .</p> <p>Malheureusement, la distribution ainsi obtenue n'est plus uniforme. certains nombres ont plus de chance d'\u00eatre produits que d'autres. Avec \\(n = 10\\) et \\(25\\) pour <code>RAND_MAX</code> , on obtient :</p> Valeur calcul\u00e9e par <code>rand</code> Valeur apr\u00e8s modulo \\([0, 10[\\) \\([0, 10[\\) \\([10, 20[\\) \\([0, 10[\\) \\([20, 25[\\) \\([0, 5[\\) <p>Les nombres entre \\(0\\) et \\(5\\) ont plus de chance d'\u00eatre obtenus que les autres. On se contente n\u00e9mamoins de ce calcul modulo.</p> <p>Voici donc la fonction <code>int my_rand(int n)</code> qui renvoie un nombre entre \\(0\\) et \\(n\u22121\\) :</p> <pre><code>int my_rand ( int n) {\n    static int first = 0;\n\n    if (first == 0){\n        srand(time(NULL));\n        first = 1;\n    }\n    return (rand() % n);\n}\n</code></pre>"},{"location":"Divers/1-Backtracking/","title":"Backtracking","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <p>Un cours de Sol\u00e8ne Mirliaz ; Cette page de Wikipedia</p>"},{"location":"Divers/1-Backtracking/#probleme-dexploration","title":"Probl\u00e8me d'exploration","text":"<p>D\u00e9finition</p> <p>Un probl\u00e8me d\u2019exploration (ou de recherche) est un probl\u00e8me algorithmique \\(P\\) donn\u00e9 par une relation binaire \\(R\u2282E \u00d7(S \\sqcup  \\{None\\})\\) telle qu\u2019il existe deux sous-ensembles not\u00e9s \\(E^+\\), \\(E^\u2212\\) de \\(E\\) formant une partition de \\(E\\) et v\u00e9rifiant :</p> <p>\\(R\u2282(E^+ \\times S )\\sqcup (E^\u2212 \\times \\{None\\})\\)</p> <p>Remarque</p> <p>Les \u00e9l\u00e9ments de \\(E\\) sont appel\u00e9s des entr\u00e9es et ceux de \\(S\\) des solutions;</p> <p>Le fait que l\u2019union soit disjointe interdit d\u2019avoir une entr\u00e9e \\(e\\) et une solution \\(s\\) telles que \\((e, s) \u2208R\\) et \\((e, None) \u2208R\\).</p>"},{"location":"Divers/1-Backtracking/#vocabulaire-solution","title":"Vocabulaire : solution","text":"<p>Avec les notations de la d\u00e9finition pr\u00e9c\u00e9dente :</p> <ul> <li>si \\((e, s ) \u2208E \u00d7S\\) , on dit que \\(s\\) est une solution de l\u2019entr\u00e9e \\(e\\);</li> <li>si \\((e, Node) \u2208R\\), on dit que l\u2019entr\u00e9e \\(e\\) n\u2019a pas de solution.</li> </ul>"},{"location":"Divers/1-Backtracking/#backtracking-presentation-informelle","title":"Backtracking : pr\u00e9sentation informelle","text":"<p>D\u00e9finition</p> <p>Le backtracking (ou retour sur trace) est une classe d\u2019algorithmes cherchant la solution de probl\u00e8mes d\u2019exploration.</p> <p>Notamment les probl\u00e8mes avec contraintes de satisfactions comme le Sudoku o\u00f9 les \\(N\\)-reines sont r\u00e9solubles par backtracking.</p> <p>Le backtracking construit incr\u00e9mentalement des candidats-solutions partiels qui sont abandonn\u00e9s d\u00e8s lors qu\u2019on \u00e9tablit qu\u2019ils ne peuvent pas \u00eatre compl\u00e9t\u00e9s en une solution.</p> <p>Conceptuellement, les candidats-solutions partiels sont repr\u00e9sent\u00e9s comme des n\u0153uds d\u2019une structure arborescente : l\u2019arbre de recherche potentiel.</p> <p>Chaque candidat-solution partiel est le parent d\u2019autres candidats-solutions qui diff\u00e8rent de lui par une simple \u00e9tape d\u2019extension (par exemple ajout d\u2019un \u00e9l\u00e9ment unique \u00e0 une liste).</p> <p>Les feuilles sont les candidats-solutions qui ne peuvent pas \u00eatre d\u00e9velopp\u00e9s plus avant (ce sont des candidats-solutions complets). Certains candidats-solutions complets sont effectivement des solutions, d\u2019autres non.</p>"},{"location":"Divers/1-Backtracking/#backtracking-arbre-de-decision","title":"Backtracking : arbre de d\u00e9cision","text":"<p>L\u2019algorithme de backtracking parcourt l\u2019arbre de recherche potentiel par un DFS.</p> <p>\u00c0 chaque n\u0153ud \\(c\\) (donc, un candidat-solution), l\u2019algorithme cherche si \\(c\\) peut \u00eatre compl\u00e9t\u00e9 en une solution valide.</p> <ul> <li>Si ce n\u2019est pas possible, le sous-arbre de racine \\(c\\) dans l\u2019arbre solution est supprim\u00e9.</li> <li>Par ailleurs, si \\(c\\) est une feuille, l\u2019algorithme cherche si \\(c\\) lui-m\u00eame peut \u00eatre consid\u00e9r\u00e9 comme une solution valide (exemple une grille compl\u00e8tement remplie constitue-t-elle une solution au probl\u00e8me de Sudoku ?).</li> </ul> <p>L\u2019arbre effectivement parcouru par le backtracking est un sous-arbre (souvent strict) de l\u2019arbre de recherche potentiel.</p>"},{"location":"Divers/1-Backtracking/#algorithme-de-backtracking","title":"Algorithme de Backtracking","text":"<pre><code>fonction backtrack(e, c):\n    entree : e entr\u00e9e du probl\u00e8me; c candidat\u2212solution partiel\n    sortie : une solution de e s'il en existe, None sinon\n    debut\n        si c est un candidat\u2212solution complet(une feuille) alors\n            si c est une solution de e alors renvoyer c\n            sinon renvoyer None;\n        sinon\n            pour tout c' fils candidat\u2212solution POSSIBLE de c faire\n                v \u27f5 backtrack(e, c');\n                si v \u2260 None alors renvoyer v\n            renvoyerNone;\n    fin\n</code></pre> <p>Remarque Un candidat-solution impossible est un candidat dont on se rend compte qu\u2019il ne peut pas \u00eatre compl\u00e9t\u00e9 en une solution.La d\u00e9tection pr\u00e9coce des candidats-solutions impossibles permet de limiter le co\u00fbt de l\u2019exploration.</p>"},{"location":"Divers/1-Backtracking/#complexite","title":"Complexit\u00e9","text":"<p>La complexit\u00e9 d\u2019un algorithme de backtracking de recherche de solution pour une entr\u00e9e \\(e\\) d\u00e9pend en particulier de la taille de l\u2019arbre explor\u00e9.</p> <p>On se place dans le cas le pire o\u00f9 aucune d\u00e9tection pr\u00e9coce de candidat impossible n\u2019est d\u00e9tect\u00e9e.</p> <p>Il faut alors explorer tout l\u2019arbre de d\u00e9cision.</p> <p>Complexit\u00e9</p> <p>On note \\(h\\) la hauteur de l\u2019arbre et \\(p\\), l\u2019arit\u00e9 maximum d\u2019un n\u0153ud. L\u2019arbre est alors de taille \\(\\sum_{i=0}^{h}{p^i} = O(p^h)\\).</p> <p>Le test de d\u00e9tection pr\u00e9coce d\u2019impossibilit\u00e9 pour un candidat \\(c\\) a une complexit\u00e9 en \\(O (g(|c|))\\) pour une certaine fonction \\(g\\).</p> <p>La taille \\(|c|\\) du candidat est domin\u00e9e grossi\u00e8rement par un \\(k (|e|)\\) pour une certaine fonction \\(k\\) ne d\u00e9pendant que de \\(e\\).</p> <p>Ainsi, la d\u00e9tection pr\u00e9coce est en \\(O (g\u25e6k (|e|))\\)</p> <p>Lorsque le candidat \\(c\\) est une feuille, le test de validit\u00e9 du candidat comme solution est en \\(O (l(|c |))\\) donc en \\(O (l \u25e6k (|e|))\\) pour une certaine fonction \\(l\\)</p> <p>Bref, il existe \\(f\\), tel que pour tout candidat \\(c\\), la d\u00e9tection pr\u00e9coce et le test de validit\u00e9 ont une complexit\u00e9 en \\(O (f (|e|))\\) o\u00f9 \\(f = max(g \u25e6k , l \u25e6k )\\).</p> <p>Ainsi, le backtracking a une complexit\u00e9 major\u00e9e par un \\(O (p^h \\times f(|e|))\\)</p>"},{"location":"Divers/2-Serialisation/","title":"S\u00e9rialisation","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Informatique MP2I et MPI - CPGE 1re et 2e ann\u00e9es - Nouveaux programmes \"(Vincent Barra)\"</li> <li>Wikipedia</li> </ul>"},{"location":"Divers/2-Serialisation/#presentation","title":"Pr\u00e9sentation","text":"<p>La s\u00e9rialisation est le codage d'une information sous la forme d'une suite d'informations plus petites (dites atomiques) pour, par exemple, sa sauvegarde (persistance) ou son transport sur le r\u00e9seau (proxy, RPC... ).</p> <p>L'activit\u00e9 r\u00e9ciproque, visant \u00e0 d\u00e9coder cette suite pour cr\u00e9er une copie conforme de l'information d'origine, s'appelle la d\u00e9s\u00e9rialisation (ou unmarshalling).</p>"},{"location":"Divers/2-Serialisation/#difficultes","title":"Difficult\u00e9s","text":"<p>Plus le m\u00e9canisme de s\u00e9rialisation est sp\u00e9cialis\u00e9 dans un type de donn\u00e9es sp\u00e9cifiques plus il est performant.</p> <p>Si on veut coder des entiers de valeurs entre \\(0\\) et \\(255\\), il suffit de un octet par entier.</p> <p>Si on veut coder un nombre arbitraire d'entiers de valeurs entre \\(0\\) et \\(255\\), il faut ajouter des octets suppl\u00e9mentaires pour transmettre l'information sur le nombre.</p> <p>Si ce ne sont pas des entiers mais des objets complexes, il faut associer des informations permettant de coder le type pr\u00e9cis de chaque objet.</p>"},{"location":"Divers/2-Serialisation/#dilemne-precision-de-linformationtaille-du-fichier-genere","title":"Dilemne : Pr\u00e9cision de l'information/Taille du fichier g\u00e9n\u00e9r\u00e9","text":"<p>Il y a un choix \u00e0 faire selon que l'on veut privil\u00e9gier une d\u00e9s\u00e9rialisation \u00e0 l'identique du fichier s\u00e9rialis\u00e9 ou la place prise par ce fichier.</p> <p>La police de caract\u00e8re dans un fichier PDF :</p> <ul> <li>on peut transmettre la description compl\u00e8te du trac\u00e9 des caract\u00e8res,</li> <li>ou bien on peut indiquer seulement le nom de la police et quelques autres caract\u00e9ristiques et laisser le soin \u00e0 la machine distante de choisir elle-m\u00eame la police la plus adapt\u00e9e parmi celles dont elle dispose.</li> </ul>"},{"location":"Divers/2-Serialisation/#informations-non-serialisables","title":"Informations non s\u00e9rialisables","text":"<p>Certaines informations ne sont pas s\u00e9rialisables.</p> <p>Le descripteur de fichier : d'une machine \u00e0 l'autre, ces descripteurs sont attribu\u00e9s de fa \u0327con arbitraires par le syst\u00e8me d'exploitation : s\u00e9rialiser leur contenu n'a donc pas de sens. Il faut plut\u00f4t encoder des informations qui permettront de reconstruire le descripteur au moment de la d\u00e9s\u00e9rialisation.</p> <p>Un autre exemlpe plus pertinent est : la s\u00e9rialisation des pointeurs</p>"},{"location":"Divers/2-Serialisation/#choix-de-lencodage","title":"Choix de l'encodage","text":"<p>encodage binaire : les fichiers binaires sont plus compacts, le code pour parser (analyser) ce type de donn\u00e9es est plus simple \u00e0 mettre en \u0153uvre, la lecture et l'\u00e9criture sont moins exigeantes en ressources processeurs ;</p> <p>encodage textuel : les fichiers textes sont plus simples \u00e0 v\u00e9rifier ou modifier \u00e0 la main, ils posent moins de probl\u00e8mes de portabilit\u00e9 et sont plus simples \u00e0 maintenir ou \u00e0 faire \u00e9voluer.</p>"},{"location":"Divers/2-Serialisation/#codage-binaire","title":"Codage binaire","text":"<p>Contrainte de portabilit\u00e9</p> <ul> <li> <p>Si la machine distante utilise un autre processeur, elle doit pouvoir d\u00e9s\u00e9rialiser un bloc de donn\u00e9es en tenant compte :</p> <ul> <li>des probl\u00e8mes d'alignement : si on transmet un caract\u00e8re (\\(1\\) octet) puis un entier (\\(4\\) octets), doit on compter en tout \\(4\\) octets en \"concat\u00e9nant \"la fin du caract\u00e8re avec le d\u00e9but de l'entier, ou au contraire pr\u00e9voire \\(4\\) octets par donn\u00e9es (et donc en utilisant inutilement \\(3\\) octets de trop pour le caract\u00e8re)</li> <li>ou d'endianness (boutisme) : o\u00f9 est le bit de poids fort ?</li> <li>Il est utile d'utiliser des conventions. Par exemple :</li> <li>pas d'alignement,</li> <li>encodage des types entiers C en fonction de leur empreinte m\u00e9moire ; tout en big-endian</li> <li>les nombres \u00e0 vigules flottantes sont cod\u00e9es selon la norme \\(IEEE754\\)</li> </ul> </li> </ul> <p>Protocoles \\(GIOP\\) de \\(CORBA\\) ; \\(RMI\\) de \\(Java\\)</p>"},{"location":"Divers/2-Serialisation/#codage-textuel","title":"Codage textuel","text":"<p>Choisir un protocole pour s\u00e9parer les champs, pour encoder des donn\u00e9es binaires</p> <p>Dans le pass\u00e9, on utilisait souvent un d\u00e9riv\u00e9 de \\(XML\\) (e\\(X\\)tended \\(M\\)arkup \\(L\\)angauge). En \\(2019\\), le codage texte le plus r\u00e9pandu \u00e9tait \\(JSON\\) (\\(J\\)ava\\(S\\)cript \\(O\\)bject \\(N\\)otation). \u00c9mergence du standard \\(Protobug\\) de Google.</p> <p>Codages bas\u00e9s sur des fichiers textes \\(XML:SOAP\\), \\(XML-RPC\\) Autre exemple \\(CSV\\) (\\(C\\)omma \\(S\\)eparated \\(V\\)alues) ;</p>"},{"location":"Divers/2-Serialisation/#json","title":"JSON","text":"<p>Format simple de stockage de donn\u00e9es textuelles en utilisant des identifiants de ponctation.</p> <ul> <li>Les accolades d\u00e9finissent un objet (appel\u00e9 membre).</li> <li>Un membre contient des paires (clefs, valeurs). La clef est toujours entre guillemets.</li> <li>Les crochets annoncent un tableau et les virgules s\u00e9parent les items du tableau.</li> </ul> <p>Exemple inspir\u00e9 du livre de V. Barra</p> <pre><code>{\n\"entr\u00e9es\" : [\"Melon\", \"Oeufs mayo\"],\n\"plats\" : {\n\"Viandes\" : [\"Boeuf\", \"Poulet\"] ,\n\"Poisson\" : [\"Meuni\u00e8re\"] ,\n\"platsComposees\" : [\n{\n\"nom\" : \"Boeuf bourguignon\",\n\"ingr\u00e9dients\" : []\n},\n{\"nom\" : \"Poisson meuni\u00e8re\", \"quantit\u00e9s\" : {}}\n] ,\n\"viandeEtPoisson\": true\n},\n\"nombreInvites\" : 5, \"nomHote\" : \"M.Noyer\"\n}\n</code></pre>"},{"location":"Divers/2-Serialisation/#serialisation-de-structure-hierarchique","title":"S\u00e9rialisation de structure hi\u00e9rarchique","text":""},{"location":"Divers/2-Serialisation/#cas-des-arbres-binaires","title":"Cas des arbres binaires","text":"<p>On peut donner le r\u00e9sultat sous forme de deux listes : les parcours infixe et pr\u00e9fixes. Mais la place utilis\u00e9e est le double de celle de l'arbre.</p> <p>On peut aussi faire un parcours pr\u00e9fixe et indiquer les n\u0153uds <code>NULL</code> par un symbole comme \\(-1\\) (cela rend implicitement l'arbre entier).</p> <p></p> <p>Figure \u2013 Codage \\(a\\) \\(b\\) \\(-1\\) \\(-1\\) \\(-1\\)</p> <p></p> <p>Figure \u2013 Codage \\(a\\) \\(b\\) \\(-1\\) \\(-1\\) \\(c\\) \\(-1\\) \\(-1\\)</p> <p></p> <p>Figure \u2013 Codage \\(a\\) \\(b\\) \\(c\\) \\(-1\\) \\(-1\\) \\(d\\) \\(e\\) \\(-1\\) \\(-1\\) \\(f\\) \\(-1\\) \\(-1\\) \\(-1\\) (Vincent Barra)</p>"},{"location":"Divers/2-Serialisation/#cas-des-arbres-n-aires","title":"Cas des arbres n-aires","text":"<p>Un symbole (comme \\(\u2217\\)) indique la fin de la liste des fils.</p> <p></p> <p>Figure \u2013 Codage \\(a\\) \\(b\\) \\(e\\) \\(\u2217\\) \\(f\\) \\(j\\) \\(\u2217\\) \\(k\\) \\(\u2217\\) \\(\u2217\\) \\(\u2217\\) \\(c\\) \\(\u2217\\) \\(d\\) \\(g\\) \\(\u2217\\) \\(h\\) \\(\u2217\\) \\(j\\) \\(\u2217\\) \\(\u2217\\) \\(\u2217\\) (Vincent Barra)</p>"},{"location":"Divers/2-Serialisation/#cas-des-graphes-orientes","title":"Cas des graphes orient\u00e9s","text":"<p>Figure 1 \u2013 Graphe orient\u00e9</p> <pre><code>{\n    \"0\" : [3],\n    \"1\" : [0, 2, 3],\n    \"2\" : [4],\n    \"3\" : [2, 4],\n    \"4\" : []\n}\n</code></pre> <p>Figure 2 \u2013 S\u00e9rialisation</p>"},{"location":"Divers/2-Serialisation/#cas-des-graphes-non-orientes","title":"Cas des graphes non orient\u00e9s","text":"<p>Figure 1 \u2013 Graphe non orient\u00e9</p> <pre><code>{\n    \"0\" : [1, 3],\n    \"1\" : [0, 2, 3],\n    \"2\" : [1, 3, 4],\n    \"3\" : [1, 2, 4],\n    \"4\" : [2, 3]\n}\n</code></pre> <p>Figure 2 \u2013 S\u00e9rialisation</p> <p>Tip</p> <p>On peut \u00e9galement donner le code OCaml <code>[[1;3];[0;2;3];[1;3;4];[1;2;4];[2;3]]</code> c'est aussi une s\u00e9rialisation</p>"},{"location":"Divers/3-Rencontre%20au%20milieu/","title":"Rencontre au milieu","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dit</p> <ul> <li>Cette page sur Quora</li> </ul>"},{"location":"Divers/3-Rencontre%20au%20milieu/#position-du-probleme","title":"Position du probl\u00e8me","text":"<p>Consid\u00e9rons un ensemble \\(E\\) de \\(n\\) nombres distincts et un entier \\(S\\).</p> <p>On cherche la plus grande somme d'\u00e9l\u00e9ments de \\(E\\) dont la valeur est plus petite que \\(S\\).</p> <p>On peut faire une recherche en force brute. Il s'agit de d\u00e9terminer la somme pour tous les sous-ensembles de \\(E\\) et de la comparer avec \\(S\\) puis de prendre la plus grande somme plus petite que \\(S\\).</p> <p>Malheureusement, il y a \\(2^n\\) sous-ensemble de \\(E\\), donc la complexit\u00e9 de cette approche serait en \\(O(2^n)\\) au moins (c'est sans compter le co\u00fbt de la somme elle-m\u00eame).</p>"},{"location":"Divers/3-Rencontre%20au%20milieu/#presentation","title":"Pr\u00e9sentation","text":"<p>Meet-in-the-middle est une technique de recherche appliqu\u00e9e lorsque l'entr\u00e9e est petite (par exemple \\(40\\) nombres) mais pas assez petite pour que la recherche en force brute soit envisageable (\\(2^{40}\\) est quand m\u00eame assez gros).</p> <p>Comme diviser pour r\u00e9gner, le probl\u00e8me est divis\u00e9 en \\(2\\) sous-probl\u00e8mes. Cependant ici, le travail ne se fait pas r\u00e9cursivement. On travaille sur deux moiti\u00e9s du tableau, on ne divise pas le tableau davantage.</p>"},{"location":"Divers/3-Rencontre%20au%20milieu/#algorithme","title":"Algorithme","text":"<p>Notation</p> <p>\\(n/2\\) : division euclidienne par \\(2\\).</p> <p>Consid\u00e9rons un ensemble de \\(n\\) nombres.</p> <p>Diviser l'ensemble des entiers en deux sous-ensemble \\(A\\), \\(B\\). \\(A\\) contient \\(n/2\\) \u00e9l\u00e9ments et \\(B\\) les autres.</p> <p>Chercher toutes les sommes possibles d'\u00e9l\u00e9ments de \\(A\\) et mettre le r\u00e9sultat dans un tableau \\(X\\) (resp. \\(B\\), tableau \\(Y\\) ). Puisqu'il y a \\(n/2\\) \u00e9l\u00e9ments dans \\(A\\), alors la complexit\u00e9 de cette op\u00e9ration est major\u00e9e par \\(O\\left (\\frac{n}{2} \\times 2 ^{n/2} \\right )\\).</p> <p>Fusionner les \\(2\\) sous-probl\u00e8mes : trouver les couples \\((x, y) \u2208 X \u00d7 Y\\) tels que \\(x + y \u2264 S\\) :</p> <ul> <li>En force brute, puisque \\(X, Y\\) sont de taille en gros \\(n/2\\), on obtient par une double boucle toutes les sommes en \\(O \\left ((2 ^{n/2})^2 \\right ) = O(2^n)\\) : \\(\\color{red}\\textsf{pas mieux que la force brute initiale}\\).</li> <li>Dans un premier temps on trie \\(Y\\) (et pas \\(X\\)) en \\(O\\left (\\frac{n}{2} \\times 2 ^{n/2} \\right )\\)</li> <li>On m\u00e9morise la meilleure somme \\(m\\) trouv\u00e9e jusqu'ici : initialisation \\(m \u2190 0\\).</li> <li>Pour chaque \\(x \u2208 X\\), on recherche par dichotomie le plus grand \\(y \u2208 Y\\) tel que \\(x + y \u2264 S\\). Si \\(x + y &gt; m\\), alors \\(m \u2190 x + y\\).</li> <li>On fait donc \\(|X| \\simeq  2^{n/2}\\) fois une recherche en \\(\\log(|Y|) \\simeq  log(2^{n/2})\\). Comme \\(log(2^{n/2}) = \\frac{n}{2}\\log(2)\\), La complexit\u00e9 totale est en \\(O \\left ((2 ^{n/2})^2 \\right ) = O(n2^{n/2})\\), co\u00fbteuse mais moins que \\(O(2^n)\\)</li> </ul>"},{"location":"Divers/3-Rencontre%20au%20milieu/#rappels-utiles-pour-limplantation","title":"Rappels utiles pour l'implantation","text":"<p>\\(1L&lt;&lt;52\\) calcule \\(2^{52}\\) mais caste d'abord \\(1\\) en un <code>long</code> Le codage binaire d'un entier \\(i\\) repr\u00e9sente un ensemble \\(E_i\\) d'entiers.Exemple \\(i = 100101\\) repr\u00e9sente \\(E_ i \\{0, 2, 5\\}\\). \\(i\\) \\(\\&amp;\\) \\(1L &lt;&lt; j\\) cherche si le \\(j\\)-i\u00e8me bit de \\(i\\) est \u00e0 \\(1\\), donc si \\(j \u2208 E_i\\)</p>"},{"location":"Graphes/1-Graphes/","title":"Graphes","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Graphes/1-Graphes/#credits","title":"Cr\u00e9dits","text":"<ul> <li>Wikip\u00e9dia : th\u00e9orie des graphes</li> <li>Wikip\u00e9dia : graphes simples</li> <li>Toujours le Mansuy.  </li> </ul>"},{"location":"Graphes/1-Graphes/#historique","title":"Historique","text":""},{"location":"Graphes/1-Graphes/#les-sept-ponts-de-konigsberg","title":"Les sept ponts de K\u00f6nigsberg","text":"<p>Un article du math\u00e9maticien suisse Leonhard Euler, pr\u00e9sent\u00e9 \u00e0  l\u2019Acad\u00e9mie de Saint-P\u00e9tersbourg en 1735 puis publi\u00e9 en 1741.  </p> <p>Trouver une promenade \u00e0 partir d\u2019un point donn\u00e9 qui fasse revenir \u00e0  ce point en passant une fois et une seule par chacun des sept ponts  de la ville de K\u00f6nigsberg : Circuit eul\u00e9rien.</p> <p>Euler fut sans doute le premier \u00e0 proposer un traitement  math\u00e9matique de la question, suivi par Vandermonde.</p> <p></p> <p>Figure \u2013 Abstraction du probl\u00e8me des 7 ponts de K\u00f6nigsberg</p> <p>Th\u00e9or\u00e8me</p> <p>Un graphe connexe admet un circuit eul\u00e9rien si et  seulement si tous ses sommets sont de degr\u00e9 pair. Ici un des sommets a \\(3\\) voisins: pas de circuit eul\u00e9rien.  </p>"},{"location":"Graphes/1-Graphes/#graphes-representation-sous-graphes","title":"Graphes, repr\u00e9sentation, sous-graphes","text":""},{"location":"Graphes/1-Graphes/#informellement","title":"Informellement","text":"<p>Un graphe est un ensemble de points dans lequel on fait appara\u00eetre  une ou plusieurs relations(s) entre deux points. Ces relations sont en g\u00e9n\u00e9ral repr\u00e9sent\u00e9es par des \ufb02\u00e8ches ou par des  segments. Dans le premier cas, le graphe est dit orient\u00e9 et les liens  sont appel\u00e9s des arcs. Dans le second, le graphe est dit non orient\u00e9 et  les liens sont souvent appel\u00e9s des ar\u00eates.  </p> <p>Les points sont appel\u00e9s les sommets (en r\u00e9f\u00e9rence aux poly\u00e8dres) ou  les n\u0153uds (en r\u00e9f\u00e9rences \u00e0 la loi des n\u0153uds).</p> <p></p> <p>Figure \u2013 Un graphe orient\u00e9 avec des arcs - un graphe non orient\u00e9 et ses ar\u00eates.</p> <p>Exemple : plan d\u2019une ville. <p></p></p> <p>Figure \u2013 Un multigraphe non orient\u00e9 : ses ar\u00eates multiples en bleu et ses boucles en rouge.</p> <p>En anglais, sommet se dit vertice, ar\u00eate se dit undirected edge et arc  se dit directed edge.  </p> <p>Les ar\u00eates multiples ne sont pas au programme.  </p>"},{"location":"Graphes/1-Graphes/#graphe-simple-non-oriente","title":"Graphe simple non orient\u00e9","text":"<p>La d\u00e9finition suivante ne s\u2019applique pas aux graphes avec ar\u00eates multiples.</p> <p>D\u00e9finition: Graphe simple non orient\u00e9</p> <p>Un graphe (simple) non orient\u00e9 \\(G\\) est un couple \\((S, A)\\) o\u00f9 \\(A \u2286 P(S)\\) est un ensemble de paires ou de singleton d\u2019\u00e9l\u00e9ments de \\(S\\). On appelle sommets les \u00e9l\u00e9ments de \\(S\\) et arcs ceux de \\(A\\).</p> <p>La lettre \\(E\\) est utilis\u00e9e pour les arcs car en anglais, arc se dit edge.  </p> <p>Certains auteurs utilisent un vocabulaire sp\u00e9cial pour les graphes non  orient\u00e9s. Par exemple, une ar\u00eate (undirected edge) d\u00e9signe un arc.  </p> <p>Soit \\(a = \\{x, y\\}\\). On dit que :  </p> <ul> <li>\\(a\\) relie les sommets \\(x\\) et \\(y\\), \\(x\\) et \\(y\\) sont adjacents ou encore voisins</li> <li>\\(a\\) est incidente avec \\(x\\) et \\(y\\) ou encore \\(x\\) et \\(y\\) sont incidents avec \\(a\\).  </li> </ul>"},{"location":"Graphes/1-Graphes/#graphe-simple-oriente","title":"Graphe simple orient\u00e9","text":"<p>Au programme ne figurent que les graphes avec au plus un seul arc d\u2019un  sommet \u00e0 un autre.</p> <p>D\u00e9finition: Graphe simple orient\u00e9</p> <p>Un graphe simple orient\u00e9 \\(G\\) est un couple \\((S, A)\\) o\u00f9 :</p> <ul> <li>\\(S\\) est appel\u00e9 l\u2019ensemble des sommets de \\(G\\),</li> <li>Et \\(A \u2286 S^2\\) est un ensemble de couples d\u2019\u00e9l\u00e9ments de \\(S\\) appel\u00e9 l\u2019ensemble des arcs de \\(G\\).</li> </ul> <p>La lettre \\(V\\) peut \u00eatre utilis\u00e9e pour les sommets car en anglais, sommet se dit vertex (au pluriel vertices).  </p> <p>Un arbre est un cas particulier de graphe orient\u00e9 simple.</p> <p>Mais pour certains auteurs, un arbre est un graphe non orient\u00e9  connexe et acyclique (voir plus loin pour les d\u00e9finitions).  </p> <p>Un arc est not\u00e9 \\(a = (x, y)\\) ou \\(a = x \u2192 y\\) et on dit que :  </p> <ul> <li>\\(a\\) va de \\(x\\) \u00e0 \\(y\\)</li> <li>\\(x\\) est l\u2019extr\u00e9mit\u00e9 initiale de \\(a\\) </li> <li>\\(y\\) est l\u2019extr\u00e9mit\u00e9 terminale de \\(a\\)</li> <li>\\(y\\) est un voisin de \\(x\\). \\(a\\) est incident \u00e0 \\(x\\) et \\(y\\) </li> </ul>"},{"location":"Graphes/1-Graphes/#degre","title":"Degr\u00e9","text":"<p>Dans un graphe g\u00e9n\u00e9ral (orient\u00e9 ou non), on appelle degr\u00e9 d\u2019un  sommet \\(s\\) et on note \\(d(s)\\), le nombre d\u2019arcs incidents au sommet \\(s\\). Dans un graphe g\u00e9n\u00e9ral orient\u00e9, on distingue le degr\u00e9 sortant ou  ext\u00e9rieur \\(d^{+}(s)\\) qui est \u00e9gal au nombre d\u2019arcs dont \\(s\\) est l\u2019extr\u00e9mit\u00e9  initiale et le degr\u00e9 entrant ou int\u00e9rieur \\(d^{\u2212}(s)\\) qui est \u00e9gal au nombre  d\u2019arcs dont \\(s\\) est l\u2019extr\u00e9mit\u00e9 finale.  </p> <ul> <li>\\(d^{-}(S_3) = 3\\)f</li> <li>\\(d^{+}(S_3) = 1\\)</li> <li>\\(d(S_3) = 4\\)</li> </ul> <p></p>"},{"location":"Graphes/1-Graphes/#matrice-dadjacence-sommets-sommets","title":"Matrice d\u2019adjacence sommets-sommets","text":"<p>D\u00e9finition: Matrice d'adjacence</p> <p>Soit \\(G = (S, A)\\) un graphe fini simple. Notons \\(\\{v_1,..., v_n\\}\\) les sommets de \\(S\\). On appelle matrice d\u2019adjacence sommets-sommets de \\(G = (S, A)\\) la matrice \\(A_{n\u00d7n} = (a_{ij})_1{\u2264i,j\u2264n}\\) telle que</p> \\[ a_{ij} =  \\begin{equation} \\nonumber     \\begin{cases}         1 \\text{ si il existe un arc de } v_i \\text{ \u00e0 } v_j\\\\         0 \\text{ sinon}     \\end{cases} \\end{equation} \\] <p>Remarque</p> <ul> <li>La matrice d\u2019adjacence d\u00e9pend de la num\u00e9rotation des sommets. Il  faut que cette num\u00e9rotation soit connue pour comprendre la matrice.  </li> <li>\\(A\\)    une num\u00e9rotation des sommets correspond une unique matrice  d\u2019ajacence sommets-sommets.  </li> <li>Inadapt\u00e9e pour les ar\u00eates (ou les arcs) multiples. Pr\u00e9sence de boucle  si \\(a_{ii} = 1\\).  Graphe non orient\u00e9 \\(\\Rightarrow\\) matrice sym\u00e9trique.  </li> </ul>"},{"location":"Graphes/1-Graphes/#liste-dadjacence","title":"Liste d\u2019adjacence","text":"<p>D\u00e9finition: Liste d'adjacence</p> <p>Soit \\(G = (S, A)\\) un graphe fini simple.</p> <p>On appelle liste d\u2019adjacence de \\(G\\) toute liste de couples \\((s, l)\\) o\u00f9 \\(s\\) parcourt \\(S\\) et \\(l\\) est une liste de ses voisins.</p> <p>Remarque</p> <p>Si une num\u00e9rotation des sommets est choisie, on peut se contenter de donner la liste des voisins. La premi\u00e8re liste donne les voisins du premier sommet, la seconde celle du second sommet etc...</p>"},{"location":"Graphes/1-Graphes/#exemple-de-repesentation","title":"Exemple de rep\u00e9sentation","text":""},{"location":"Graphes/1-Graphes/#cas-non-oriente","title":"Cas non orient\u00e9","text":"<p>Figure - Un graphe \u00e9tiquet\u00e9 non orient\u00e9</p>"},{"location":"Graphes/1-Graphes/#matrice-dadjacence","title":"Matrice d'adjacence","text":"<p>Matrice sym\u00e9trique</p> \\[\\begin{pmatrix}0 &amp; 1 &amp; 1 &amp; 1\\\\1 &amp; 0 &amp; 0 &amp; 0\\\\1 &amp; 0 &amp; 0 &amp; 1\\\\1 &amp; 0 &amp; 1 &amp; 0\\end{pmatrix}\\]"},{"location":"Graphes/1-Graphes/#liste-dadjacence_1","title":"Liste d'adjacence","text":"<p><pre><code>[(\u2019A\u2019, [\u2019B\u2019, \u2019C\u2019, \u2019D\u2019]), (\u2019B\u2019, [\u2019A\u2019]), (\u2019C\u2019, [\u2019A\u2019, \u2019D\u2019]), (\u2019D\u2019, [\u2019C\u2019, \u2019A\u2019])]\n</code></pre> ou <pre><code>[[\u2019B\u2019, \u2019C\u2019, \u2019D\u2019], [\u2019A\u2019], [\u2019A\u2019, \u2019D\u2019], [\u2019C\u2019, \u2019A\u2019]]\n</code></pre></p>"},{"location":"Graphes/1-Graphes/#cas-oriente","title":"Cas orient\u00e9","text":"<p>Figure - Un graphe \u00e9tiquet\u00e9 orient\u00e9</p>"},{"location":"Graphes/1-Graphes/#matrice-dadjacence_1","title":"Matrice d'adjacence","text":"<p>Matrice non sym\u00e9trique</p> \\[\\begin{pmatrix}0 &amp; 1 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\\\1 &amp; 0 &amp; 0 &amp; 0\\end{pmatrix}\\]"},{"location":"Graphes/1-Graphes/#liste-dadjacence_2","title":"Liste d'adjacence","text":"<p><pre><code>[(\u2019A\u2019, [\u2019B\u2019, \u2019C\u2019]), (\u2019B\u2019,[]), (\u2019C\u2019, [\u2019D\u2019]), (\u2019D\u2019,[\u2019A\u2019])] \n</code></pre> ou <pre><code>[[\u2019B\u2019, \u2019C\u2019], [], [\u2019D\u2019], [\u2019A\u2019]]\n</code></pre></p>"},{"location":"Graphes/1-Graphes/#matrices-dadjacence-quelle-representation","title":"Matrices d\u2019adjacence : quelle repr\u00e9sentation ?","text":"<p>En Ocaml ou C, les matrices d\u2019adjacence sont simplement  repr\u00e9sent\u00e9es par des matrices carr\u00e9es c.a.d. des tableaux \u00e0 deux  dimensions avec m\u00eame nombre de lignes que de colonnes.  </p> <p>A la place de \\(0\\) et de \\(1\\), on peut utiliser des boul\u00e9ens.  </p> <p>Implicitement on consid\u00e8re que les sommets sont des nombres. Ou  alors on dispose d\u2019un tableau de correspondance entre les sommets et  leurs num\u00e9ros (utile si les sommets contiennent des informations).  </p> <p>Avec un tel choix :  </p> <ul> <li>il est facile de supprimer ou d\u2019ajouter un arc entre deux sommets  existants.  </li> <li>On teste en \\(O(1)\\) si deux sommets sont voisins.  </li> <li>Ajouter un sommet n\u00e9cessite en g\u00e9n\u00e9ral une copie de la matrice  (complexit\u00e9 quadratique).  </li> <li>Place m\u00e9moire perdue importante si beaucoup de sommets et matrice  creuse.  </li> </ul>"},{"location":"Graphes/1-Graphes/#listes-dadjacence-en-ocaml-quelle-representation","title":"Listes d\u2019adjacence en Ocaml : quelle repr\u00e9sentation ?","text":"<p>En Ocaml pour un graphe \\(G = (S, A)\\) : On peut consid\u00e9rer une liste \\(L\\) de longueur \\(|S|\\) de tuples \\((s, l)\\) ou \\(s\\) est un sommet et \\(l\\) la liste des voisins de \\(s\\).  </p> <ul> <li>Avantages : pas de place m\u00e9moire perdue ; possibilit\u00e9 d\u2019ajouter un  nouveau sommet apr\u00e8s avoir v\u00e9rifi\u00e9 que ce sommet n\u2019est pas d\u00e9j\u00e0 dans  la liste.  </li> <li>Inconv\u00e9nients : Acc\u00e8s \u00e0 la liste d\u2019adjacence de \\(s\\) en \\(O(|S|)\\) ; test de voisinage entre \\(s\\) et \\(x\\) en \\(O(|S| + deg (s))\\) ; ajout d\u2019un arc \\((s, x)\\) en  \\(O(|S| + deg (s))\\).  </li> </ul> <p>On peut pr\u00e9ferer g\u00e9rer un tableau de listes \\(l\\) plut\u00f4t qu\u2019une liste de  tuples (les sommets sont alors des nombres).  </p> <ul> <li>Avantage : l\u2019acc\u00e8s \u00e0 la liste d\u2019adjacence de \\(s\\) est en \\(O(1)\\) ; test de voisinage avec \\(x\\) en \\(O(deg (s))\\); ajout d\u2019un arc \\((s, x)\\) en \\(O(deg (s))\\) (il faut v\u00e9rifier que l\u2019arc n\u2019est pas d\u00e9j\u00e0 pr\u00e9sent - usage de list.mem -).  </li> <li>Inconv\u00e9nient : pour ajouter un sommet, il faut recopier le tableau.  </li> </ul>"},{"location":"Graphes/1-Graphes/#listes-dadjacence-en-c-quelle-representation","title":"Listes d\u2019adjacence en C : quelle repr\u00e9sentation ?","text":""},{"location":"Graphes/1-Graphes/#tableau-de-liste-de-chaines","title":"Tableau de liste de cha\u00eenes","text":"<p>Dans le m\u00eame esprit qu\u2019en Ocaml, pour repr\u00e9senter \\(G = (S, A)\\) Tableau \\(t\\) des successeurs de chaque sommet. \\(t[i]\\) pointe sur la liste des sucesseurs du sommet \\(i\\). Acc\u00e8s direct \u00e0 un sommet via \\(t\\). Complexit\u00e9 spatiale optimale en \\(O(|A| + |S|)\\) </p> <p></p> <p>Figure \u2013 Un tableau de liste cha\u00een\u00e9e de successeurs. (F. Pesseaux)</p> <pre><code>typedef int edge_val ;// \u00e9tiquette sur les arcs\ntypedef int vertex_name_t ;//nom des sommet\n\nstruct edge_list_t {// liste de voisins = extr\u00e9mit\u00e9s d\u2019 arcs\n    int dest ;\n    edge_val data ;// \u00e9tiquette sur l' arc\n    struct edge_list_t \u2217 next;\n};\n\nstruct vertex_t {\n    vertex_name_t name ;// nom du sommet\n    struct edge_list_t \u2217 edges;// liste de voisins\n};\n\nstruct graph_t {\n    int nb_vertices ;\n    struct vertex_t \u2217 vertices [ MAX VERTICES ];\n};\n</code></pre> <ul> <li>ici il y a des \u00e9tiquettes sur les  arcs;</li> <li>si nom \\(\u2260\\) index de tableau : besoin d'une fonction nom \\(\\rightarrow\\) index</li> </ul>"},{"location":"Graphes/1-Graphes/#partage-physique-des-sommets","title":"Partage physique des sommets","text":"<p>On peut aussi partager physiquement les sommets. - Chaque sommet est repr\u00e9sent\u00e9 1 et 1 seule fois. - Chaque sommet est associ\u00e9 \u00e0 une liste dont les \u00e9l\u00e9ments pointent sur  ses successeurs.  </p> <p></p> <p>Figure \u2013 Partage physique des donn\u00e9es (F.Pesseaux)</p> <pre><code>struct vertex_list_t ;\nstruct vertex_t ;\n\nstruct vertex_t {\n    vertex_name_t name ;    //nom\n    struct vertex_list_t\u2217 neighbours;   // liste de sommets voisins\n    bool seen ;    // visit\u00e9 / pas visit\u00e9\n};\n\nstruct vertex_list_t {\n    struct vertex_t\u2217 vertex ;   // sommet\n    struct vertex_list_t\u2217 next; // pointeur sur liste de sommets\n};\n\nstruct graph_t{\n    int nb vertices ;\n    struct vertex_list_t\n};\n</code></pre> <ol> <li> <p>Chaque sommet vient avec son nom, un pointeur sur sa liste de sommets voisins (qui est une liste de pointeurs sur sommets) et une \u00e9tiquette (visit\u00e9 ou non) ;</p> </li> <li> <p>une liste de sommets contient un pointeur sur sommet et un pointeur sur le mailllon suivant.</p> </li> </ol>"},{"location":"Graphes/1-Graphes/#sous-graphes","title":"Sous-graphes","text":"<p>Convention : \\(S\\) pour sommets, \\(A\\) pour arcs.  </p> <ul> <li> <p>Un sous-graphe est un graphe contenu dans un autre graphe :  \"\\(H = (S_H, A_H)\\) est un sous-graphe de \\(G = (S_G, A_G)\\) si \\(S_H \u2282 S_G\\),  \\(A_H \u2282 A_G\\) et pour tout arc (resp. ar\u00eate) de \\(A_H\\), les extr\u00e9mit\u00e9s sont  dans \\(S_H\\)\". On supprime des arcs et des sommets avec la contrainte qu\u2019il ne faut pas conserver d\u2019arc dont une extr\u00e9mit\u00e9 a \u00e9t\u00e9 supprim\u00e9e de l\u2019ensemble des sommets.</p> </li> <li> <p>Un sous-graphe couvrant (ou graphe partiel) est un sous-graphe ayant  le m\u00eame ensemble de sommets que le graphe qui le contient.  \"\\(H\\) est un sous-graphe couvrant de \\(G\\) (ou \\(H\\) couvre \\(G\\)) si \\(S_H = S_G\\)  et \\(A_H \u2282 A_G\\).\"  On garde tous les sommets, on enl\u00e8ve certains arcs.</p> </li> <li> <p>Un sous-graphe induit est un sous-graphe d\u00e9fini par un sous ensemble  de sommets.  \"\\(H\\) est un sous-graphe induit de \\(G\\) si, pour tout \\((x, y) \\in S_H^2\\), l\u2019existence d\u2019un lien entre \\(x\\) et \\(y\\) dans \\(H\\) est \u00e9quivalente \u00e0 l\u2019existence  d\u2019un lien entre \\(x\\) et \\(y\\) dans \\(G\\).\" On enl\u00e8ve des sommets, toutes les ar\u00eates correspondant \u00e0 ces sommets et uniquement celles-l\u00e0.</p> </li> </ul> <p>Exemples</p> <p><p></p></p>"},{"location":"Graphes/1-Graphes/#chaines-et-chemins-connexite","title":"Cha\u00eenes et chemins, connexit\u00e9","text":""},{"location":"Graphes/1-Graphes/#accessibilite","title":"Accessibilit\u00e9","text":""},{"location":"Graphes/1-Graphes/#chaines-et-chemins","title":"Cha\u00eenes et Chemins","text":"<p>Soit \\(G = (S, A)\\) un graphe.  </p> <ul> <li>Un chemin d\u2019un sommet \\(x\\) \u00e0 un sommet \\(y\\) est une s\u00e9quence de (au  moins 2) sommets \\(x = x_0, x_1,..., x_{n\u22121}, x_n\\) = y dans laquelle chaque \\(x_i\\)  admet \\(x_{i+1}\\) pour voisin.  </li> <li>Un sommet \\(y\\) est accessible depuis \\(x\\) s\u2019il existe un chemin de \\(x\\) \u00e0 \\(y\\).  </li> <li>La longueur d\u2019un chemin est \u00e9gale au nombre d\u2019ar\u00eates qui la  constituent.  </li> <li>Un chemin simple est une chemin qui ne contient pas plusieurs fois  une m\u00eame ar\u00eate/arc (on dit aussi eul\u00e9rien).  </li> <li>Un chemin \u00e9l\u00e9mentaire est une chemin qui ne passe pas plusieurs fois  par un m\u00eame sommet.  </li> <li>\u00e9l\u00e9mentaire \\(\\Rightarrow\\) simple.  </li> <li>En CPGE, les cha\u00eenes sont souvent \u00e9l\u00e9mentaires (pas de doublon de  sommet sauf pour d\u00e9finir les cycles).  </li> <li>Certains auteurs utilisent le mot cha\u00eene pour d\u00e9signer les chemins  dans les graphes non orient\u00e9s.  </li> </ul>"},{"location":"Graphes/1-Graphes/#cycles-et-circuits","title":"Cycles et circuits","text":"<ul> <li> <p>Un chemin est dit simple si chacun de ses arcs/ar\u00eates  n\u2019est emprunt\u00e9 qu\u2019une fois.</p> </li> <li> <p>Un cycle \\(x_0, x_1,..., x_n\\) est un chemin dont les extr\u00e9mit\u00e9s sont  confondues : \\(\\color{red}\\text{dans l\u2019immense majorit\u00e9 des cas, on impose qu\u2019il soit simple}\\), c\u2019est \u00e0 dire qu\u2019aucun arc/ar\u00eate n\u2019y figure deux fois.  </p> </li> <li>Remarque : le sommet r\u00e9p\u00e9t\u00e9 peut varier. Le cycle \\(x_0\\) , \\(x_1\\) , \\(x_2\\) , \\(x_0\\) est consid\u00e9r\u00e9 comme \u00e9gal au cycle \\(x_1\\) , \\(x_2\\) , \\(x_0\\) , \\(x_1\\).</li> <li>Un cycle est dit \u00e9l\u00e9mentaire si, lorsqu\u2019on enl\u00e8ve un arc quelconque et une extr\u00e9mit\u00e9 de cet arc, le chemin restant est \u00e9l\u00e9mentaire.  </li> <li>Un graphe est acyclique s\u2019il ne poss\u00e8de aucun cycle.  </li> <li>Certains auteurs distinguent la notion de circuit (pour les graphes orient\u00e9s) de celle de cycle (pour les graphes non orient\u00e9s). Dans un graphe non orient\u00e9, la plupart du temps, on consid\u00e8re qu\u2019un cycle est simple et poss\u00e8de au moins \\(3\\) ar\u00eates (les boucles ne sont alors pas consid\u00e9r\u00e9es comme des cycles).</li> </ul>"},{"location":"Graphes/1-Graphes/#existence-de-chemin-elementaire-propriete-de-konig","title":"Existence de chemin \u00e9l\u00e9mentaire (Propri\u00e9t\u00e9 de  K\u00f6nig)","text":"<p>Proposition S\u2019il existe un chemin de \\(x\\) \u00e0 \\(y\\) dans le graphe \\(G = (S , A )\\), alors il existe un chemin \u00e9l\u00e9mentaire de \\(x\\) \u00e0 \\(v\\) .</p> <p>Preuve en TD.</p>"},{"location":"Graphes/1-Graphes/#distance-et-diametre","title":"Distance et diam\u00e8tre","text":"<p>La distance entre deux sommets \\(x\\) et \\(y\\) d\u2019un graphe \\(G = (S, A)\\)  orient\u00e9 (resp. non orient\u00e9) est not\u00e9e \\(d_G (x, y)\\) et est \u00e9gale \u00e0 la longueur d\u2019un plus court chemin (resp. cha\u00eene) allant de \\(x\\) \u00e0 \\(y\\) s\u2019il en  existe un ou bien \\(+\\infty\\) sinon.</p> <p>Il s\u2019agit bien d\u2019une distance au sens math\u00e9matiques. En particulier,  elle v\u00e9rifie l\u2019in\u00e9galit\u00e9 triangulaire  </p> \\[ \\forall (x, y, z) \\in S^3, d_G (x, z) \\leq d_G (x, y) + d_G (y, z) \\] <p>Le diam\u00e8tre d\u2019un graphe \\(G\\) est la valeur : \\(sup_{(x,y) \\in S^2} (d_G (x, y))\\). C\u2019est \"la longueur du plus long plus court chemin entre deux sommets\".  </p>"},{"location":"Graphes/1-Graphes/#connexite","title":"Connexit\u00e9","text":""},{"location":"Graphes/1-Graphes/#relation-de-connexite","title":"Relation de connexit\u00e9","text":"<ul> <li>La connexit\u00e9 dans un graphe non orient\u00e9 est une relation binaire entre  deux sommets : \\(x\\) et \\(y\\) sont en relation de connexit\u00e9 si et seulement si  \\(y\\) est accessible depuis \\(x\\).  </li> <li>Comme le graphe est non orient\u00e9, si \\(y\\) est accessible depuis \\(x\\), alors \\(x\\)  est accessible depuis \\(y\\).</li> <li>La connexit\u00e9 est une relation d\u2019\u00e9quivalence.  </li> <li>Les classes d\u2019\u00e9quivalences sont appel\u00e9es composantes connexes. La composante connexe d\u2019un sommet \\(x\\) est not\u00e9e ici \\(\\dot{x}\\) et vaut :  </li> </ul> \\[\\dot{x} = \\{y \u2208 S| \\text{ il existe une cha\u00eene de x \u00e0 y }\\}\\] <ul> <li>Un graphe est dit connexe si il poss\u00e8de une seule composante  connexe.</li> <li>La connexit\u00e9 est \u00e9tendue aux graphes orient\u00e9s en ne tenant pas compte du sens des arcs.  </li> </ul>"},{"location":"Graphes/1-Graphes/#relation-de-forte-connexite","title":"Relation de forte connexit\u00e9","text":"<p>La relation de forte connexit\u00e9 est une relation binaire entre sommets  d\u2019un graphe orient\u00e9 : \\(x\\) et \\(y\\) sont en relation de forte connexit\u00e9 si et  seulement si  </p> <ul> <li>il existe un chemin de \\(x\\) \u00e0 \\(y\\) et il existe un chemin de \\(y\\) \u00e0 \\(x\\) </li> <li>ou bien \\(x = y\\).  </li> </ul> <p>\\(\\color{red}\\text{Il peut y avoir un chemin de }x\\text{ \u00e0 }y\\text{ sans chemin de }y\\text{ \u00e0 }x{.}\\)</p> <p>Les classes d\u2019\u00e9quivalence de la relation de forte connexit\u00e9 sont  appel\u00e9es composantes fortement connexes. La composante fortement connexe de \\(x\\), not\u00e9e ici \\(\\tilde{x}\\) vaut :  </p> \\[ \\tilde{x} = \\{y \\in S| \\text{ il existe un chemin de $x$ \u00e0 $y$ et de $y$ \u00e0 $x$} \\} \\] <p>Elle v\u00e9rifie \\(\\tilde{x} \u2282 \\dot{x}\\). L\u2019inclusion r\u00e9ciproque est en g\u00e9n\u00e9ral fausse.</p> <p>On dit qu\u2019un graphe est fortement connexe si et seulement si il est  constitu\u00e9 d\u2019une seule composante fortement connexe, c\u2019est \u00e0 dire si  pour tout couple de sommet \\((x, y)\\) il existe un chemin allant de \\(x\\) \u00e0 \\(y\\)  et r\u00e9ciproquement.  </p> <p>Connexit\u00e9 : exemple</p> <pre><code>graph TB; \n    A((S1))--&gt;B((S8))\n    D((S7))--&gt;B\n    A--&gt;D\n    J((S10))--&gt;C((S2))\n    C--&gt;A\n    C--&gt;D\n    J--&gt;B\n    E((S3))--&gt;C\n    E--&gt;H((S5))\n    H--&gt;G((S4))\n    G--&gt;E\n    F((S6))--&gt;C\n    D--&gt;F\n    H--&gt;F</code></pre> <p>Graphe connexe (quand on ne consid\u00e8re pas le sens des \ufb02\u00e8ches).</p> <p>\\(S8\\) est accessible depuis tous les sommets.  \\(\\tilde{S8} = \\{S8\\}\\). Donc le graphe n\u2019est pas fortement connexe, sinon \\(\\tilde{S8}\\)  contiendrait tous les sommets.  </p> <ul> <li>Sommets accessibles(qui partent de \\(S2\\)) depuis \\(S2 : \\{S1, S2, S6, S7, S8\\}\\).  </li> <li>Sommets coaccessibles(qui viennent vers \\(S2\\)) depuis \\(S2 : \\{S1, S2, S3, S4, S5, S6, S7, S10\\}\\).  </li> <li>\\(\\tilde{S2} = \\{S1, S2, S6, S7\\}\\) est l\u2019intersection des accessibles et des  coaccessibles.  </li> </ul>"},{"location":"Graphes/1-Graphes/#isthme","title":"Isthme","text":"<p>D\u00e9finition: Isthme</p> <p>Une ar\u00eate \\(u\\) d\u2019un graphe \\(G\\) non orient\u00e9 est appel\u00e9e un isthme si sa suppression met ses extr\u00e9mit\u00e9s dans deux composantes connexes  di\ufb00\u00e9rentes (donc la suppression augmente le nombre de composante  connexes du graphe).  </p> <p></p> <p>Une seule composante connexe.</p> <p></p> <p>Deux composantes connexes apr\u00e8s suppression de \\(\\{S_4, S_5\\}\\).</p> <p>Proposition</p> <p>Soit \\(G\\) un graphe non orient\u00e9. Une ar\u00eate \\(u\\) est un isthme si et seulement si \\(u\\) n\u2019appartient \u00e0 aucun cycle  de \\(G\\).  </p> <p>Preuve</p> <p>Soit \\(u = \\{x, y\\}\\) une ar\u00eate avec \\(x \\neq y\\). On montre que \\(u\\) est un isthme si et  seulement si \\(u\\) n\u2019appartient \u00e0 aucun cycle de \\(G\\). </p> <ul> <li>Supposons que \\(u\\) soit un isthme. Supprimer \\(u\\) met \\(x\\), \\(y\\) dans deux  composantes connexes di\ufb00\u00e9rentes. Cela veut dire qu\u2019il n\u2019existe pas de  chemin de \\(x\\) \u00e0 \\(y\\) qui ne passe pas par \\(u\\). Et donc, \\(u\\) n\u2019est sur aucun  cycle.  </li> <li>Si \\(u\\) n\u2019appartient \u00e0 aucun cycle, supposons qu\u2019il y ait un chemin  allant de \\(x\\) \u00e0 \\(y\\) ne passant pas par \\(u\\) (on peut le prendre \u00e9l\u00e9metaire). En y ajoutant \\(u\\), on obtient un cycle passant par \\(u\\) : ABSURDE. Si on supprime \\(u\\), on ne peut donc plus joindre \\(y\\) depuis \\(x\\). Alors \\(x\\), \\(y\\)  sont dans deux \\(CC\\) di\ufb00\u00e9rentes. On en d\u00e9duit que \\(u\\) est un istme.  </li> </ul>"},{"location":"Graphes/1-Graphes/#nombre-daretes-et-de-sommets","title":"Nombre d\u2019ar\u00eates et de sommets","text":"<p>Proposition</p> <p>Soit \\(G\\) un graphe non orient\u00e9 sans boucle de \\(n\\) sommets et \\(p\\) ar\u00eates.  </p> <ul> <li>\\(G\\) connexe \\(\\Rightarrow p \u2265 n \u2212 1\\),  </li> <li>\\(G\\) acyclique (i.e. pas de cycle simple) \\(\\Rightarrow p \u2264 n \u2212 1\\).  </li> </ul> <p>Corollaire</p> <p>Si \\(G\\) non orient\u00e9 sans boucle est acyclique connexe, alors \\(p = n \u2212 1\\).</p> <p>Remarque Ce sont des conditions n\u00e9cessaires, pas suffisantes (exo : donner des contre-exemples).</p> <p>Preuve</p>"},{"location":"Graphes/1-Graphes/#si-g-s-a-non-oriente-est-connexe-p-n-1","title":"Si \\(G = (S, A)\\) non orient\u00e9 est connexe, \\(p \u2265 n \u2212 1\\)","text":"<p>Par r\u00e9currence forte :</p> <ul> <li>Vrai si \\(n = 1\\). Alors \\(p \u2265 0\\). Le graphe est connexe et \\(p \u2265 n \u2212 1\\) </li> <li>Si \\(n = 2\\), il faut qu\u2019il y ait une ar\u00eate entre les deux sommets pour que  le graphe soit connexe. Alors \\(p \u2265 1 = n \u2212 1\\).  </li> <li>Cas de base : OK. (Remarque : on pourrait ajouter des boucles \u00e7a ne  changerait rien).  </li> <li> <p>Si \\(P(k)\\) pour \\(n \u2265 2\\) et tout \\(k \u2264 n\\). Soit \\(G\\) connexe \u00e0 \\(n + 1\\) sommets. Tout sommet poss\u00e8de au moins une ar\u00eate incidente car \\(G\\) est connexe.  </p> <ul> <li>Si \\(G\\) poss\u00e8de un sommet \\(x\\) de degr\u00e9 \\(d(x) = 1\\), \\(x\\) n\u2019est sur aucune  cha\u00eene simple joignant deux autres sommets. On supprime \\(x\\) et son  unique arr\u00eate adjacente, le sous-graphe \\(G'\\) obtenu est connexe \u00e0 \\(n\\)  sommets. Par HR le nombre d\u2019ar\u00eates de \\(G'\\) est \\(p' \u2265 n \u2212 1\\). En  remettant l\u2019ar\u00eate de \\(x\\), on a au moins \\((n + 1) \u2212 1\\) ar\u00eates dans \\(G\\).  </li> <li>Sinon, tous les degr\u00e9s sont \\(\u2265 2\\). La somme des degr\u00e9s dans un graphe est \\(\\sum_{x \\in S}d(x) = 2p\\) car toutes les ar\u00eates sont compt\u00e9es deux fois. On  a donc  $$2p = \\sum_{x \\in S} \\underbrace{d(x)}_{\\geq 2} \\geq 2|S| = 2n+2 $$  Donc \\(p \\geq n+1 \\geq (n+1) - 1\\). OK</li> </ul> </li> </ul>"},{"location":"Graphes/1-Graphes/#si-g-est-non-oriente-sans-boucle-a-au-moins-n-aretes-il-nest-pas-acyclique","title":"Si \\(G\\) est non orient\u00e9 sans boucle a au moins \\(n\\) ar\u00eates, il n\u2019est pas acyclique","text":"<p>On raisonne par contrapos\u00e9e sur \\(\\text{G acyclique} \\Rightarrow p \\leq n-1\\).</p> <ul> <li>Pr\u00e9cisons : pas de cycle simple : \\(x_0 , x_1 , x_0\\) n\u2019est pas un cycle car la m\u00eame ar\u00eate est emprunt\u00e9 deux fois</li> <li>Si le graphe (qui est sans boucle) a au plus deux sommets, il ne poss\u00e8de pas de cycle simple puisqu\u2019il y a au plus une ar\u00eate qu\u2019on ne peut pas emprunter deux fois (en CPGE, il n\u2019y a pas de multigraphe : il existe au plus une ar\u00eate entre deux sommets).</li> <li>Pour \\(n = 3\\). S\u2019il y a \\(3\\) ar\u00eates, le graphe tout entier est un cycle.</li> </ul> <p>On consid\u00e8re des graphes non orient\u00e9s \u00e0 au moins \\(3\\) sommets. On raisonne par r\u00e9currence forte sur \\(|G| = n\\).  </p> <ul> <li>Cas de base \\(n = 3\\). S\u2019il y a \\(3\\) ar\u00eates, le graphe tout entier est un cycle.  </li> <li> <p>Supposons \\(P(k)\\) pour \\(k \u2265 3\\) et tout \\(k \u2264 n\\). Soit \\(G\\) \u00e0 \\(n + 1\\) sommets et  \\(p = n + 1\\) ar\u00eates. On montre qu\u2019il poss\u00e8de un cycle.  Consid\u00e9rons un  sommet quelconque \\(x\\).  </p> <ul> <li>S\u2019il n\u2019y a pas d\u2019ar\u00eate incidente \u00e0 \\(x\\), le graphe priv\u00e9 de \\(x\\) a \\(n\\) sommets  et \\(n + 1\\) ar\u00eates. Il y a un cycle par HR.  </li> <li> <p>Si il existe une ar\u00eate incidente \u00e0 \\(x\\) qui n\u2019est pas un isthme elle est  alors sur un cycle et \\(G\\) poss\u00e8de donc un cycle : OK.  </p> </li> <li> <p>Si toutes ar\u00eate \\(x\\)-incidente est un isthme, soit \\(u = \\{x, y\\} \\in E\\).  Retirons \\(u\\). Alors \\(x\\) se retrouve dans une composante connexe  di\ufb00\u00e9rente de celle de \\(y\\). S\u00e9parons la composante connexe de \\(x\\) et ses ar\u00eates (formant un sous graphe \\(G_1\\)) du reste du graphe (notons \\(G_2\\) ce reste).  </p> <ul> <li>\\(G_1\\) poss\u00e8de, disons \\(k\\) sommets \\((1 \u2264 k &lt; n + 1)\\), l\u2019autre \\(n + 1 \u2212 k\\). \\(G_1\\) poss\u00e8de \\(q_1\\) ar\u00eates et \\(G_2\\) en a \\(q_2\\) avec \\(q_1 + q_2 = n\\).  </li> <li>Si \\(q_1 \u2265 k\\), il y a un cycle dans \\(G_1\\) par HR donc dans \\(G\\) puisque \\(G_1\\) est  un sous-graphe de \\(G\\) : Prouv\u00e9.  </li> <li>Sinon, \\(q_2 = n \u2212 q_1 &gt; n \u2212 k\\) donc \\(q_2 \u2265 (n \u2212 k) + 1\\) et le sous-graphe \\(G\\) par HR a un cycle donc \\(G\\) aussi. CQFD </li> </ul> </li> </ul> </li> </ul>"},{"location":"Graphes/1-Graphes/#caracterisation-des-arbres-non-enracines","title":"Caract\u00e9risation des arbres non enracin\u00e9s","text":"<p>D\u00e9finition : Arbre non enracin\u00e9</p> <p>On appelle arbre non enracin\u00e9 tout graphe non orient\u00e9 sans boucle acyclique et connexe.</p> <p>Remarque</p> <p>On dit en g\u00e9n\u00e9ral arbre plut\u00f4t que arbre non enracin\u00e9 mais cette appelation am\u00e8ne des confusions avec la notion d\u2019arbre d\u00e9finie inductivement des chapitres pr\u00e9c\u00e9dents.</p> <p>Proposition</p> <p>Soit un graphe non orient\u00e9 sans boucle \\(G\\) de \\(n\\) sommets et \\(p\\) ar\u00eates, les  a\ufb03rmations suivantes sont \u00e9quivalentes : - \\(G\\) est un arbre non enracin\u00e9, - \\(G\\) est acyclique et contient \\(n \u2212 1\\) ar\u00eates \\((p = n \u2212 1)\\), - \\(G\\) est connexe et contient \\(p + 1\\) sommets.  </p> <p>On a d\u00e9j\u00e0 vu les sens directs.  </p> <p>Preuve</p>"},{"location":"Graphes/1-Graphes/#si-g-acyclique-et-p-n-1","title":"Si \\(G\\) acyclique et \\(p = n \u2212 1\\)","text":"<p>Si \\(x\\), \\(y\\) sont deux \u00e9l\u00e9ments non reli\u00e9s par un chemin, on ajoute l\u2019ar\u00eate  \\(\\{x, y \\}\\)  Cela cr\u00e9e un cycle puisque le nombre d\u2019ar\u00eate est \u00e9gal \u00e0 celui des  sommets. Ce nouveau cycle passe par l\u2019ar\u00eate \\(\\{x, y\\}\\) (avant, il n\u2019y en avait pas). Puisque cycle il y a, c\u2019est que \\(x\\) et \\(y\\) sont joignables sans passer par  \\(\\{x, y\\}\\) : ABSURDE Donc pour tous sommets \\(x\\) et \\(y\\), il y a un chemin de l'un \u00e0 l'autre : \\(G\\) est donc connexe</p>"},{"location":"Graphes/1-Graphes/#si-g-est-connexe-et-p-n-1","title":"Si \\(G\\) est connexe et \\(p = n \u2212 1\\)","text":"<p>Si \\(G\\) poss\u00e8de un cycle, soit \\(\\{x, y \\}\\) une ar\u00eate de ce cycle. Alors il y a un autre chemin de \\(x\\) \u00e0 \\(y\\) que cette ar\u00eate. Donc on peut  enlever l\u2019ar\u00eate \\(\\{x, y \\}\\) en conservant le caract\u00e8re connexe. Mais alors le nouveau graphe \\(G'\\) est encore connexe et poss\u00e8de \\(n\\)  sommets et \\(n \u2212 2\\) ar\u00eates. ABSURDE  Alors \\(G\\) est aussi acyclique. Et comme graphe connexe acyclique N.O. , \\(G\\) est un arbre.</p>"},{"location":"Graphes/1-Graphes/#graphes-particuliers","title":"Graphes particuliers","text":""},{"location":"Graphes/1-Graphes/#arbres-et-forets","title":"Arbres et for\u00eats","text":"<p>Pour certains auteurs, un arbre est un graphe non orient\u00e9 connexe et  acyclique. S\u2019il a \\(n\\) sommets, il poss\u00e8de donc \\(n \u2212 1\\) ar\u00eates. Comme il y a con\ufb02it avec la d\u00e9finition du cours, ces graphes non  orient\u00e9s connexes acycliques sont dits arbres non enracin\u00e9s (on l\u2019a  d\u00e9j\u00e0 vu). \u00c0 contrario, on parle des objets du premier chapitre (d\u00e9finis  inductivement) comme des arbres.  </p> <p>Dans un arbre non enracin\u00e9, on peut choisir une racine. Il y a alors un  chemin unique de la racine \u00e0 tous les sommets (cela se montre). La  pr\u00e9sence de la racine induit alors une orientation.  La structure ainsi construite est ce que certains auteurs appellent  arborescence ou arbre enracin\u00e9 (cf def \\(\\color{red}6\\))  </p> <p>Une arborescence n\u2019est pas encore un des objets que nous manipulons  sous le nom d\u2019arbres. Il n\u2019y a pas, dans les arborescences de notion  comme fils gauche et fils droit. Il manque une notion de lat\u00e9ralisation.  </p>"},{"location":"Graphes/1-Graphes/#forets","title":"For\u00eats","text":"<p>Une for\u00eat est un graphe non orient\u00e9 acyclique, c\u2019est une union disjointe  d\u2019arbres non enracin\u00e9s (qui en sont les composantes connexes).  </p> <p>Exemple</p> <p><p></p></p>"},{"location":"Graphes/1-Graphes/#racine-arborescence","title":"Racine, arborescence","text":"<p>D\u00e9finition: Racine et Arborescence</p> <p>Un sommet \\(r\\) d\u2019un graphe orient\u00e9 \\(G = (S , A)\\) est une racine de \\(G\\) si  pour tout sommet \\(x\\) de \\(G\\) il existe un chemin de \\(r\\) \u00e0 \\(x\\).  </p> <p>On dit qu\u2019un graphe orient\u00e9 \\(G = (S , A)\\) est une arborescence s\u2019il  poss\u00e8de un unique \u00e9l\u00e9ment \\(x_0\\) de degr\u00e9 entrant nul, si tous les autres  sont de degr\u00e9 entrant \\(1\\) et si il existe un chemin de \\(x_0\\) \u00e0 tous les  autres sommets.  </p> <p>Exemple</p> <p><p></p></p>"},{"location":"Graphes/1-Graphes/#graphes-non-orientes-particuliers","title":"Graphes non orient\u00e9s particuliers","text":""},{"location":"Graphes/1-Graphes/#statut-de-cette-section","title":"Statut de cette section","text":"<p>Cette section donne quelques exemples de graphes particuliers sans  qu\u2019aucune preuve ne soit donn\u00e9e.  </p>"},{"location":"Graphes/1-Graphes/#etoiles-peignes-chenilles","title":"Etoiles, peignes, chenilles","text":"<p>Etoile : Un arbre dont un sommet est adjacent \u00e0 tous les autres.</p> <p></p> <p>Chenille : arbre tel que tout sommet de degr\u00e9 \\(\\geq 2\\) est adjacent \u00e0 au plus deux sommets de degr\u00e9 \\(\\geq 2\\).</p> <p></p> <p>Peigne : Bon j'ai vraiment besoin de d\u00e9crire \u00e7a ?</p> <p></p>"},{"location":"Graphes/1-Graphes/#graphe-planaire","title":"Graphe planaire","text":"<p>Un graphe est planaire  si on peut le dessiner sans  qu\u2019aucune ar\u00eate n\u2019en coupe  une autre.  </p> <p>4-coloriabilit\u00e9 :  les sommets d\u2019un graphe planaire  peuvent \u00eatre colori\u00e9s  avec \\(4\\) couleurs sans  que deux sommets adjacents  ne soient de la m\u00eame couleur.  </p> <p></p>"},{"location":"Graphes/1-Graphes/#graphe-complet-tournoi","title":"Graphe complet, tournoi","text":"<p>Un graphe complet est un graphe  non orient\u00e9 o\u00f9  tous les sommets sont deux \u00e0 deux adjacents.  </p> <p></p> <p>Un tournoi est un graphe orient\u00e9  obtenu \u00e0 partir d\u2019un graphe complet  en orientant chaque ar\u00eate.  </p>"},{"location":"Graphes/1-Graphes/#graphe-biparti","title":"Graphe biparti","text":"<p>Un graphe biparti \\(G = (S , A)\\)  est un graphe (orient\u00e9 ou non orient\u00e9)  admettant une partition \\(\\{P_1, P_2\\}\\)  de ses sommets telle que  \\(\\{x, y\\} \\in A \\Rightarrow (x, y) \u2208 P_1 \u00d7 P_2 \u222a P_2 \u00d7 P_1\\) </p> <p>Les arbres (et plus g\u00e9n\u00e9ralement les for\u00eats)  sont des graphes bipartis.  </p> <p></p>"},{"location":"Graphes/1-Graphes/#graphe-biparti-complet","title":"Graphe biparti complet","text":"<p>Un graphe est dit biparti complet (ou encore est appel\u00e9 une biclique) s\u2019il  est biparti et contient le nombre maximal d\u2019ar\u00eates.  Si \\(P_1\\) est de cardinal \\(m\\) et \\(P_2\\) est de cardinal \\(n\\) le graphe biparti complet  est not\u00e9 \\(K_{m,n}\\).  </p> <p></p>"},{"location":"Graphes/1-Graphes/#un-peu-de-ocaml","title":"Un peu de OCAML","text":""},{"location":"Graphes/1-Graphes/#liste-dadjacence_3","title":"Liste d\u2019adjacence","text":"<pre><code>type graphe = int list array ;;\n(* graphe orient\u00e9 *)\nlet g1 = [|[1; 2]; [2]; [0]|];;\n(* graphe non orient\u00e9 *)\nlet g2 = [|[1; 2]; [2; 0]; [0; 1]|] ;;\n</code></pre> <p>Les sommets sont num\u00e9rot\u00e9s de \\(0\\) \u00e0 \\(|g| \u2212 1\\).  </p> <p></p> <p>Voir TD pour les exercices  </p>"},{"location":"Graphes/1-Graphes/#matrice-dadjacence_2","title":"Matrice d\u2019adjacence","text":"<pre><code>type graphe = int array array ;;\nlet g = Array . make_matrix 4 4 0;;\ng .(0) .(1) &lt; -1; g .(0) .(2) &lt; -1; g .(1) .(3) &lt; -1; g .(2) .(1) &lt; -1;;\n</code></pre> <p>Voir TD pour les exercices  </p>"},{"location":"Graphes/1-Graphes/#parcours-de-graphes","title":"Parcours de graphes","text":""},{"location":"Graphes/1-Graphes/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"Graphes/1-Graphes/#definition","title":"D\u00e9finition","text":"<p>En th\u00e9orie des graphes, un parcours de graphe est un algorithme  consistant \u00e0 explorer les sommets d\u2019un graphe de proche en proche \u00e0  partir d\u2019un sommet initial. Un cas particulier important est le parcours  d\u2019arbre.</p> <p>Un parcours d\u2019un graphe permet de choisir, \u00e0 partir des sommets  visit\u00e9s, le sommet suivant \u00e0 visiter.</p> <p>Le probl\u00e8me consiste \u00e0 d\u00e9terminer un ordre sur les visites des  sommets.</p> <p>Une fois le choix fait, l\u2019ordre des visites induit une num\u00e9rotation des  sommets visit\u00e9s (l\u2019ordre de leur d\u00e9couverte) et un choix sur l\u2019arc ou  l\u2019ar\u00eate utilis\u00e9 pour atteindre un nouveau sommet \u00e0 partir des sommets  d\u00e9j\u00e0 visit\u00e9s.</p> <p>Les arcs ou ar\u00eates distingu\u00e9s forment une arborescence ou un arbre, et  les num\u00e9ros des sommets sont croissants sur les chemins de  l\u2019arborescence ou les cha\u00eenes de l\u2019arbre depuis la racine.  </p>"},{"location":"Graphes/1-Graphes/#finalite","title":"Finalit\u00e9","text":"<p>Les algorithmes de parcours ne sont pas une fin en eux-m\u00eames. Ils servent  comme outil pour \u00e9tudier une propri\u00e9t\u00e9 globale du graphe, par exemple :</p> <ul> <li>Connexit\u00e9 et forte connexit\u00e9</li> <li>Existence d\u2019un circuit ou d\u2019un cycle et, le cas  \u00e9ch\u00e9ant, d\u00e9finition d\u2019un  ordre total sur les sommets compatible avec le sens des arcs (ce qu\u2019on  appelle tri topologique)  </li> <li>Calcul des plus courts chemins (notamment l\u2019algorithme de Dijkstra)  </li> <li>Calcul d\u2019un arbre recouvrant (notamment l\u2019algorithme de Prim)  </li> <li>Algorithmes pour les \ufb02ots maximums (comme l\u2019algorithme de  Ford-Fulkerson).  </li> <li>Coloration des sommets etc.  </li> </ul>"},{"location":"Graphes/1-Graphes/#analyse","title":"Analyse","text":"<p>La di\ufb03cult\u00e9 de l\u2019exploration consiste \u00e0 \u00e9viter de visiter plusieurs fois  un m\u00eame sommet. Pour cela on met en oeuvre un marquage des  sommets par des couleurs.  Lors d\u2019une exploration, chaque sommet passe par trois couleurs :</p> <ul> <li><code>bleu</code> tant que la visite du sommet n\u2019a pas commenc\u00e9e  </li> <li><code>vert</code> d\u00e8s que sa visite commence et tant le traitement n\u2019est pas termin\u00e9  </li> <li><code>rouge</code> d\u00e8s que le traitement est termin\u00e9  </li> </ul> <p>L\u2019exploration \u00e0 partir d\u2019un sommet s ne permet pas n\u00e9cessairement  d\u2019explorer tout le graphe (il peut y avoir plusieurs \\(CC\\)\\(/\\)\\(CFC\\) ). Pour  e\ufb00ectuer une exploration compl\u00e8te il faut relancer le parcours \u00e0 partir  d\u2019un sommet bleu tant qu\u2019il en existe.  </p>"},{"location":"Graphes/1-Graphes/#parcours-a-partir-dun-sommet","title":"Parcours \u00e0 partir d\u2019un sommet","text":"<p>On g\u00e8re une structure \\(S\\) (pile, file, ou autre). On dispose d\u2019une fonction  d\u2019ajout (dans) et de retrait (de) cette structure. Depuis un sommet donn\u00e9  on peut s\u00e9lectionner un successeur (par exemple un voisin).  Le parcours d\u00e9bute par un sommet \\(s_0\\).  </p> <pre><code>/* parcourir les sommets bleus accessibles depuis s0 \u2217/\nColorer en bleu tous les sommets .\nCr\u00e9er une structure S vide , y ajouter s0 ,colorer s0 en vert\n    tant que S n\u2019est pas vide faire\n    retirer un sommet s de S\n    (traiter s et le colorer en Rouge ) ou bien le rajouter \u00e0 S\n    si s a des successeurs Bleus\n        en choisir un ou m\u00eame plusieurs ;\n        le/les colorer en Vert ; le/les ajouter \u00e0 S ;\n    sinon\n        si s \u2208 S , le retrirer d\u00e9finitivement , traiter + colorer s en Rouge\n</code></pre> <p>D\u00e8s qu\u2019un sommet bleu est abord\u00e9, il devient vert. Suivant les traitements,  on peut choisir de traiter \\(s\\) \u00e0 plusieurs endroits (L6 ou L11).  </p>"},{"location":"Graphes/1-Graphes/#graphe-de-liaison-induit","title":"Graphe de liaison induit","text":"<p>Soit \\(G = (S , A)\\) un graphe et \\(s_0 \\in S\\). On appelle graphe de liaison  induit par l\u2019exploration de \\(G\\) \u00e0 partir de \\(x\\), le sous-graphe de \\(G\\)  engendr\u00e9 par les ar\u00eates\\(\\left \\{u,v \\right \\}\\in A\\) (resp. les arcs) par lesquelles  passent l\u2019exploration de \\(G\\) , (l\u2019exploration passe par \\(\\left \\{u,v \\right \\}\\) (resp.  \\((u, v)\\)) si celle-ci provoque le coloriage du sommet \\(v\\) en vert).  </p> <p>Pour un parcours depuis \\(s_0\\) :  </p> <ul> <li>on d\u00e9bute avec le graphe (\\(s_0,\\varnothing\\))</li> <li>lors du passage du parcours par un sommet \\(s\\) vert on ajoute chaque  voisin bleu \\(t\\) et l\u2019ar\u00eate (resp. arc) \\(\\left \\{s,t \\right \\}\\) (resp. \\((s, t)\\)) au graphe induit  (mais peut-\u00eatre pas tous en m\u00eame temps).</li> <li>On construit ainsi un graphe connexe ayant \\(k\\) sommets et \\(k \u2212 1\\) ar\u00eates,  autrement dit un arbre ou une arborescence.</li> </ul> <p>Le graphe de liaison induit par une exploration compl\u00e8te de \\(G\\) est un ensemble d\u2019arbre ou une arborescence.  </p>"},{"location":"Graphes/1-Graphes/#tableau-de-couleurs","title":"Tableau de couleurs","text":"<ul> <li> <p>On colorie tous les sommets en bleu \\((O(n))\\) puis on lance  l\u2019exploration de n\u2019importe quel sommet.  </p> </li> <li> <p>Lors d\u2019un parcours, chaque sommet entre au plus une fois dans  l\u2019accumulateur <code>Verts</code> , et n\u2019en sort qu\u2019au plus une fois (quand il  devient rouge).</p> </li> <li> <p>On s\u2019arrange pour que ces op\u00e9rations d\u2019entr\u00e9e et de sortie  dans/de l\u2019accumulateur sont de co\u00fbt constant. Pour r\u00e9aliser cette  condition, la solution que nous adoptons consiste \u00e0 utiliser un tableau  de couleurs \\(R,V,B\\).  </p> </li> </ul>"},{"location":"Graphes/1-Graphes/#parcours-en-largeur-dabord","title":"Parcours en largeur d'abord","text":""},{"location":"Graphes/1-Graphes/#algorithme","title":"Algorithme","text":"<p>L\u2019ensemble des sommets Verts est repr\u00e9sent\u00e9 par une file  (biblioth\u00e8que OCAML queue par exemple)</p> <p>\\(\\color{red}Principe\\) : on explore le graphe \u00e0 partir d\u2019un sommet en visitant  d\u2019abord tous les sommets voisins (\u00e0 une distance \\(1\\)), puis tous les  sommets voisins de ses voisins (\u00e0 une distance \\(2\\))....  </p> <p>\\(F\\) : file des sommets verts.  </p> <pre><code>procedure Largeur(G: graphe, s: sommet, F: file)\n    Colorier s en vert et Enfiler s\n    tant que F non vide faire\n        Defiler x\n        pour chaque voisin y de x:\n            si y est bleu alors\n                Enfiler y et le colorier en vert\n            Colorier x en rouge\n\nprocedure Largeur_totale (G:graphe, F:file)\n    Pour chaque sommet s :\n        si s est bleu alors\n            Largeur(G, s, F)\n\nColorier tous les sommets en bleu\nCr\u00e9er une file vide F /\u2217 file des sommets verts \u2217/\nLargeur_totale(G, F)\n</code></pre> <p>Variant de boucle <code>tant que</code> : nombre de sommets bleus + nombre de  sommets verts. L\u2019algorithme termine.  </p> <p>Animation du parcours en largeur d'abord :</p> <p></p> <p>A la fin on obtient :</p> <p></p> <p>Avec en rouge le graphe de liaison induit.</p> <p>Deux arborescences de racines respectives \\(S_1\\) et \\(S_5\\).</p>"},{"location":"Graphes/1-Graphes/#cout-des-operations-de-file","title":"Co\u00fbt des op\u00e9rations de file","text":"<p>Pour un graphe \\(G = (S , A)\\) avec \\(|A| = p\\) et \\(|S| = n\\) </p> <ul> <li>Tous les sommets sont colori\u00e9s en bleu exactement une fois au d\u00e9but  puis plus jamais : \\(O(n)\\).</li> <li>Un sommet finit toujours par entrer dans la file (soit du fait de la  boucle tant que , soit du fait de Largeur).  Du fait des tests de couleurs, il n\u2019y entre qu\u2019une fois.</li> <li>Un sommet finit toujours par quitter la file car l\u2019algorithme termine.</li> <li>Les op\u00e9rations d\u2019enfilement/d\u00e9filement sont en \\(O(1)\\). Le co\u00fbt total de  gestion de file est en \\(\\Theta(n)\\).  </li> </ul>"},{"location":"Graphes/1-Graphes/#gestion-des-listes-dadjacence","title":"Gestion des listes d\u2019adjacence","text":"<p>Pour un graphe \\(G = (S , A)\\) avec \\(|A| = p\\) et \\(|S| = n\\)</p> <ul> <li>Une liste d\u2019adjacence donn\u00e9e n\u2019est balay\u00e9e qu\u2019une fois et une seule (puisque chaque sommet est ajout\u00e9 dans la file puis d\u00e9fil\u00e9 une fois et  une seule). Chaque \u00e9l\u00e9ment de cette liste donne lieu \u00e0 des op\u00e9rations  de coloriage/enfilement en \\(O(1)\\).</li> <li>La somme des longueurs des listes d\u2019adjacence est en \\(\\Theta(\\left|A \\right|) = \\Theta(p)\\).  Donc le temps total consacr\u00e9 au balayage des listes d\u2019adjacence est en  \\(\\Theta(p)\\).</li> <li>Enfin la coloration initiale est en \\(\\Theta(n)\\).</li> <li>Le total des op\u00e9rations est en \\(\\Theta(n + p)\\) pour le parcours en largeur.  </li> </ul>"},{"location":"Graphes/1-Graphes/#proprietes-du-parcours-en-largeur-dabord","title":"Propri\u00e9t\u00e9s du parcours en largeur d\u2019abord","text":"<p>Consid\u00e9rons un parcours en largeur depuis un sommet \\(s\\) :</p> <ul> <li>\\(s\\) est le premier sommet rouge. Un sommet devient rouge avant ses  sucesseurs dans l\u2019ordre de parcours.</li> <li>Un sommet rouge n\u2019a que des sommets adjacents verts ou rouges (en  exo).  </li> <li>Si un sommet \\(x\\) est rouge alors il existe une cha\u00eene/chemin allant de \\(s\\)  \u00e0 \\(x\\) constitu\u00e9e uniquement de sommets rouges (en exo).  </li> <li>Si un sommet \\(x\\) est vert alors il existe une cha\u00eene/chemin allant de \\(s\\) \u00e0  \\(x\\) constitu\u00e9e uniquement de sommets verts ou rouges (en exo).  </li> <li>A la fin du parcours tous les sommets sont soit bleus, soit rouges (et la  file des verts est vide).  </li> </ul> <p>Cons\u00e9quence : \u00e0 la fin de l\u2019appel de <code>Largeur</code> les sommets rouges sont  tous les sommets accessibles \u00e0 partir de \\(s\\).  </p> <p>Preuve : accessiblit\u00e9 = coloration en rouge</p> <p>Posons \\(G = (S , A)\\) et faison un bfs depuis \\(s_0\\in S\\) . On montre qu\u2019il y a un  chemin vert/rouge depuis \\(s_0\\) vers tout sommet de la file, et qu\u2019existe un  chemin totalement rouge de \\(s_0\\) vers tout sommet rouge.</p> <ul> <li>Au tour \\(1\\), \\(s_0\\) sort de la file et devient rouge. Alors il y a un chemin  rouge de \\(s_0\\) \u00e0 \\(s_0\\). Et tous les voisins de \\(s\\) deviennent verts : donc il y a  un chemin rouge/vert vers eux.</li> <li> <p>Supposons la propri\u00e9t\u00e9 vraie au tour \\(k\\). Soit \\(s\\) le sommet d\u00e9fil\u00e9 au  tour \\(k + 1\\). Il faut v\u00e9rifier la propri\u00e9t\u00e9 pour le nouveau sommet rouge  et les nouveaux verts.  </p> <ul> <li>\\(s\\) devient rouge. Puisque \\(s\\) \u00e9tait dans la file, il y a \u00e9t\u00e9 plac\u00e9 par un  sommet \\(x\\) qui est devenu rouge. Par HR, il y a un chemin rouge de \\(s\\) \u00e0  \\(x\\) et donc (en ajoutant l\u2019arc \\((x, s)\\)) de \\(s_0\\) \u00e0 \\(s\\).</li> <li>Tout sommet \\(y\\) qui devient vert est un voisin de \\(s\\). Comme il y a un  chemin rouge de \\(s_0\\) \u00e0 \\(s\\), il y a un chemin rouge/vert de \\(s_0\\) \u00e0 \\(y\\) .  </li> </ul> </li> <li> <p>Si un sommet \\(x\\) est rouge, il y a un chemin (rouge) depuis \\(s\\) vers \\(x\\)  donc \\(x\\) est accessible.</p> </li> <li> <p>R\u00e9ciproquement. On montre que si un sommet est \u00e0 une distance  \\(k \u2264 n\\) de \\(s_0\\), alors il est rouge \u00e0 la fin du BFS. </p> <ul> <li> <p>Vrai pour la distance \\(d = 0\\). \\(s_0\\) est accessible depuis \\(s\\) et il est rouge.  Cas de base OK.</p> </li> <li> <p>Si la propri\u00e9t\u00e9 est vraie pour tout sommet accesible \u00e0 la distance k de  \\(s_0\\), soit \\(x\\) \u00e0 la distance \\(k + 1\\) (s\u2019il n\u2019existe pas de sommet \u00e0 la distance  \\(k + 1\\), il n\u2019en existe pas non plus \u00e0 une distance sup\u00e9rieure et la propri\u00e9t\u00e9 est prouv\u00e9e).</p> </li> <li> <p>Alors le pr\u00e9d\u00e9cesseur \\(y\\) de \\(x\\) dans un PCC de \\(s_0\\) \u00e0 \\(x\\) est \u00e0 la distance \\(k\\)  de \\(s_0\\) (un sous-chemin de PCC est un PCC). Par HR, il devient rouge \u00e0  un moment.</p> </li> <li> <p>Donc si \\(x\\) est bleu au moment o\u00f9 \\(y\\) devient rouge, alors \\(y\\) le marque en vert et \\(x\\) finit par devenir rouge. Et si \\(x\\) est d\u00e9j\u00e0 marqu\u00e9 quand \\(y\\) devient rouge, alors \\(x\\) devient rouge. (Tout sommet qui entre dans la file en sort et devient rouge)         </p> </li> </ul> </li> </ul>"},{"location":"Graphes/1-Graphes/#parcours-en-profondeur-dabord","title":"Parcours en profondeur d'abord","text":""},{"location":"Graphes/1-Graphes/#presentation_1","title":"Pr\u00e9sentation","text":"<p>Principe : on explore le graphe \u00e0 partir d\u2019un sommet \\(x\\) en visitant l\u2019un  de ses sommets successeurs \\(y\\) et en poursuivant l\u2019exploration d\u2019abord  par les successeurs de ce dernier avant les autres successeurs de \\(x\\).  </p> <p>Ainsi l\u2019exploration s\u2019e\ufb00ectue en suivant le plus loin possible une  cha\u00eene issue de \\(x\\). Lorsque tous les successeurs d\u2019un sommet ont \u00e9t\u00e9 visit\u00e9s, on continu l\u2019exploration en remontant dans la cha\u00eene au  premier sommet ayant encore des successeurs non visit\u00e9s.  </p> <p>On g\u00e8re une pile des sommets verts (biblioth\u00e8que OCAML listes ou  stack, python : listes ou classe deque)  </p>"},{"location":"Graphes/1-Graphes/#algorithme_1","title":"Algorithme","text":"<p>On utilise une pile pour g\u00e9rer les sommets verts.</p> <pre><code>procedure Profondeur(G: graphe, P: pile)\n    Si P non vide\n        x := Peek P /*R\u00e9cup\u00e8re le sommet de la pile sans d\u00e9piler */ \n        tant qu'il existe un voisin bleu y de x faire\n            Empiler ce voisin; /*il devient vert*/ \n            Profondeur (G,P)\n        fin_faire\n        Depiler x\n        Colorier x en rouge\n\nColorier tous les sommets en bleu\nCr\u00e9er une pile P vide /* Pile des sommets verts */\ntant que des sommets bleus sont pr\u00e9sents faire\n    s := choisir un sommet bleu;\n    empiler s dans P; /*revient \u00e0 colorier s en vert*/ \n    Profondeur (G,P)\n</code></pre>"},{"location":"Graphes/1-Graphes/#en-pratique","title":"En pratique","text":"<p>Un m\u00eame n\u0153ud \\(s\\) appara\u00eet plusieurs fois au sommet de la pile. Il faut  donc g\u00e9rer un marqueur de progression dans sa liste de voisins pour  \u00e9viter de reprendre cette liste depuis le d\u00e9but \u00e0 chaque passage de \\(s\\)  au sommet de la pile.  </p> <p>Solution : consid\u00e9rer les listes de voisins comme des piles. On d\u00e9pile  jusqu\u2019\u00e0 trouver un sommet bleu. Les voisins d\u00e9pil\u00e9s ne reviennent  jamais dans la pile de voisins. Cela impose de faire une copie du graphe (\\(O(n)\\) si le graphe est un tableau de listes de voisins.)  </p>"},{"location":"Graphes/1-Graphes/#nombre-doperations-due-a-un-sommet","title":"Nombre d\u2019op\u00e9rations due \u00e0 un sommet","text":"<p>On analyse le nombre d\u2019op\u00e9rations engendr\u00e9es par la pr\u00e9sence d\u2019un  sommet donn\u00e9 \\(s\\) en haut de la pile. Il su\ufb03ra de sommer sur tous les  sommets pour obtenir la complexit\u00e9 totale. (Ajouter aussi le co\u00fbt  d\u2019initialisation en \\(O(n)\\)).</p> <ul> <li>Le sommet \\(s\\) entre toujours dans la pile (soit du fait de la boucle <code>tant que</code>, soit du fait de <code>Profondeur</code>). Le coloriage assure que le sommet  ne revient pas dans la pile verte quand il l\u2019a quitt\u00e9e.  </li> <li>Le sommet \\(s\\) appara\u00eet au plus \\(deg\\text{ }s^+ + 1\\) fois au sommet de la pile  (s\u2019en convaincre avec le graphe \\(x \u2192 y\\)).  </li> <li>A chaque apparition au sommet de la pile verte, il y a une recherche d\u2019un voisin bleu (on peut la rendre AU TOTAL en \\(O(deg^+ s)\\) pour tout l\u2019algo) ; un coloriage/empilement dans la pile verte parfois (au plus \\(deg^+ s\\) fois).  </li> <li>\\(s\\) est d\u00e9pil\u00e9 puis colori\u00e9 en rouge une seule fois.  </li> </ul> <p>La pr\u00e9sence de \\(s\\) en haut de la pile engendre donc un nombre  d\u2019op\u00e9rations (major\u00e9 par un nombre) proportionnel \u00e0 son nombre de  pr\u00e9sences au sommet, soit \\(1 + deg s^+\\) .  </p>"},{"location":"Graphes/1-Graphes/#complexite-totale","title":"Complexit\u00e9 totale","text":"<p>Pour un graphe \\(G = (S, A)\\) avec \\(|A| = p\\) et \\(|S| = n\\) </p> <ul> <li>On somme les nombres d\u2019op\u00e9rations occasionn\u00e9es par chaque sommet pour obtenir la complexit\u00e9 totale.  </li> <li>Le nombre total d\u2019op\u00e9ration est (major\u00e9 par un nombre) proportionnel  \u00e0  </li> </ul> \\[\\sum_{s\\in S}(1 + deg^+ s) = n + \\sum_{i\\in S}deg^+ s  = n + p = O(n+p)\\] <ul> <li>M\u00eame si on ajoute le co\u00fbt d\u2019initialisation en \\(O(n)\\) et la copie en \\(O(n+p)\\), l\u2019ensemble reste en  \\(O(n)\\) </li> </ul>"},{"location":"Graphes/1-Graphes/#observations","title":"Observations","text":"<p>Les invariants suivants sont maintenus  </p> <ul> <li>A tout moment, la pile d\u00e9crit un chemin entre \\(s\\) (la base) et le haut  de la pile.  </li> <li>Lorsqu\u2019on colorie un sommet \\(x\\) en vert, tous les sommets bleus  accessibles \u00e0 partir de \\(x\\) seront colori\u00e9s en rouges avant que \\(x\\) ne le  soit.  </li> <li>A la fin du parcours, l\u2019ensemble des sommets rouges est l\u2019ensemble  des sommets accessibles \u00e0 partir de \\(s\\) qui \u00e9taient bleus au moment  l\u2019entr\u00e9e de \\(s\\) dans la pile.  </li> </ul> <p>Animation du parcours en largeur d'abord :</p> <p></p> <p>A la fin on obtient :</p> <p></p>"},{"location":"Graphes/1-Graphes/#vocabulaire","title":"Vocabulaire","text":"<p>Soit \\(G_l = (S , L)\\) le graphe de liaison induit par le parcours en  profondeur d\u2019un graphe \\(G\\) . Un arc \\(u \u2192 v\\) est :  </p> <ul> <li>un arc de <code>liaison</code> si et seulement si \\(u \\rightarrow v \\in L\\) </li> <li>un arc <code>retour</code> si et seulement si \\(u\\) est un descendant de \\(v\\) dans \\(L\\).  </li> <li>un arc <code>avant</code> si et seulement si \\(v\\) est un descendant de \\(u\\) dans \\(L\\) et  \\(u \\rightarrow v \\notin L\\)   (on prend de l\u2019avance par rapport au cheminement normal  dans \\(L\\))  </li> <li>un arc couvrant sinon (tous les autres arcs).  </li> </ul>"},{"location":"Graphes/1-Graphes/#variante","title":"Variante","text":"<p>Certains auteurs, g\u00e8rent le parcours en profondeur comme le parcours  en largeur mais utilisent juste une pile et non une file.</p> <p>Dans ce type de parcours, un m\u00eame sommet n\u2019appara\u00eet qu\u2019une seule  fois au sommet de la pile verte.  </p> <p>D\u00e8s qu\u2019un sommet appara\u00eet au sommet de la pile, il est d\u00e9pil\u00e9 (une  fois pour toute) et on ajoute en une seule fois tous ses voisins bleus  au sommet de la pile. Un sommet devient alors rouge avant ses  successeurs.  </p> <p>L\u2019\u00e9criture du programme est alors plus simple, puisqu\u2019une m\u00eame liste  de voisins n\u2019est parcourue qu\u2019une fois pour toute (alors qu\u2019avec ma  version, on la parcourt \"par bouts\" en \\(y\\) revenant plusieurs fois).  </p> <p>En revanche, on perd une propri\u00e9t\u00e9 importante : la pile ne d\u00e9crit plus  exactement un chemin de la base au sommet mais est un simple  accumulateur de sommets rencontr\u00e9s.  </p> <pre><code>Profondeur2 (G: graphe, s: sommet)\n    Cr\u00e9er P : pile vide des sommets verts\n    Colorier s en vert et Empiler s \n    tant que P non vide faire\n        x := Depiler P /*x ne sera plus jamais au sommet*/ \n        pour chaque sommet adjacent y de x:\n            /* tous les voisins de x ajout\u00e9s en une seule fois */\n            si y est bleu alors\n                Colorier y en vert et Empiler y dans P\n        Colorier x en rouge /*x devient rouge avant tous ses voisins*/\n</code></pre> <p>A noter qu\u2019il n\u2019y a plus vraiment de raison d\u2019utiliser trois couleurs ; deux  su\ufb03sent.  </p>"},{"location":"Graphes/1-Graphes/#graphes-acyclique","title":"Graphes acyclique","text":""},{"location":"Graphes/1-Graphes/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":"<p>Graphe <code>acyclique</code>: un graphe qui ne contient pas de circuit/cycle.  </p> <p>Certain probl\u00e8mes n\u2019ont de solution que pour des graphes acycliques :  plus court chemin, ordonnancement...  </p> <p>Si un graphe est acyclique on peut concevoir des algorithmes qui  s\u2019arrangent pour traiter tous les pr\u00e9decesseurs d\u2019un sommet donn\u00e9  avant de traiter ce sommet (variante du parcours en profondeur).  </p>"},{"location":"Graphes/1-Graphes/#propietes","title":"Propi\u00e9t\u00e9s","text":""},{"location":"Graphes/1-Graphes/#cas-des-graphes-orientes","title":"Cas des graphes orient\u00e9s","text":"<p>Propri\u00e9t\u00e9s</p> <p>Un graphe contient un circuit si et seulement si lors du  parcours en profondeur l\u2019un des successeurs du sommet en haut de la  pile verte est d\u00e9j\u00e0 vert.  </p> <p>Exemple</p> <p><p></p></p> <p>\\(S_6\\) a pour successeur \\(S_1\\) qui est d\u00e9j\u00e0 vert \\(\\Rightarrow\\) un circuit.  </p> <p>Autre fa\u00e7on de dire que le graphe est acyclique : le graphe de liaison  induit par un parcours en profondeur d\u2019un graphe sans circuit ne  g\u00e9n\u00e8re aucun arc retour.  </p> <p><p></p></p> <p>Il y a des arcs retour (en vert) \\(\\Rightarrow\\) des circuits  </p> <p>L\u2019algorithme pour la d\u00e9tection de circuit dans un graphe est une variante  du parcours en profondeur : quand on examine les arcs issus du sommet de  la pile, il su\ufb03t de regarder si un arc ne pointe pas vers un n\u0153ud vert. On  s\u2019ar\u00eate d\u00e8s que c\u2019est le cas.  </p> <p>Preuve de la m\u00e9thode</p> <p>On montre que la pr\u00e9sence d\u2019un cycle est \u00e9quivalente \u00e0 l\u2019existence d\u2019un arc retour.  </p>"},{"location":"Graphes/1-Graphes/#sil-existe-un-arc-retour","title":"S'il existe un arc retour","text":"<ul> <li>Si la pile verte \\(P\\) a \\(r &gt; 1\\) sommets, le dernier sommet vert a \u00e9t\u00e9 ajout\u00e9 parce qu\u2019il existe un arc de  \\(P[\u22122]\\) \u00e0 \\(P[\u22121]\\) (notations Python).  </li> <li>Par r\u00e9currence, on obtient l\u2019existence d\u2019un chemin de  tout sommet dans la pile vers les sommets sup\u00e9rieurs.  </li> <li>Donc si on empile un sommet, et qu\u2019un de ses  successeurs est d\u00e9j\u00e0 vert (ce qui est la d\u00e9finition d\u2019un  arc retour), il y a un cycle.  </li> </ul>"},{"location":"Graphes/1-Graphes/#sil-existe-un-cycle-reciproque","title":"S'il existe un cycle (R\u00e9ciproque)","text":"<p>Supposons l\u2019existence d\u2019un cycle. On peut le consid\u00e9rer sans doublon  (sinon enlever des sommets juqu\u2019\u00e0 ce qu\u2019il ne contienne que des sommets  distincts).  Soit \\(x\\) le premier sommet du cycle \u00e0 \u00eatre empil\u00e9. Tous les autres sommets du cycle sont bleus.  </p> <ul> <li>Le second sommet du cycle sera vert avant que \\(x\\) devienne rouge  puisque c\u2019est un voisin de \\(x\\).  </li> <li>De proche en proche, on \u00e9tablit que \u00e0 un moment tous les sommets  du cycle sont dans la pile. Donc, le dernier sommet du cycle avant \\(x\\),  notons le \\(y\\) , devient vert alors que \\(x\\) est encore dans la pile. Comme il  y a un arc \\((y , x)\\), cet arc est un arc retour.  </li> </ul>"},{"location":"Graphes/1-Graphes/#tri-topologique","title":"Tri topologique","text":""},{"location":"Graphes/1-Graphes/#presentation_2","title":"Pr\u00e9sentation","text":"<p>Exemple de probl\u00e8me : \u00e9tant donn\u00e9 un ensemble de t\u00e2che \u00e0 effectuer avec des contraintes d'ant\u00e9riorot\u00e9, on veut construire une liste de ces t\u00e2ches respectant les contraintes</p> <p>Repr\u00e9sentation : \u00e0 l'aide d'un graphe orient\u00e9 o\u00f9 chaque sommet repr\u00e9sente une t\u00e2che et o\u00f9 chaque arc \\(x \\rightarrow y\\) signifie que la t\u00e2che \\(x\\) doit \u00eatre effectu\u00e9e avant la t\u00e2che \\(y\\). on dit que \\(x\\) est un pr\u00e9decesseur de \\(y\\), \\(y\\) est un successeur de \\(x\\).</p> <p>La r\u00e9solution de ce probl\u00e8me consiste \u00e0 effectuer un tri topologique des sommets du graphes, c'est \u00e0 dire \u00e0 construire une liste ordon\u00e9ee des sommets telle qu'aucun sommet du graphes n'appara\u00eet dans la liste avant l'un de ses pr\u00e9d\u00e9cesseurs.</p> <p>On peut repr\u00e9senter les sommets align\u00e9s de gauche \u00e0 droite sans qu'aucun arc n'aille de droite \u00e0 gauche</p> <p>D\u00e9finition: Tri topologique</p> <p>On appelle <code>tri topologique</code> d'un graphe orient\u00e9 \\(G = (S, A)\\) toute injection \\(r: S\\rightarrow \\mathbb{N}\\) telle que \\(\\forall x \\rightarrow y \\in A: r(x) \\le r(y)\\). On appelle \\(r(x)\\) le rang du sommet \\(x\\).</p> <p></p>"},{"location":"Graphes/1-Graphes/#tri-topologique-et-acyclicite","title":"Tri topologique et acyclicit\u00e9","text":"<p>Proposition</p> <p>Un graphe \\(G\\) orient\u00e9 est acyclique si et seulement si il existe un tri topologique de \\(G\\).</p> <p>Preuve</p>"},{"location":"Graphes/1-Graphes/#graphe-acyclique-rightarrow-tri-topologique","title":"Graphe acyclique \\(\\Rightarrow\\) tri topologique","text":"<p>Pour trier topologiquement un graphe acyclique orient\u00e9 contenant \\(n\\) sommets, on effectue un parcours en profondeur et on num\u00e9rote de mani\u00e8re d\u00e9croissante les sommets \u00e0 partir de \\(n\\) au fur et \u00e0 mesure qu\u2019ils deviennent rouges : \\(r(s) = n\\) si \\(s\\) est le premier rouge, \\(r(s) = 1\\) si \\(s\\) est le dernier. On montre que la m\u00e9thode est correcte.</p> <ul> <li>Supposons \\(G\\) acyclique. Si \\(r (x) &lt; r (y)\\), c\u2019est que y devient rouge avant \\(x\\). On raisonne par l\u2019absurde en supposant qu\u2019il existe un arc \\((y , x)\\).</li> <li>Au moment de l\u2019empilement de \\(y\\) (donc quand \\(y\\) devient vert), si \\(x\\) est bleu, alors \\(x\\) est empil\u00e9 apr\u00e8s \\(y\\) donc devient rouge avant, ce qui contredit \\(r (x) &lt; r (y)\\).</li> <li>Si au moment de l\u2019empilement de \\(y\\) , \\(x\\) est d\u00e9j\u00e0 rouge, alors \\(r (x) &gt; r (y)\\), ce qui est absurde.</li> <li>Donc au moment de l\u2019empilement de \\(y\\) , \\(x\\) est vert. Et comme il y a un arc \\((y , x)\\), cela r\u00e9v\u00e8le un circuit : absurde.</li> </ul>"},{"location":"Graphes/1-Graphes/#tri-topologique-rightarrow-graphe-acyclique","title":"Tri topologique \\(\\Rightarrow\\) graphe acyclique","text":"<p>Soit \\(G = (S , A )\\) un graphe orient\u00e9. Rappel : un tri toplogique \\(r\\) est une num\u00e9rotation injective des sommets telle que pour deux sommets \\(x, y\\) : \\((r(x) \\le r(y) \\Rightarrow y \\rightarrow x \\notin A)\\).</p> <ul> <li>On suppose qu\u2019existe un circuit \u00e9l\u00e9mentaire \\(C\\) et on prend \\(x\\) dans ce circuit tel que \\(r(x) = min(\\{ r(y)\\text{ | }y \\in C \\})\\).</li> <li>Soit \\(y\\) le pr\u00e9decesseur de \\(x\\) dans \\(C\\) . Comme \\(y \\rightarrow x \\in A\\), on a \\(r(y) &lt; r(x)\\). Contradiction avec \\(r(x) \\leq r(y)\\).</li> </ul>"},{"location":"Graphes/1-Graphes/#composantes-fortement-connexes-cfc","title":"Composantes fortement connexes (CFC)","text":""},{"location":"Graphes/1-Graphes/#observations_1","title":"Observations","text":"<p>Soit \\(G = (S, A)\\) un graphe orient\u00e9. On a vue qu\u2019une composante fortement connexe de \\(G\\) contenant un sommet \\(x\\) est l\u2019ensemble des sommets \\(y\\) tels que \\(y\\) est accessible \u00e0 partir de \\(x\\) et \\(x\\) est accessible \u00e0 partir de \\(y\\).</p> <p>Le parcours en profondeur d\u2019un graphe \u00e0 partir d\u2019un sommet \\(x\\) ayant comme r\u00e9sultat l\u2019ensemble des sommets accessibles \u00e0 partir de \\(x\\), on va utiliser ce parcours pour calculer la composante fortement connexe contenant \\(x\\).</p>"},{"location":"Graphes/1-Graphes/#principe","title":"Principe","text":"<p>D\u00e9finition: Graphe Transpos\u00e9</p> <p>Le graphe transpos\u00e9 \\(G^{-1}\\) d'un graphe \\(G\\) s'obtient en inversant chacun de ses arcs.</p> <p>Soit \\(G\\) un graphe orient\u00e9 et \\(x\\) un sommet.</p> <p>Parcourir en profondeur \\(G\\) \u00e0 partir du sommet \\(x\\) pour calculer l\u2019ensemble \\(A\\) des sommets accessibles \u00e0 partir de \\(x\\).</p> <p>Parcourir en profondeur le graphe transpos\u00e9 \\(G^{-1}\\) \u00e0 partir de \\(x\\) pour calculer l\u2019ensemble \\(B\\) des sommets dans \\(G\\) \u00e0 partir desquels \\(x\\) est accessible.</p> <p>L\u2019ensemble des sommets \\(A \\cap B\\) est la composante fortement connexe de \\(x\\) dans \\(G\\).</p> <p>L\u2019intersection des CFC de \\(x\\) dans \\(G\\) et \\(G^{-1}\\) peut s\u2019effectuer en \\(O((|A| + |B|)\\times ln(|A \\cap B|))\\) si on repr\u00e9sente les ensembles par des ABR \u00e9quilibr\u00e9s.</p>"},{"location":"Graphes/1-Graphes/#cfc-en-mpi","title":"CFC en MPI","text":"<p>On verra en MPI une meilleure m\u00e9thode : l'algorithme de Kosaraju-Sharir.</p> <p>Id\u00e9e : Le graphe des CFC est orient\u00e9 et acyclique et on le parcourt dans l'ordre inverse d'un de ses tris topologiques.</p> <p></p>"},{"location":"Graphes/2-PCC/","title":"Plus cours chemin","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Graphes/2-PCC/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":""},{"location":"Graphes/2-PCC/#graphe-pondere","title":"Graphe pond\u00e9r\u00e9","text":"<p>D\u00e9finition : Graphe pond\u00e9r\u00e9</p> <p>On dit qu'un triplet \\(G = (V, E, p)\\) est un graphe pond\u00e9r\u00e9 si le couple \\((V,E)\\) est un graphe et si \\(p\\) est une fonction de \\(E\\) dans \\(\\mathbb{R}\\)</p> <p>On dit que \\(p\\) est la (fonction de) pond\u00e9ration. Souvent not\u00e9e \\(w\\) pour weight.</p> <p>Si \\(e \\in E\\), alors \\(p(e)\\) est le poids de \\(e\\) ou pond\u00e9ration de \\(e\\).</p> <p>Les graphes sont munis par d\u00e9faut de la fonction de pond\u00e9ration \\(p:E \\to \\mathbb{R}, e \\mapsto 1\\). Donc tout graphe est un graphe pond\u00e9r\u00e9 qui s'ignore.</p>"},{"location":"Graphes/2-PCC/#poids-dune-chaine","title":"Poids d'une cha\u00eene","text":"<p>D\u00e9finition : Poids d'une cha\u00eene</p> <p>Le poids d'une cha\u00eene (resp. chemin) d'un graphe pond\u00e9r\u00e9 non orient\u00e9 (resp. orient\u00e9) est la somme des poids des ar\u00eates(resp. arcs) de la cha\u00eene (resp. chemin).</p> <p>Si \\(c\\) est la cha\u00eene \\(x_1, \\dots, x_n\\) :</p> \\[p(c) = \\sum_{i=1}^{n-1} p(\\{x_i, x_{i+1}\\})\\] <p><pre><code>graph LR\nA(A) ---- 7 ---&gt; B(B)\nA --- 5 --&gt; C(C)\nA -- 2 --&gt; D\nC --- 6 --&gt; D(D)</code></pre> Figure - graphe \\(ABCD\\) avec les poids \\(7\\) \\(5\\) \\(-2\\) et \\(6\\) en mermaid</p> <p>\\(p(ACDA) = -2 +6 +5 = 9\\)</p> <p>\\(p(ADC) = -2+6 = 4 \\text{ et } p(AC)=5\\)</p> <p>Le plus court chemin de \\(A\\) \u00e0 \\(C\\) est \\(ADC\\)</p>"},{"location":"Graphes/2-PCC/#le-plus-court-chemin","title":"Le plus court chemin","text":"<p>Etant donn\u00e9 un graphe pond\u00e9r\u00e9, on recherche le plus court chemin d\u2019un sommet \u00e0 un autre (ou \u00e0 tous les autres, ou le plus court chemin entre tous les couples de sommets...)</p> <p>Exemple :</p> <p>Dans une carte routi\u00e8re de la France, les villes \u00e9tant des sommets, les routes \u00e9tant des arcs, chercher le (ou les) trajet(s) de Paris \u00e0 Marseille qui optimise(nt) l'un des crit\u00e8res suivants :</p> <ul> <li>le temps de trajet</li> <li>la distance parcourue</li> <li>le prix des p\u00e9ages</li> </ul>"},{"location":"Graphes/2-PCC/#recherche-de-plus-courts-chemins","title":"Recherche de plus courts chemins","text":"<p>Dans tout ce qui suit, les graphes sont consid\u00e9r\u00e9s comme orient\u00e9s. Si le graphe \\(G\\) est non orient\u00e9, on l'oriente en construisant le graphe orient\u00e9 tel que :</p> <ul> <li>\\(G'\\) a les m\u00eames sommets que \\(G\\)</li> <li>pour tout ar\u00eate \\(\\{x, y\\}\\) de \\(G\\), \\(G'\\) poss\u00e8de les arcs \\(\\{x, y\\}\\) et \\(\\{y, x\\}\\)</li> </ul> <p>On recherche pour tout couple de sommets \\((i, j)\\) le plus court chemin de \\(i\\) \u00e0 \\(j\\) et on calcule sa longueur \\(d(i, j)\\). Si \\(j\\) n'est pas accessible depuis \\(i\\), on note \\(d(i, j) = +\\infty\\).</p>"},{"location":"Graphes/2-PCC/#longueur-de-plus-courts-chemins","title":"Longueur de plus courts chemins","text":""},{"location":"Graphes/2-PCC/#cas-particuliers-des-graphes-orientes-non-ponderes","title":"Cas particuliers des graphes orient\u00e9s non pond\u00e9r\u00e9s","text":"<p>Si le graphe \\(G\\) est orient\u00e9 et non pond\u00e9r\u00e9, on consid\u00e8re sa pond\u00e9ration par d\u00e9faut.</p> <p>Lors du parcours en largeur les sommets sont explor\u00e9s par distance croissante au sommet source. Gr\u00e2ce \u00e0 cette propri\u00e9t\u00e9 on r\u00e9sout le probl\u00e8me de cheminement suivant : calculer les longueurs des plus courts chemins entre un sommet source et tous les sommets du graphe (voir TD).</p>"},{"location":"Graphes/2-PCC/#circuits-de-poids-negatif","title":"Circuits de poids n\u00e9gatif","text":"<p>Pour rechercher un \\(PCC\\)( \\(=\\) plus court chemin) dans un graphe, il faut s'assurer au pr\u00e9alable que celui-c ne poss\u00e8de pas de circuit de poids n\u00e9gatif. Cela ne veut pas dire que le graphe ne peut pas contenir d'arcs de poids n\u00e9gatif.</p> <pre><code>graph LR\nA(A) -- -1 --&gt; B(B)\nC(C) -- 1 --&gt; A\nB -- -2 --&gt; C\nC --3--&gt; D(D)</code></pre> \\[p(ABCA) = -2\\] \\[p(ABCD) = 0\\] \\[p(ABCABCD) = -2\\] \\[p(ABCABCABCD) = -4\\]"},{"location":"Graphes/2-PCC/#sous-chemin-du-plus-court-chemin","title":"Sous-chemin du plus court chemin","text":"<p>Si un \\(PCC\\) de \\(A\\) \u00e0 \\(C\\) passe par \\(B\\), alors le sous-chemin entre \\(A\\) et \\(B\\) est un chemin de poids minimum.</p> <p>En effet, s\u2019il existe un autre chemin plus court entre \\(A\\) et \\(B\\), il suffit de le mettre \u00e0 la place du premier pour obtenir un nouveau chemin de \\(A\\) \u00e0 \\(C\\) encore plus court.</p> <ul> <li>Ceci contredit le fait que le premier chemin avait un poids minimum.</li> <li>Ceci est un cas particulier du principe d\u2019optimalit\u00e9 de Bellman qui dit que l\u2019on peut d\u00e9duire une solution optimale d\u2019un probl\u00e8me en combinant des solutions optimales d\u2019une s\u00e9rie de sous-probl\u00e8mes.</li> </ul> <p>Pour les \\(PCC\\), on l\u2019utilise en calculant d\u2019abord les \\(PCC\\) passant par un sous-ensemble de sommets avant de s\u2019attaquer aux \\(PCC\\) passant par un ensemble de sommets plus gros.</p>"},{"location":"Graphes/2-PCC/#algorithme-de-floyd-warshall","title":"Algorithme de Floyd-Warshall","text":""},{"location":"Graphes/2-PCC/#presentation","title":"Pr\u00e9sentation","text":"<p>L'lagorithme de Floyd-Warshall (parfois appel\u00e9 algorithme de Roy-Floyd-Warshall car d\u00e9crit par Bernard Roy en 1959) est un algorithme pour d\u00e9terminer les distances des plus courts chemins entre toutes les paires de sommets dans un graphe orient\u00e9 et pond\u00e9r\u00e9, en temps cubique en le nombre de sommets.</p> <p>Il prend en entr\u00e9e un graphe orient\u00e9 et valu\u00e9, d\u00e9crit par une matrice d'adjacence donnant le poids d'un arc lorsqu'il existe et la valeur \\(+\\infty\\) sinon. Le graphe ne doit pas poss\u00e9der de circuit de poids strictement n\u00e9gatif.</p> <p>C'est un exemple de programmation dynamique.</p> <p>Notons \\(\\{1, 2, \\dots, n\\}\\) l'ensemble des sommets du graphe. On note aussi \\(W_{ij}^k\\) la valeur de l'arc allant de \\(i\\) \u00e0 \\(j\\) n'empruntant que des sommets interm\u00e9diaires dans \\(\\{1, 2, \\dots, k\\}\\) s'il en existe un, et \\(+\\infty\\) sinon.</p> <p>On note \\(W^k\\) la matrice des \\(W_{ij}^k\\)</p> <p>Pour \\(k=0\\), \\(W^0\\) est la matrice d\u2019adjacence par poids. Trouvons une relation de r\u00e9currence. On consid\u00e8re un chemin \\(C\\) entre \\(i\\) et \\(j\\) de poids minimal dont les sommets interm\u00e9diaires sont dans \\(\\{1, 2, \\dots, k\\}\\). De deux choses l\u2019une :</p> <ul> <li>soit \\(C\\) n\u2019emprunte pas le sommet \\(k\\) ; </li> <li>soit \\(C\\) emprunte exactement une fois le sommet \\(k\\) (car les circuits sont de poids positifs ou nuls) et \\(C\\) est donc la concat\u00e9nation de deux chemins, \\(C_{i,k}\\) entre \\(i\\) et \\(k\\) et \\(C_{k,j}\\) entre \\(k\\) et \\(j\\) respectivement, dont les sommets interm\u00e9diaires sont dans \\(\\{1, 2, \\dots, k-1\\}\\). Par principe de sous-optimalit\u00e9, si \\(C\\) est optimal, \\(C_{i,k}\\), \\(C_{k,j}\\) aussi.</li> </ul> <p>Cela nous donne la relation de r\u00e9currence \\(\\color{red}{W_{i,j}^k = \\min(W_{i,j}^{k-1}, W_{i,k}^{k-1} + W_{k,j}^{k-1})}\\), pour tous \\(i, j\\) et \\(k\\) dans \\(\\{1, 2, \\dots, n\\}\\). Ainsi on r\u00e9sout les sous-probl\u00e8mes par valeur de \\(k\\) croissante.</p>"},{"location":"Graphes/2-PCC/#pseudo-code","title":"Pseudo-code","text":""},{"location":"Graphes/2-PCC/#1er","title":"1er","text":"<p>Inconv\u00e9nients : on cr\u00e9e une matrice \u00e0 chaque it\u00e9ration. Co\u00fbteux en m\u00e9moire.</p> <pre><code>fonction FloydWarshall(G)\n    entree: un graphe orient\u00e9 pond\u00e9r\u00e9 G\n    sortie: la matrice des plus courts chemins W^n\n    W\u2070 \u27f5 matrice n*n d'adjacence pond\u00e9r\u00e9e\n    pour k allant de 1 \u00e0 n faire\n        cr\u00e9er une matrice W^k\n        pour i allant de 1 \u00e0 n faire\n            pour j allant de 1 \u00e0 n faire\n                W^k_{i,j} \u27f5 min(W^{k-1}_{i,j}, W^{k-1}_{i,k} + W^{k-1}{k,j})\n\n    renvoyer W^n\n</code></pre>"},{"location":"Graphes/2-PCC/#2nd","title":"2nd","text":"<p>Avantage : il n'y a plus qu'une matrice modifi\u00e9e \u00e0 chaque it\u00e9ration</p> <p>Complexit\u00e9 temporelle en \\(\\Theta(n^3)\\) (triple boucle toujours parcourue)</p> <p>Complexit\u00e9 en m\u00e9moire de l'ordre du nombre de coefficients, donc \\(\\Theta(n^2)\\)</p> <pre><code>fonction FloydWarshall(G)\n    entree: un graphe orient\u00e9 pond\u00e9r\u00e9 G\n    sortie: la matrice des plus courts chemins W^n\n    W &lt;- matrice n*n d'adjacence pond\u00e9r\u00e9e\n    pour k allant de 1 \u00e0 n faire\n        pour i allant de 1 \u00e0 n faire\n            pour j allant de 1 \u00e0 n faire\n                W_{i,j} \u27f5 min(W_{i,j}, W_{i,k} + W_{k,j})\n\n    renvoyer W\n</code></pre> Exemple <p>Graphe : <pre><code>graph LR\nA(1) -- -2 --&gt; C(3)\nB(2) -- 4 --&gt; A\nB -- 3 --&gt; C\nC -- 2 --&gt; D\nD -- -1 --&gt; B</code></pre></p> <p>Initialisation :</p> \\[\\begin{pmatrix} 0 &amp; +\\infty &amp; -2 &amp; +\\infty \\\\ 4 &amp; 0 &amp; 3 &amp; +\\infty \\\\ +\\infty &amp; +\\infty &amp; 0 &amp; 2 \\\\ +\\infty &amp; -1 &amp; +\\infty &amp; 0 \\end{pmatrix}\\] <p>Chemins :</p> \\[\\begin{pmatrix} 13 &amp; \\\\ 21 &amp; 23\\\\ 34 &amp; \\\\ 42 &amp; \\\\ \\end{pmatrix}\\] <p>Pas de circuit de poids n\u00e9gatif. On ne fera pas mieux que \\(0\\) pour aller de \\(x\\) \u00e0 \\(x\\).</p> <p>Sommets interm\u00e9diaires dans \\(\\{1\\}\\):</p> \\[\\begin{pmatrix} 0 &amp; +\\infty &amp; -2 &amp; +\\infty \\\\ 4 &amp; 0 &amp; min(\\textbf{3}, \\textbf{4}, \\textbf{-2}) &amp; +\\infty \\\\ +\\infty &amp; +\\infty &amp; 0 &amp; 2 \\\\ +\\infty &amp; -1 &amp; +\\infty &amp; 0 \\end{pmatrix}\\] <p>Chemins :</p> \\[\\begin{pmatrix} 13 &amp; \\\\ 21 &amp; \\textbf{213}\\\\ 34 &amp; \\\\ 42 &amp; \\\\ \\end{pmatrix}\\] <p>Sommets interm\u00e9diaires dans \\(\\{1; 2\\}\\):</p> \\[\\begin{pmatrix} 0 &amp; +\\infty &amp; -2 &amp; +\\infty \\\\ 4 &amp; 0 &amp; 2 &amp; +\\infty \\\\ +\\infty &amp; +\\infty &amp; 0 &amp; 2 \\\\ min(+\\infty, \\textbf{-1+4}) &amp; -1 &amp; min(+\\infty, \\textbf{-1+2}) &amp; 0 \\end{pmatrix}\\] <p>Chemins :</p> \\[\\begin{pmatrix} 13 &amp; \\\\ 21 &amp; 213\\\\ 34 &amp; \\\\ 42 &amp; \\textbf{421} &amp; \\textbf{4213} \\\\ \\end{pmatrix}\\] <p>Sommets interm\u00e9diaires dans \\(\\{1; 2; 3\\}\\):</p> \\[\\begin{pmatrix} 0 &amp; +\\infty &amp; -2 &amp; min(+\\infty, \\textbf{-2+2}) \\\\ 4 &amp; 0 &amp; 2 &amp; min(+\\infty, \\textbf{2+2}) \\\\ +\\infty &amp; +\\infty &amp; 0 &amp; 2 \\\\ 3 &amp; -1 &amp; 1 &amp; 0\\\\ \\end{pmatrix}\\] <p>Chemins : </p> \\[\\begin{pmatrix} 13 &amp; \\textbf{134} &amp; \\\\ 21 &amp; 213 &amp; \\textbf{2134}\\\\ 34 &amp; &amp; \\\\ 42 &amp; 421 &amp; 4213 \\\\ \\end{pmatrix}\\] <p>Sommets interm\u00e9diaires dans \\(\\{1; 2; 3; 4\\}\\):</p> \\[\\begin{pmatrix} 0 &amp; min(+\\infty, \\textbf{0-1}) &amp; -2 &amp; 0 \\\\ 4 &amp; 0 &amp; 2 &amp; 4 \\\\ min(+\\infty, \\textbf{3+2}) &amp; min(\\infty, \\textbf{-1+2}) &amp; 0 &amp; 2 \\\\ 3 &amp; -1 &amp; 1 &amp; 0\\\\ \\end{pmatrix}\\] <p>Chemins :</p> \\[\\begin{pmatrix} 13 &amp; 134 &amp; \\textbf{1342}\\\\ 21 &amp; 213 &amp; 2134\\\\ 34 &amp; \\textbf{342} &amp; \\textbf{3421} \\\\ 42 &amp; 421 &amp; 4213 \\\\ \\end{pmatrix}\\] <p>\\(k = 4\\) : On s'arr\u00eate l\u00e0</p>"},{"location":"Graphes/2-PCC/#floyd-warshall-fermeture-transitive","title":"Floyd-Warshall : Fermeture transitive","text":"<p>Le probl\u00e8me de la fermeture transitive dans un graphe non pond\u00e9r\u00e9 \\(G =(V,E)\\) consiste \u00e0 d\u00e9terminer si deux sommets \\(a\\) et \\(b\\) peuvent \u00eatre reli\u00e9s par un chemin allant de \\(a\\) \u00e0 \\(b\\).</p> <p>Pour cela, on utilise la matrice d'adjacence boul\u00e9enne \\(W\\) dans laquelle \\(W_{i,j}\\) vaut \\(\\textbf{true}\\) si il existe un chemin allant de \\(i\\) \u00e0 \\(j\\) et \\(\\textbf{false}\\) sinon.</p> <p>La relation de r\u00e9currence devient :</p> \\[W_{i,j}^k \\leftarrow W_{i,j}^{k-1} \\lor (W_{i,k}^{k-1} \\land W_{k,j}^{k-1})\\] <p>On ne cherche pas la longueur d'un chemin mais seulement s'il en existe un.</p> <p>Correction de Floyd-Warshall lorsque G ne contient pas de cycle de poids strictement n\u00e9gatif</p> <p>Invariant : \\(W^k_{i,j}\\) est \u00e9gal au poids d'un chemin minimal reliant \\(v_i\\) \u00e0 \\(v_j\\) et ne passant que par des sommets interm\u00e9diaires de la liste \\(v_1, \\dots, v_k\\).</p> <p>Cas de base : Vrai si \\(k = 0\\) car \\(W^k_{i,j}\\) est le poids du chemin minimal qui relie \\(v_i\\) \u00e0 \\(v_j\\) sans passer par aucun sommet interm\u00e9diaire. OK</p> <p>Si \\(k &lt; n\\), on suppose l\u2019invariant r\u00e9alis\u00e9 et on consid\u00e8re \\(C = v_i \\rightsquigarrow v_j\\)  un \\(PCC\\) ne passant que par les sommets interm\u00e9diaire \\(v_1, \\dots, v_{k+1}\\). </p> <ul> <li>Si \\(C\\) ne passe pas par \\(v_{k+1}\\), alors, par HR, son poids est \\(W^{k+1}_{i,j} = W^k_{i,j}\\). </li> <li>S\u2019il passe par \\(v_{k+1}\\), alors il n\u2019y passe qu\u2019une fois (pas de circuit de poids n\u00e9gatif). Il se d\u00e9compose en \\(C_1 = v_i \\rightsquigarrow v_{k+1}\\) et \\(C_2 = v_{k+1} \\rightsquigarrow v_j\\) qui sont des chemins ne passant que par des sommets dans \\(v_1, \\dots, v_{k}\\) . Par principe d\u2019optimalit\u00e9, ces chemins sont les meilleurs ne passant que par \\(v_1, \\dots, v_{k}, v_{k+1}\\). Donc, par HR, leurs poids sont \\(W^k_{i,k+1}\\) et \\(W^k_{k+1,j}\\). Le poids de \\(C\\) est donc \\(W^k_{i,k+1} + W^k_{k+1,j}\\).</li> <li>Finalement, \\(min(w^k_{i,j}, W^k_{i,k+1} + W^k_{j+1,j})\\) est le poids minimal d'un chemin reliant \\(v_i\\) \u00e0 \\(v_j\\) et ne passant que par les sommets interm\u00e9diaire \\(v_1, \\dots, v_{k+1}\\). </li> </ul> <p>Si \\(k=n\\), \\(W\\) contient les longueurs de tous les \\(PCC\\). </p>"},{"location":"Graphes/2-PCC/#algorithme-de-dijkstra","title":"Algorithme de Dijkstra","text":""},{"location":"Graphes/2-PCC/#presentation_1","title":"Pr\u00e9sentation","text":"<p>Calcule, dans un graphe orient\u00e9 pond\u00e9r\u00e9 par des r\u00e9els positifs, les plus courts chemins \u00e0 partir d'une source unique en direction de tous les autres sommets.</p> <p>D\u00fb \u00e0 l'informaticien n\u00e9erlandais Edsger Dijkstra (par ailleurs prix Turing), publi\u00e9 en 1959.</p> <p>Comme les arcs sont de poids positifs, on peut supprimer les boucles : passer par une boucle ne raccourcira jamais un chemin. Dans la suite, nos graphes sont sans boucle.</p>"},{"location":"Graphes/2-PCC/#necessite-de-la-valuation-positive","title":"N\u00e9cessit\u00e9 de la valuation positive","text":"<p>On serait tent\u00e9, si un graphe poss\u00e8de des valuations positives, d\u2019ajouter une m\u00eame constante \u00e0 chaque valuation pour les rendre toutes positives afin d\u2019appliquer l\u2019algorithme de Dijkstra.</p> <p>Malheureusement cette approche permet certes de trouver les \\(PCC\\) dans le nouveau graphe mais le chemin suivi peut tr\u00e8s bien ne pas \u00eatre le meilleur dans l\u2019ancien.</p> <p>Consid\u00e9rons  <pre><code>graph LR\nA(x) --2--&gt; B(y)\nB -- -4 --&gt; C(z)\nA -- 1 --&gt; C</code></pre> Le \\(PCC\\) de \\(x\\) \u00e0 \\(z\\) passe par \\(y\\).</p> <p>Ajoutons 4 \u00e0 toutes les valuations <pre><code>graph LR\nA(x) --6--&gt; B(y)\nB -- 0 --&gt; C(z)\nA -- 5 --&gt; C</code></pre> Le \\(PCC\\) de \\(x\\) \u00e0 \\(z\\) passe par l'arc \\(\\{x,z\\}\\).</p>"},{"location":"Graphes/2-PCC/#principe","title":"Principe","text":"<p>\\(G\\) a pour ensemble de sommets \\([\\![ 1, n ]\\!]\\)</p> <p>On cherche les \\(PCC\\) depuis la source (ou entr\u00e9e) \\(e\\) vers tous les autres sommets.</p> <p>Principe :</p> <ul> <li>A chaque tour, on choisit parmi tous les sommets verts celui dont la distance \u00e0 l'enr\u00e9e est la plus petite(le plus court chemin). Ce sommet devient rouge.</li> <li>Tout voisin bleu du sommet choisi est ajout\u00e9 \u00e0 l'ensemble des sommets verts (en ce sens c'est un parcours en largeur). Les informations concernant les distances \u00e0 la source des voisins du sommet qui vient de devenir rouge sont mises \u00e0 jour.</li> </ul> <p>C'est un algorithme glouton dont le r\u00e9sultat est optimal. Nous avons vu qu'il existe des algos gloutons non optimaux(par exemple pour la coloration).</p> <p>L'ensemble des sommets verts est not\u00e9 \\(F\\) car il est souvent impl\u00e9ment\u00e9 avec un file de priorit\u00e9. Graphe \\(G = (S,A)\\)</p> <pre><code>F := {e} /*sommets en cours de traitement (=verts)*/\nE := \u2205 /*sommets trait\u00e9s = sommets rouges*/\nD := tableau des distances minimales (d_e = 0, k \u2260 e \u21d2 d_k = +\u221e)\ntant que F \u2260 \u2205 faire\n    choisir k \u2208 F avec d_k minimal\n    F := F \\ {k}\n    E := E \u222a {k} /*k devient rouge*/\n    pour tout voisin v de k non rouge faire\n        si v \u2209 F /*si v est bleu*/\n            F := F \u222a {v} /*v devient vert*/\n        fin si\n        si d_k + w(k \u27f6 v) &lt; d_v\n            /*passer par k pour atteindre v est plus rentable*/\n            d_v := d_k + w(k \u27f6 v) /*maj tab. des distances*/\n        fin si\n    fin faire\nfin faire\n</code></pre>"},{"location":"Graphes/2-PCC/#variant","title":"Variant","text":"<p>Pour un graphe \\(G (S, A)\\), on note \\(B=S \\setminus (F \\cup E)\\) l'ensemble des sommets bleus.</p> <ul> <li>Variant : \\(|F| + |B|\\) (cardinal de l'ensemble de sommets verts ou bleus). Quantit\u00e9 enti\u00e8re positive.</li> <li> <p>C'est une quantit\u00e9 d\u00e9croissante strictement \u00e0 la fin de chaque tour de boucle car :</p> <ul> <li>on retire toujours un sommet de \\(F\\) (si ce n'est pas possible, \\(F=\\emptyset\\) et l'algorithme s'arr\u00eate).</li> <li>tout sommet ajout\u00e9 \u00e0 \\(F\\) est retir\u00e9 de \\(B\\).</li> <li>ainsi, l'ensemble de  s sommets verts ou bleus comporte un \u00e9l\u00e9ment de moins \u00e0 la fin d'un tour par rapport au tour pr\u00e9c\u00e9dent.</li> </ul> </li> </ul> <p>Exemple</p> <p>On g\u00e8re en plus un tableau \\(P\\) (pr\u00e9d\u00e9cesseur) qui garde en m\u00e9moire la derni\u00e8re \u00e9tape sur le chemin de la source au sommet consid\u00e9r\u00e9.</p> <p><p></p></p> \\[  \\begin{array}{c|c|c|c} \\text{F} &amp; \\text{E} &amp; \\text{T} &amp; \\text{P} \\\\ \\hline \\{1\\} &amp; \\emptyset &amp; [\\![0; \\infty; \\infty; \\infty ; \\infty ]\\!] &amp; [\\![ 1,-1,-1,-1,-1]\\!] \\\\ \\{2; 5\\} &amp; \\{1\\} &amp; [\\![0; 12; \\infty; \\infty ; 5 ]\\!] &amp; [\\![ 1,1,-1,-1,1]\\!] \\\\ \\{2;3;4\\} &amp; \\{1;5\\} &amp; [\\![0; 6; 9; 7 ; 5 ]\\!] &amp; [\\![ 1,5,5,5,1]\\!] \\\\ \\{3;4\\} &amp; \\{1;5;2\\} &amp; [\\![0; 6; 8; 7 ; 5 ]\\!] &amp; [\\![ 1,5,2,5,1]\\!] \\\\ \\{3\\} &amp; \\{1;5;2;4\\} &amp; [\\![0; 6; 8; 7 ; 5 ]\\!] &amp; [\\![ 1,5,2,5,1]\\!] \\\\ \\emptyset &amp; \\{1;5;2;4;3\\} &amp; [\\![0; 6; 8; 7 ; 5 ]\\!] &amp; [\\![ 1,5,2,5,1]\\!] \\\\ \\end{array} \\] <p>\\(PCC\\) pour aller de 1 \u00e0 3 :</p> <ul> <li>On a \\(T = [\\![0; 6; 8; 7 ; 5 ]\\!]\\) et \\(P = [\\![ 1,5,2,5,1]\\!]\\).</li> <li>pr\u00e9decesseur de \\(3\\) : \\(P[3] = 2\\).</li> <li>pr\u00e9decesseur de \\(2\\) : \\(P[2] = 5\\).</li> <li>pr\u00e9decesseur de \\(5\\) : \\(P[5] = 1\\).</li> <li>Donc \\(1523\\) avec un co\u00fbt de \\(8\\).</li> </ul>"},{"location":"Graphes/2-PCC/#correction","title":"Correction","text":"<p>Pour un graphe \\(G\\) d'ensemble de sommets \\(S\\), notons \\(D\\) le tableau des distances et \\(\\delta(e,u)\\) la longueur d'un \\(PCC\\) de \\(e\\) \u00e0 \\(u\\), \\(w(a, b)\\) le poids de l'arc \\(a \\rightarrow b\\).</p> <p>Th\u00e9or\u00e8me</p> <p>A la fin de l'Algorithme de Dijkstra, on a \\(d_u = \\delta(e, u)\\) pour tout sommet \\(u \\in S\\).</p> <p>Notations</p> <p>On note \\(F^k; E^k, d_u^k\\) les valeurs de \\(F, E, d_u\\) \u00e0 la fin de l'it\u00e9ration \\(k\\).</p> <p>\\(F^k\\) est l'ensemble des sommets verts \u00e0 la fin de l'it\u00e9ration \\(k\\), \\(E^k\\) l'ensemble des sommets rouges et \\(S \\setminus (F^k \\cup E^k)\\) l'ensemble des sommets bleus.</p> <p>Un sommet \\(u\\) est bleu \u00e0 la fin de l'\u00e9tape \\(k\\) si et seulement si \\(d_u = +\\infty\\) si et seulement si \\(u\\) n'est voisin d'aucun sommet rouge \u00e0 la fin de l'\u00e9tape \\(k\\).</p> <p>Pour tout sommet \\(u \\in S\\), \\(d_u &lt; +\\infty\\) documente un chemin de \\(e\\) \u00e0 \\(u\\) n'empruntant que des sommets verts ou rouges.</p> <p>Rappel</p> <p>A la fin du parcours, les sommets accessibles depuis \\(e\\) sont dans \\(E\\)</p> <p>Invariant de boucle :</p> <ol> <li>Sommets rouges : \\(\\forall u \\in E^k, d_u^k = \\delta(e, u)\\) (point 1)</li> <li>Sommet \\(v\\) vert ou bleu diff\u00e9rents de \\(e\\) : \\(d_v^k = min(\\{d_u^k + w(u, v) | u \\in E^k\\})\\) ce qui revient par le point 1 \u00e0 \\(d_v^k = min(\\{\\delta(e, u) + w(u, v) | u \\in E^k\\})\\) (point 2)</li> </ol> <p>Remarque</p> <p>La distance \\(d^k_v\\) est donc le poids minimal d'un chemin vert-rouge de \\(e\\) \u00e0 \\(v\\) dont l'avant dernier sommet est rouge.</p> <p>Pour un sommet bleu \\(v\\) \u00e0 l'\u00e9tape k, les \\(w(u, v)\\) pour \\(u\\) rouge \u00e9tant infinis(car \\(v\\) n'est pas voisin d'un rouge), on retrouve que \\(d_v^k = +\\infty\\).</p> <p>Cas de base :</p> <ul> <li> <p>Au tour 0 (avant la boucle) :</p> <ul> <li>L'ensemble des sommets rouge est vide, donc pour un sommet \\(v \\neq e\\) le minimum des sommes \\(\\delta(u,v) + w(u,v)\\) pour les u rouges est infini. Or \\(d_v^0 = +\\infty\\) : Point 2 OK.</li> <li>Le point 1 est vrai car il n'y a pas de sommet rouge.</li> </ul> </li> <li> <p>A la fin du 1er tour de boucle \\(e\\) est rouge, \\(d_e^1 = 0 = \\delta(e, e)\\) (Point 1 OK) et \\(d_v^1 = w(e,v)\\) pour tout \\(v \\neq e\\) donc \\(d_v^1 = min(\\{\\delta(e, u) + w(e,v) | u \\in E^1\\})\\) (Point 2 OK) puisque seul \\(e\\) est rouge.</p> </li> </ul> <p>H\u00e9r\u00e9dit\u00e9 (pour le point 1) :</p> <p>Soit \\(u\\) un sommet rouge \u00e0 la fin de l'\u00e9tape \\(k+1(k \\geq 1)\\).</p> <ul> <li>On a \\(d_u^{k+1} = d_u^k\\) (pas de changement dans le tableau des distances).</li> <li>Comme \\(u\\) est rouge, il est accessible, donc \\(d_u^{k+1}\\) est fini, donc le chemin qui le document n'emprunte que des sommets verts ou rouges.</li> <li>Si \\(u \\notin E^{k+1}\\setminus E^k\\), c'est \u00e0 dire si \\(u\\) n'est pas le sommet qu'on vient de rendre rouge, alors \\(u in E^k\\) et par HR \\(d_u^k = \\delta(e, u)\\) (Point 1 OK).</li> <li> <p>Si \\(u\\) entre dans \\(E^{k+1}\\) alors au d\u00e9but du passage \\(k+1\\), \\(u\\) est vert (\\(u \\in F^k\\)) et \\(d_u^k \\leq d_s^k\\) pour tout sommet vert \\(s\\) (car \\(u\\) est choisi).</p> <ul> <li>Soit \\(\\color{red}{e \\rightsquigarrow \\textit{u} \\text{ un } PCC \\text{ et } \\textit{v} \\text{ son premier sommet non rouge}}\\) (\\(u=v\\) possible). Les sous chemins \\(e \\rightsquigarrow v\\) et \\(v \\rightsquigarrow u\\) sont des \\(PCC\\) par principe d'optimalit\u00e9. Comme les poids des arcs sont positifs (condition Dijkstra), il vient que \\(\\color{red}{\\delta(e, u) \\geq \\delta(e, v)}\\).</li> <li>\\(\\color{red}{\\text{Le pr\u00e9d\u00e9cesseur } \\textit{r} \\text{ de } \\textit{v} \\text{ dans } e \\rightsquigarrow v \\text{ est rouge et diff\u00e9rent de u}}\\) \\(\\color{red}{\\text{ donc } d_r^k = \\delta(e, r) \\text{par HR.}}\\)</li> <li>\\(\\color{red}{\\text{Comme } \\textit{v} \\text{ n'est pas rouge, il v\u00e9rifie le point 2}}\\) donc </li> </ul> \\[ \\begin{align}\\nonumber     d_v^k &amp; \\space\\space\\space\\space\\space\\space = \\space\\space\\space\\space min(\\{\\delta(e,x) + w(x,v) | x \\in E^k\\})\\text{ par HR.(2)}\\\\ \\nonumber     &amp;\\underbrace{=}_{e\\rightsquigarrow r \\rightarrow v \\text{ PCC}} \\delta(e, r) + w(r, v) = \\delta(e,v)\\\\ \\end{align} \\\\ \\color{red}\\text{Ainsi } d^k_v = \\delta(e,v) \\] <ul> <li>\\(\\color{red}{\\text{On a } \\delta(e,u) \\geq \\delta(e,v)}\\). Et \\(d^k_v \\geq d^k_u\\) car \\(u\\) est choisi. Or, \\(d_u^k\\) est le poids d'un chemin de \\(e\\) \u00e0 \\(u\\) donc plus grand que \\(\\delta(e,u)\\) alors</li> </ul> \\[     \\delta(e,u) \\geq \\delta(e,v) = d^k_v \\geq d^k_u \\geq \\delta(e,u) \\textbf{ Point 1 OK} \\] </li> </ul> <p>H\u00e9r\u00e9dit\u00e9 (pour le point 2) :</p> <p>Soit \\(v\\) un sommet vert ou bleu \u00e0 la fin de l'\u00e9tape \\(k+1\\) \\(\\color{red}{\\text{non voisin}}\\) de l'\u00e9l\u00e9ment \\(u\\) qui entre dans \\(E^{k+1}\\).</p> <ul> <li>Alors \\(d_v^k = d^{k+1}_v\\) car \\(d^k_u + w(u,v) = +\\infty\\)</li> <li> <p>On a :</p> \\[ \\begin{align}     D^{k+1}_v &amp;= d^k_v&amp; \\\\ \\nonumber     &amp;= min(\\{\\delta(e, x) + w(x, v) | x \\in \\underbrace{E^{k+1}}_{E^{k+1}\\backslash\\{u\\}}\\})&amp;\\\\ \\nonumber     &amp;= min(\\{\\delta(x,k) + w(x, v) | x \\in E^k\\}\\cup\\{\\underbrace{\\delta(e,u)+w(u,v)}_{=+\\infty}\\}) &amp;\\\\ \\nonumber     &amp;= min(\\{\\delta(e,x) + w(x, v) | x \\in E^{k+1}\\})\\color{red}{\\text{ : Point 2 OK}} \\nonumber \\end{align} \\] </li> </ul> <p>Soit \\(v\\) vert ou bleu \u00e0 la fin de l'\u00e9tape \\(k+1\\) et \\(\\color{red}{\\text{voisin}}\\) de l'\u00e9l\u00e9ment rouge \\(u\\) entrant dans \\(E^{k+1}\\).</p> <ul> <li> <p>Le sommet \\(v\\) est vert ou bleu \u00e0 l'\u00e9tape \\(k\\) mais vert \u00e0 l'\u00e9tape \\(k+1\\).</p> <ul> <li>\\(d_v^k = min(\\{\\delta(e, x) + w(x, v) | x \\in E^k\\})\\) par HR.2</li> <li>\\(d_v^{k+1} = min(d^k_v, \\underbrace{d_u^k}_{=\\delta(e,u)\\text{ par HR.1}} + w(u,v))\\) par algo Dijkstra</li> </ul> </li> <li> <p>On a donc encore</p> \\[     d^{k+1}_v = min(\\{\\delta(e, x) + w(x, v) | x \\in \\underbrace{E^{k+1}}_{E^k\\cup\\{u\\}}\\}) \\textbf{ Point 2 OK }\\text{dans ce cas} \\] </li> </ul>"},{"location":"Graphes/2-PCC/#complexite-pour-une-source-e","title":"Complexit\u00e9 pour une source e","text":""},{"location":"Graphes/2-PCC/#force-brute-pour-un-graphe-de-n-sommets-et-p-arcs","title":"Force brute pour un graphe de n sommets et p arcs","text":"<pre><code>F := {e}; E := \u2205; D := tableau des distances minimales;\ntant que F non vide faire\n    Choisir k dans F avec d_k minimal /*explorer D en O(n)*/\n    F := F\\{k}; E := E\u222a{k}; /*MAJ en O(1) si E,F tableaux*/\n    pour tout voisin r de k non rouge faire\n        si r \u2209 F faire /* cas r bleu*/\n            F := F\u222a{r}; /*O(1)*/\n        si d_k + w(k \u27f6 r) &lt; d_r faire\n            d_r := d_k + w(k \u27f6 r); /*maj tableau des distances en O(1)*/\n</code></pre> <p>Au plus \\(n\\) transferts de \\(F\\) vers \\(E\\) (ligne L4). Pour chacun recherche (ligne L3) du plus petit \u00e9l\u00e9ment vert dans le tableau des distances : \\(O(n)\\)</p> <p>(L5 \u00e0 L9) Co\u00fbt des v\u00e9rifications et mises \u00e0 jour pour un sommet \\(k\\) : \\(O (deg^{+} k )\\). Au total, complexit\u00e9 en multiple de : \\(n + \\sum_{k = 0}^{n-1} (n + deg^{+} k) = n + n^2 + p = O(n^2)\\text{ (Rappel : }p = O(n\u00b2))\\)</p>"},{"location":"Graphes/2-PCC/#avec-file-de-priorite-pour-un-graphe-de-n-sommets-et-p-arcs","title":"Avec file de priorit\u00e9 pour un graphe de n sommets et p arcs","text":"<p>Puisqu\u2019on g\u00e8re un ensemble \\(F\\) des sommets verts et un tableau \\(D\\) des distances \u00e0 la source, on peut les fusionner en une seule file de priorit\u00e9 \\(T\\) d\u2019\u00e9l\u00e9ments \\((s ,d (e,s ))\\).</p> <p>On implante les files de priorit\u00e9 comme des tas. On consid\u00e8re donc un tas-min (fils plus grands que p\u00e8re). Cr\u00e9ation par descente en \\(O (n)\\). On g\u00e8re en interne \\(\\color{red}{\\text{un tableau des positions dans le tas}}\\) pour obtenir en \\(O (1)\\) la position d'un sommet dans \\(T\\) en vue d'une MAJ.</p> <pre><code>E := \u2205; /*sommets rouges*/\nT := tas-min des couples (sommet, distance depuis e); /*O(n)*/\ntant que T \u2260 \u2205 :\n    retirer le sommet (k, d(e,k)) du tas T /*O(ln n)*/\n    E := E\u222a{k};\n    pour tout voisin r de k non trait\u00e9 :\n        /*nb passages : deg^+ k*/\n        si d(e,k)+w(k \u27f6 r) &lt; d(e,r): /*O(1)*/\n            MAJ T avec d(e,r) := d(e,k)+w(k \u27f6 r) /*O(ln n)*/\n</code></pre> <ul> <li>Complexit\u00e9 de chaque acc\u00e8s/maj dans la file major\u00e9 en \\(O (\\log n)\\). La file de priorit\u00e9 contient au plus \\(n\\) \u00e9l\u00e9ments.</li> <li>Par passage dans la boucle <code>while</code> : choix puis suppression du sommet \\(k\\) le plus prioritaire : \\(O(\\log n)\\). Pour ses \\(deg^{+} k\\) voisins, au plus \\(deg^{+} k\\) maj de cl\u00e9s. Donc co\u00fbt pour \\(k\\) en \\(O((1+deg^{+}k)\\log n)\\). Co\u00fbt total </li> </ul> \\[ \\underbrace{n}_{\\text{cr\u00e9ation du tas}} + \\sum_{e=0}^{n-1} (deg^{+} k + 1) \\log n = \\newline n + n \\log n + \\log n \\sum_{e=0}^{n-1} (deg^{+} k) \\leq n \\log n + p \\log n \\] <ul> <li>Complexit\u00e9 en \\(O((n + p) \\log n)\\)</li> <li>Si \\(p \\log n = O(n^2)\\), c'est \u00e0 dire si \\(p = O(\\frac{n^2}{\\log n})\\), la complexit\u00e9 avec file de priorit\u00e9s est au moins aussi bonne qu'en force brute.</li> <li>Si le graphe est creux (peu d'ar\u00eates), \\(p=O(n)\\), et donc la complexit\u00e9 avec file de priorit\u00e9 est \\(O(n \\log n)\\).</li> <li>Mais si le graphe est dense (par exemple complet) il y a un nombre d'arc ou d'ar\u00eates en \\(p=O(n^2)\\), et donc la complexit\u00e9 avec file de priorit\u00e9 est \\(O(n^2 \\log n)\\). Dans ce cas, l'impl\u00e9mentation par file de priorit\u00e9 n'est pas int\u00e9ressante.</li> </ul>"},{"location":"Linux/1-Linux/","title":"Linux","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Avant-propos</p> <p>Ces transparents constituent une toute petite introduction forc\u00e9ment non  exhaustive au syst\u00e8me Linux. Ils sont pr\u00e9sent\u00e9s pour faciliter le quotidien  des \u00e9tudiants de MP2I dans l'\u00e9laboration de leurs programmes en cours  d'ann\u00e9e. On y donne notamment</p> <ul> <li>des pr\u00e9cisions sur les principaux r\u00e9pertoires sous Linux</li> <li>les commandes de survie dans le shell bash.  </li> </ul> <p>On n'y trouve pas d'explication sur ce qu'est un disque logique ni sur la notion d'inode. Un futur document traitera des droits et redirections.  </p> <p>Cr\u00e9dits</p> <ul> <li>Un historique de Linux </li> <li>Un cours sur Linux tr\u00e8s complet : Linux France (Lien indisponible) et un autre : Telecom Paris (Lien indisponible) </li> <li>Des pr\u00e9cisions sur l'architecture des fichiers sous Linux ici et la nomenclature des syst\u00e8mes de fichiers l\u00e0.  </li> <li>Un cours du MIT (Lien indisponible)</li> </ul>"},{"location":"Linux/1-Linux/#systeme-dexploitation","title":"Syst\u00e8me d'exploitation","text":""},{"location":"Linux/1-Linux/#presentation","title":"Pr\u00e9sentation","text":"<p>Syst\u00e8me d'exploitation</p> <p>Un syst\u00e8me d'exploitation (en anglais operating system (OS)) est un ensemble de programmes qui dirige l'utilisation des ressources d'un ordinateur par des logiciels applicatifs.</p> <p>L'OS fournit aux programmes utilisateurs un acc\u00e8s unifi\u00e9 aux ressources mat\u00e9rielles et logicielles (p\u00e9riph\u00e9riques, m\u00e9moire, autres  programmes). Il offre un ensemble de fonctions \"primitives\" permettant d'interagir avec le mat\u00e9riel.  </p> <p></p> <p>Figure \u2013 Le syst\u00e8me d'exploitation est un interm\u00e9diaire entre les logiciels d'application et le mat\u00e9riel (WIKIPEDIA).</p>"},{"location":"Linux/1-Linux/#composants-logiciels-dun-os","title":"Composants logiciels d'un OS","text":"<p>On trouve notamment :</p> <ul> <li>l'ordonnanceur : d\u00e9cide quel programme s'ex\u00e9cute \u00e0 un moment  donn\u00e9 sur le processeur ;  </li> <li>le gestionnaire de m\u00e9moire, qui r\u00e9partit la m\u00e9moire vive entre les  diff\u00e9rents programmes en cours d'ex\u00e9cution ;  </li> <li>les diff\u00e9rents syst\u00e8mes de fichiers qui d\u00e9finissent la mani\u00e8re de stocker  les fichiers sur les supports physiques (disque dur, cl\u00e9 USB, disque  optique etc.) ;</li> <li>la pile r\u00e9seau qui impl\u00e9mente des protocoles de communication  comme TCP/IP ;  </li> <li>les pilotes de p\u00e9riph\u00e9riques (driver) qui g\u00e8rent les p\u00e9riph\u00e9riques  mat\u00e9riels (souris, clavier, carte 3D etc.)  </li> </ul>"},{"location":"Linux/1-Linux/#standard-posix","title":"Standard POSIX","text":"<p>La palette des services offerts et la mani\u00e8re de s'en servir diff\u00e8rent  d'un syst\u00e8me d'exploitation \u00e0 l'autre.</p> <p>Le standard industriel POSIX du IEEE d\u00e9finit une suite d'appels  syst\u00e8mes standard. POSIX est largement inspir\u00e9 de UNIX.</p> <p>Un logiciel applicatif qui effectue des appels syst\u00e8me selon POSIX  pourra \u00eatre utilis\u00e9 sur tous les syst\u00e8mes d'exploitation conformes \u00e0 ce  standard.</p> <p>Tous les syst\u00e8mes de type LINUX sont compatibles POSIX de m\u00eame que Android, macOS, iOS mais pas Windows : alors que les premiers d\u00e9rivent de UNIX, Windows d\u00e9rive de MS-DOS dont la philosophie est diff\u00e9rente.</p>"},{"location":"Linux/1-Linux/#extension-des-noms-de-fichiers","title":"Extension des noms de fichiers","text":"<p>Dans les syst\u00e8mes POSIX, l'extension du nom de fichier (tous les  caract\u00e8res \u00e0 droite du \"\u00b7\" dans le nom du fichier) n'a pas de  signification particuli\u00e8re pour le syst\u00e8me.</p> <p>Mais elle est pratique pour l'utilisateur car il voit bien \u00e0 quel type de fichier il a \u00e0 faire.</p> <p>Un fichier ex\u00e9cutable n'a pas n\u00e9c\u00e9ssairement un nom se terminant par  .exe</p> <p>L'utilisation de l'extension pour d\u00e9terminer le type de fichier est une  caract\u00e9ristique de Windows  </p>"},{"location":"Linux/1-Linux/#presentation-de-linux","title":"Pr\u00e9sentation de Linux","text":""},{"location":"Linux/1-Linux/#historique-pi","title":"Historique (PI)","text":"<p>Linux ou GNU/Linux : famille de syst\u00e8mes d'exploitation open source de type Unix fond\u00e9 sur le noyau Linux, cr\u00e9\u00e9 en \\(1991\\) par Linus Torvalds.</p> <p>GNU : projet informatique cr\u00e9\u00e9 en janvier 1984 par Richard Stallman pour d\u00e9velopper le syst\u00e8me d'exploitation GNU. Chaque brique du projet est un logiciel libre utilisable en tant que tel mais dont l'objectif est de s'inscrire dans une logique coh\u00e9rente. GNU/Linux c'est donc le noyau Linux plus les composantes de GNU.</p> <p>Linux \u00e9quipe une faible part des ordinateurs PC mais beaucoup de  serveurs, t\u00e9l\u00e9phones portables, syst\u00e8mes embarqu\u00e9s ou encore  superordinateurs.</p> <p>Android : syst\u00e8me d'exploitation pour t\u00e9l\u00e9phones portables. Utilise le  noyau Linux mais pas GNU. Equipe 85 % des tablettes tactiles et  smartphones.  </p>"},{"location":"Linux/1-Linux/#logiciel-libre-pi","title":"Logiciel libre (PI)","text":"<p>Distributions Linux (Ubuntu, Debian, Linux Mint, CentOS ...) :  syst\u00e8mes d'exploitation libres.  </p> <p>Les 4 libert\u00e9s d'un logiciels libres telles que d\u00e9finies par la Free  Software Foundation. On peut :</p> <ul> <li>utiliser le logiciel sans restriction,</li> <li>\u00e9tudier le logiciel</li> <li>le modifier pour l'adapter \u00e0 ses besoins</li> <li>le redistribuer sous certaines conditions pr\u00e9cises</li> </ul> <p>Le non respect de ces r\u00e8gles peut conduire \u00e0 des condamnations.</p> <p>Certaines licences sont con\u00e7ues selon le principe du copyleft : une  \u0153uvre d\u00e9riv\u00e9e d'un logiciel sous copyleft doit \u00e0 son tour \u00eatre libre.</p> <p>Licence GNU GPL : logiciel libre + copyleft. Le noyau Linux utilise  cette licence.</p> <p>Un logiciel libre n'est pas n\u00e9cessairement gratuit, et inversement un logiciel gratuit n'est pas forc\u00e9ment libre.  </p>"},{"location":"Linux/1-Linux/#caracteristiques-pi","title":"Caract\u00e9ristiques (PI)","text":"<p>Linux est multi-t\u00e2ches : plusieurs processus peuvent s'ex\u00e9cuter  \"simultan\u00e9ment\".</p> <p>Linux est multi-utilisateur : Chaque personne utilisant le syst\u00e8me  dispose d'un compte, qui peut \u00eatre vu comme une certaine zone qui  lui est allou\u00e9e, accessible par un nom et un mot de passe. Un  m\u00e9canisme de droits un peu contraignant emp\u00eache un utilisateur  d'acc\u00e9der \u00e0 des donn\u00e9es dont il n'a pas les droits.</p> <p>Les droits peuvent \u00eatre modifi\u00e9s.</p> <p>Un utilisateur sp\u00e9cial a tous les droits le super-utilisateur ou  administrateur (super user en anglais).</p>"},{"location":"Linux/1-Linux/#utilisateur","title":"Utilisateur","text":"<p>Chaque utilisateur poss\u00e8de un identifiant de connexion (login). On lui  associe un mot de passe.</p> <p>L'ensemble des donn\u00e9es de l'utilisateur (identifiant, mot de passe et  autres m\u00e9tadonn\u00e9es), ainsi que ses fichiers personnels constituent le  compte de l'utilisateur.</p> <p>L'ensemble des interractions de l'utilisateur authentifi\u00e9 avec le  syst\u00e8me est appel\u00e9 une session. Quand l'utilisateur se d\u00e9connecte, on  dit qu'il ferme sa session.</p> <p>\u00c0 l'identifiant de connexion correspond un num\u00e9ro d'utilisateur  nomm\u00e9 UID (User IDentifier). L'OS n'utilise que l'UID, l'identifiant  n'est l\u00e0 que par soucis de convivialit\u00e9.</p> <p>Les utilisateurs peuvent \u00eatre r\u00e9unis en groupes. Ces derniers ont un  nom symbolique et un identifiant num\u00e9rique GID (Group IDentifier).</p> <p>Chaque utilisateur a un groupe principal et \u00e9ventuellement des  groupes secondaires. La commande id affiche les identifiants  num\u00e9riques et les groupes de l'utilisateur courant.</p> <pre><code>$ id\nuid=1000(ivan) gid=1000(ivan) groupes=1000(ivan),\n4(adm),24(cdrom),27( sudo ),30(dip),46(plugdev),  \n111(lxd),116(lpadmin),131(libvirtd),132(sambashare)\n</code></pre>"},{"location":"Linux/1-Linux/#noyau","title":"Noyau","text":"<p>Noyau</p> <p>Noyau de syst\u00e8me d'exploitation (ou noyau, ou kernel en anglais) :  partie fondamentale de certains syst\u00e8mes d'exploitation. G\u00e8re les  ressources de l'ordinateur et permet aux diff\u00e9rents composants (mat\u00e9riels et logiciels) de communiquer entre eux.</p> <p>Le noyau assure :  </p> <ul> <li>la communication entre les logiciels et le mat\u00e9riel</li> <li>la gestion des divers logiciels (t\u00e2ches) d'une machine (lancement des programmes, ordonnancement...)</li> <li>la gestion du mat\u00e9riel (m\u00e9moire, processeur, p\u00e9riph\u00e9rique, stockage...).  </li> </ul> <p>Le noyau offre ses fonctions (l'acc\u00e8s aux ressources qu'il g\u00e8re) au travers des appels syst\u00e8me. Il transmet ou interpr\u00e8te les informations du mat\u00e9riel via des interruptions (appell\u00e9es les entr\u00e9es/sorties).  </p>"},{"location":"Linux/1-Linux/#processus","title":"Processus \u2665","text":"<p>Processus : programme en cours d'ex\u00e9cution par un ordinateur.</p> <p>R\u00e9guli\u00e8rement, il a besoin d'acc\u00e9der \u00e0 des ressources prot\u00e9g\u00e9es (comme  une \u00e9criture en m\u00e9moire). Le noyau prend alors le relai du processus pour rendre le service demand\u00e9 et lui rend le contr\u00f4le lorsque les actions voulues ont \u00e9t\u00e9 r\u00e9alis\u00e9es.  </p>"},{"location":"Linux/1-Linux/#systeme-de-fichier","title":"Syst\u00e8me de fichier","text":""},{"location":"Linux/1-Linux/#vue-logique","title":"Vue logique","text":"<p>Syst\u00e8me de fichier \u2665</p> <p>Syst\u00e8me de fichier : ensemble de conventions et structures permettant de stocker des donn\u00e9es sur un support physique</p> <p>Chaque syst\u00e8me de fichier impl\u00e9mente (\u00e0 sa fa\u00e7on) les primitives de manipulation de fichiers g\u00e9n\u00e9riques offertes par le syst\u00e8me d'exploitation :</p> <ul> <li>Cr\u00e9ation d'un fichier de nom donn\u00e9 ;</li> <li>Ouverture d'un fichier en lecture ou \u00e9criture ;</li> <li>Lecture ou \u00e9criture de portion d'un fichier ;</li> <li>Suppression d'un fichier ;</li> <li>Copie ou renommage d'un fichier.  </li> </ul>"},{"location":"Linux/1-Linux/#systemes-de-fichier","title":"Syst\u00e8mes de fichier","text":"<p>Chaque syst\u00e8me de fichier poss\u00e8de ses propres caract\u00e9ristiques et  objectifs. Certains (Samba ou NFS) sont par exemple destin\u00e9s \u00e0  exposer \u00e0 l'utilisateur des fichiers et r\u00e9pertoires se trouvant  physiquement sur une/des machine(s) distante(s).</p> <p>Quelques exemples : </p> OS Syst\u00e8me de fichier MSDOS FAT Windows 95/98 FAT32 (\\(F\\)ile \\(A\\)llocation \\(T\\)able \\(32\\) bits) Windows NT NTFS (\\(N\\)ew \\(T\\)echnology \\(F\\)ile \\(S\\)ystem) MAC OS HFS+ (\\(H\\)igh Performance \\(F\\)ile \\(S\\)ystem) Linux ext4 (\\(Ext\\)ended File System)"},{"location":"Linux/1-Linux/#systeme-de-fichier_1","title":"Syst\u00e8me de fichier","text":"<p>Fichier</p> <p>Fichier : suite d'octets constituant un ensemble coh\u00e9rent (en principe)  d'information. Sous Linux, tout est fichier (m\u00eame le clavier est consid\u00e9r\u00e9 comme un fichier).</p> <p>R\u00e8gles de nommage Linux : \\(255\\) caract\u00e8res au plus, principalement des lettres et des chiffres mais . -  \u02dc + % sont aussi autoris\u00e9s. </p> <p>Les espaces ne sont pas interdits, mais je les d\u00e9conseille de m\u00eame que les accents.</p>"},{"location":"Linux/1-Linux/#repertoires-ou-dossiers","title":"R\u00e9pertoires ou dossiers","text":"<p>Si le syst\u00e8me de fichier \u00e9tait une commode, les r\u00e9pertoires seraient  des tiroirs contenant des fichiers ou des sous-tiroirs.  </p> <p>R\u00e9pertoire \u2665</p> <p>Un r\u00e9pertoire est un fichier dans lequel se trouve la liste de son \"contenu\" sous la forme (nom du fichier, num\u00e9ro d'inode)</p> <p>Dans un r\u00e9pertoire on trouve deux fichiers particuliers not\u00e9s \".\" (r\u00e9pertoire courant) et \"..\" (r\u00e9pertoire parent).</p> <p>Le syst\u00e8me de fichier est repr\u00e9sent\u00e9 par un arbre dont la racine est le r\u00e9pertoire root not\u00e9 \"/\".</p> <p>Pratique personnelle de nommage pour les r\u00e9pertoires et fichiers  persos : la premi\u00e8re lettre des noms de r\u00e9pertoires en majuscules, celle  des autres fichiers en minuscule : UnNomDeRepertoire, unNomDeFichier.  </p>"},{"location":"Linux/1-Linux/#exemple-darborescence-de-fichiers","title":"Exemple d'arborescence de fichiers","text":"<p>Figure \u2013 Le syst\u00e8me de fichiers Linux (d'apr\u00e8s malekal)</p>"},{"location":"Linux/1-Linux/#exemple-personnel","title":"Exemple personnel","text":"<p>Figure \u2013 Une image de mon r\u00e9pertoire home donn\u00e9e par la commande tree</p> <p>L'option -d pour ne lister que les r\u00e9pertoires, l'option -L pour indiquer la profondeur de r\u00e9cursion.  </p>"},{"location":"Linux/1-Linux/#les-principaux-repertoires-systemes","title":"Les principaux r\u00e9pertoires syst\u00e8mes","text":""},{"location":"Linux/1-Linux/#principaux-repertoires","title":"Principaux r\u00e9pertoires","text":"<p>/ \u2665</p> <p>\\(\\color{blue}\\text{/}\\) C'est la racine de l'arborescence</p> <p>/bin \u2665</p> <p>\\(\\color{blue}\\text{/bin}\\) Stocke les ex\u00e9cutables et binaires essentiels lors du d\u00e9marrage Commandes utilisables ensuite par les utilisateurs (exemple ping)</p> <p>/sbin \u2665</p> <p>\\(\\color{blue}\\text{/sbin}\\) Stocke les ex\u00e9cutables et binaires essentiels lors du d\u00e9marrage mais r\u00e9serv\u00e9es au superuser (administrateur syst\u00e8me) (exemple reboot).</p> <p>/boot \u2665</p> <p>\\(\\color{blue}\\text{/boot}\\) Stocke les fichiers de d\u00e9marrage Linux</p> <p>/dev</p> <p>\\(\\color{blue}\\text{/dev}\\) (pour devices) Les fichiers li\u00e9s aux p\u00e9riph\u00e9riques.</p> <p>/etc \u2665</p> <p>\\(\\color{blue}\\text{/etc}\\) Les fichiers de configuration de Linux et des applications.</p> <p>/home \u2665</p> <p>\\(\\color{blue}\\text{/home}\\) Comptes des utilisateurs. </p> <p>/lib</p> <p>\\(\\color{blue}\\text{/lib}\\) Les librairies et biblioth\u00e8ques partag\u00e9s pour le fonctionnement de l'OS et des applications</p>"},{"location":"Linux/1-Linux/#les-principaux-repertoires","title":"Les principaux r\u00e9pertoires","text":"<p>/usr \u2665</p> <p>\\(\\color{blue}\\text{/usr}\\) R\u00e9pertoire des applications partag\u00e9es par diff\u00e9rentes machines ou utilisateurs. Les programmes dans /usr ne sont pas n\u00e9cessaires au d\u00e9marrage.</p> <p>/media \u2665</p> <p>\\(\\color{blue}\\text{/media}\\) Points de montages des m\u00e9dias amovibles (cl\u00e9s USB...)</p> <p>/proc</p> <p>\\(\\color{blue}\\text{/proc}\\) R\u00e9pertoire virtuel avec les informations syst\u00e8me (l'\u00e9tat du syst\u00e8me, noyau Linux, etc) bas\u00e9 sur procfs (process file system)</p> <p>/root</p> <p>\\(\\color{blue}\\text{/root}\\) Dossier personnel de l'utilisateur root</p> <p>/var \u2665</p> <p>\\(\\color{blue}\\text{/var}\\) Contient des donn\u00e9es mises \u00e0 jour par diff\u00e9rents programmes durant le fonctionnement du syst\u00e8me (fichiers journaux (log), des fichiers de donn\u00e9es (spool) ou des fichiers de blocage (lock)) </p> <p>/tmp \u2665</p> <p>\\(\\color{blue}\\text{/tmp}\\) Les fichiers temporaires.</p>"},{"location":"Linux/1-Linux/#le-repertoire-usr","title":"le r\u00e9pertoire /usr","text":"<p>Donn\u00e9es des applications des utilisateurs.</p> <p>/usr/bin</p> <p>\\(\\color{blue}\\text{/usr/bin}\\) Commandes utilisables par tous les utilisateurs, et non n\u00e9cessaires lors du d\u00e9marrage du syst\u00e8me.</p> <p>/usr/sbin</p> <p>\\(\\color{blue}\\text{/usr/sbin}\\) Commandes r\u00e9serv\u00e9es au super-utilisateur , et non n\u00e9cessaires lors du d\u00e9marrage du syst\u00e8me.</p> <p>/usr/lib</p> <p>\\(\\color{blue}\\text{/usr/lib}\\) Le dossier des librairies utilis\u00e9es par les applications</p> <p>/usr/local</p> <p>\\(\\color{blue}\\text{/usr/local}\\) Applications install\u00e9es localement par l'admnistrateur</p> <p>/usr/src</p> <p>\\(\\color{blue}\\text{/usr/src}\\) Les sources des applications que l'on peut compiler</p> <p>/usr/share</p> <p>\\(\\color{blue}\\text{/usr/share}\\) Le dossier avec les fichiers qui peuvent \u00eatre partag\u00e9s avec toutes les architectures (i386 -INTEL-, amd64 -AMD-, etc). </p> <p>/usr/local/bin</p> <p>\\(\\color{blue}\\text{/usr/local/bin}\\) C'est ici que peuvent \u00eatre plac\u00e9s les programmes persos \u00e0 partager avec d'autres utilisateurs (il faut quand m\u00eame  demander les droits au superuser).  </p> <p>...</p>"},{"location":"Linux/1-Linux/#le-repertoire-var","title":"Le r\u00e9pertoire /var","text":"<p>/var</p> <p>\\(\\color{blue}\\text{/var}\\) Le r\u00e9pertoire \\(\\color{blue}\\text{/usr/}\\) \u00e9tant en lecture seule, tous les programmes qui ont besoin d'\u00e9crire des fichiers journaux (log), des fichiers de donn\u00e9es (spool) ou des fichiers de blocage (lock) devraient les \u00e9crire dans \\(\\color{blue}\\text{/var}\\).</p> <p>/var/lock</p> <p>\\(\\color{blue}\\text{/var/lock}\\) Fichiers de blocage, pour interdire par exemple deux utilisations simultan\u00e9es d'un p\u00e9riph\u00e9rique.</p> <p>/var/run</p> <p>\\(\\color{blue}\\text{/var/run}\\) Des fichiers li\u00e9s aux applications en cours de fonctionnement. Par exemple on peut y trouver le PID de l'application.</p> <p>/var/log</p> <p>\\(\\color{blue}\\text{/var/log}\\) Les journaux et logs du syst\u00e8me et des applications</p> <p>/var/cache</p> <p>\\(\\color{blue}\\text{/var/cache}\\) Dossiers et fichiers de cache. Par exemple apt peut y stocker les packages pour installer ou mettre \u00e0 jour le syst\u00e8me et les applications.</p> <p>/var/spool</p> <p>\\(\\color{blue}\\text{/var/spool}\\) Pour stocker les fichiers de donn\u00e9es des programmes.</p>"},{"location":"Linux/1-Linux/#le-repertoire-etc","title":"le r\u00e9pertoire /etc","text":"<p>Stocke les fichiers de configurations du syst\u00e8me ainsi que des applications. Un sous-r\u00e9pertoire par application</p> <p>/etc/init.d et /etc/default</p> <p>\\(\\color{blue}\\text{/etc/init.d et /etc/default}\\) : les fichiers li\u00e9s aux daemons Linux</p> <p>/etc/password, /etc/group, /etc/shadow</p> <p>\\(\\color{blue}\\text{/etc/password, /etc/group, /etc/shadow}\\) : les fichiers de configuration des utilisateurs Linux.</p> <p>/etc/hosts</p> <p>\\(\\color{blue}\\text{/etc/hosts}\\) : le fichier HOSTS de Linux (liens entre adresses IP et litt\u00e9rales)</p> <p>/etc/sudoers et /etc/sudoers.d</p> <p>\\(\\color{blue}\\text{/etc/sudoers et /etc/sudoers.d}\\) : La configuration de sudo.</p> <p>/etc/sysctl.conf et /etc/sysctl.d</p> <p>\\(\\color{blue}\\text{/etc/sysctl.conf et /etc/sysctl.d}\\) Les fichiers de configuration de d\u00e9marrage du noyau Linux.</p> <p>...</p>"},{"location":"Linux/1-Linux/#des-fichiers-sensibles","title":"Des fichiers sensibles","text":"<p>Quelques fichiers particuli\u00e8rement importants, sur lesquels repose une  grande partie de la stabilit\u00e9 du syst\u00e8me, voire de son simple  fonctionnement  </p> <p>/etc/passwd</p> <p>\\(\\color{blue}\\text{/etc/passwd}\\) : fichier des utilisateurs et leurs mots de pass. Suppression de ce r\u00e9pertoire \\(\u21d2\\) impossible d'utiliser le syst\u00e8me.  </p> <p>/etc/fstab</p> <p>\\(\\color{blue}\\text{/etc/fstab}\\) Liste des partitions utilis\u00e9es par le syst\u00e8me et selon quelle m\u00e9thode il les utilise.  </p> <p>/boot/vmlinuz</p> <p>\\(\\color{blue}\\text{/boot/vmlinuz}\\) Se situe g\u00e9n\u00e9ralement, soit sous la racine (/), soit sous /boot. En fait, il s'agit du syst\u00e8me lui-m\u00eame ! Ultra sensible !</p> <p>...</p>"},{"location":"Linux/1-Linux/#le-shell-bash","title":"Le shell bash","text":"<p>On ne donne ici que quelques indications sur le shell bash :</p> <ul> <li>des principes g\u00e9n\u00e9raux d'\u00e9critures des commandes  </li> <li>quelques commandes forc\u00e9ment incompl\u00e8tes  </li> <li>pas d'instruction de programmation pour les scripts bash : on a  assez \u00e0 faire avec le langage C et OCAML.  </li> </ul>"},{"location":"Linux/1-Linux/#terminal-et-console","title":"Terminal et console","text":"<p>Terminal</p> <p>\\(\\color{blue}\\text{Terminal}\\) : environnement dans lequel on \u00e9crit et qui donne le retour  des commandes.  </p> <ul> <li>Il peut \u00eatre fourni par les serveur graphique et disposer  de fen\u00eatres, menus, et autres boutons ;  </li> <li>ou sans fen\u00eatre, comme lorsque on fait <code>Ctrl+Alt+F3</code> (entrer <code>Ctrl+Alt+F7</code> ou <code>Ctrl+Alt+F2</code> pour retourner au serveur graphique).</li> <li>Peut tr\u00e8s bien \u00eatre constitu\u00e9 d'une imprimante avec un  clavier comme un t\u00e9l\u00e9scripteur.    </li> </ul> <p>Shell</p> <p>\\(\\color{blue}\\text{Shell}\\) : interpr\u00e9teur de commande ; programme lanc\u00e9 juste apr\u00e8s la proc\u00e9dure de login et qui traite les commandes pass\u00e9es. Le shell le plus r\u00e9pandu sous Linux est le bash (Bourne again shell).</p> <p>Console</p> <p>\\(\\color{blue}\\text{Console}\\) : combinaison d'un terminal et d'un shell.</p> <p>\\(\\color{blue}\\text{Ouverture}\\) d'un terminal sous Ubuntu : <code>Ctr+Alt+T</code>.</p>"},{"location":"Linux/1-Linux/#un-terminal","title":"Un terminal","text":"<p>Figure \u2013 Un terminal dans lequel on n'a encore rien \u00e9crit</p> <ul> <li>Ouverture avec <code>Ctrl + Alt + T</code> </li> <li>Avant le prompt \\(\\$\\) : nom d'utilisateur</li> <li>\\(@\\) nom de machine puis r\u00e9pertoire courant  </li> <li>\\(\u02dc\\) d\u00e9signe le r\u00e9pertoire racine de mon compte personnel.  </li> </ul>"},{"location":"Linux/1-Linux/#syntaxe-generale-des-commandes","title":"Syntaxe g\u00e9n\u00e9rale des commandes","text":"<p>nom [-options] [argument1...]</p> <ul> <li>Explications :<ul> <li>\\(\\color{blue}\\text{nom}\\) nom de la commande</li> <li>\\(\\color{blue}\\text{options}\\) reor\u00e9sente une ou plusieurs options</li> <li>\\(\\color{blue}\\text{argument1}\\) est le \\(1\\)er argument</li> </ul> </li> <li>Les options sont \u00e9crites le plus souvent sous la forme d'un carac\u00e8re accol\u00e9 \u00e0 un tiret (ls -l) mais pas toujours, par exemple gcc --version. Les option courtes sont introduites par un tiret (-a), les longues par deux tirets (--all).</li> <li>si param\u00e8tre demand\u00e9, il est s\u00e9par\u00e9 par un espace : gcc essaie.c -o sortie (\\(2\\) param\u00e8tres : essai.c et sortie)</li> <li>les crochets indiquent un \u00e9l\u00e9ment \\(\\underline{\\textsf{facultatif}}\\)</li> <li>les points de suspension indiquent la possibilit\u00e9 de r\u00e9p\u00e9ter un argument, par exemple ls /etc /usr/bin</li> <li>s\u00e9paration par un espace ou une tabulation.</li> </ul>"},{"location":"Linux/1-Linux/#commandes-internes-vs-externes","title":"Commandes internes vs externes","text":"<p>Une commande externe est un fichier pr\u00e9sent dans l'arborescence. Exemple : Quand un utilisateur ex\u00e9cute la commande ls , le shell  demande au noyau Linux d'ex\u00e9cuter le fichier /bin/ls</p> <pre><code>$file /bin/ls  \n/bin/ls:ELF 64-bit LSB shared object, x86-64,\nversion 1 (SYSV), dynamically linked, [...]\n</code></pre> <p>Une commande interne est int\u00e9gr\u00e9e au processus shell. Elle n'a aucune correspondance avec un fichier sur le disque. L'acc\u00e8s \u00e0 une commande interne est plus rapide que pour une externe.</p> <p>La commande type indique si une commande est interne ou externe.</p> <pre><code>$ type ls  \nls est un alias vers &lt;&lt; ls -- color = auto &gt;&gt;  \n$ type cd  \ncd est une primitive du shell \n</code></pre> <p>Certaines commande ont une version externe et une interne.  </p>"},{"location":"Linux/1-Linux/#la-commande-man","title":"La commande man","text":"<p>Pour conna\u00eetre le mode d'emploi d'une commande, taper man nomDeLaCommande (ex : man ls pour conna\u00eetre le manuel de ls). Entrer q pour quitter. \u2665</p> <p>Consulter la documentation Ubuntu</p> <p>Le manuel est d\u00e9compos\u00e9 en plusieurs sections</p> <ul> <li>Programmes ex\u00e9cutables ou commandes de l'interpr\u00e9teur de commandes (shell) ;</li> <li>Appels syst\u00e8me (Fonctions fournies par le noyau) ;</li> <li>Appels de biblioth\u00e8que (fonctions fournies par des biblioth\u00e8ques) ;   - Fichiers sp\u00e9ciaux (situ\u00e9s g\u00e9n\u00e9ralement dans /dev) ;</li> <li>Formats des fichiers et conventions (Par exemple /etc/passwd) ;...</li> </ul> <p>Parfois deux pages de manuel ont le m\u00eame nom comme printf (en section \\(1\\) et \\(3\\)). Entrer man 1 printf ou man 3 printf pour  sp\u00e9cifier.</p> <p>Entrer q pour quitter le manuel.  </p>"},{"location":"Linux/1-Linux/#chemins-absolus-et-relatifs","title":"Chemins absolus et relatifs \u2665","text":"<ul> <li>Un \u00e9l\u00e9ment de l'arborescence est rep\u00e9r\u00e9 par son nom (par exemple  nom.jpg) pr\u00e9c\u00e9d\u00e9 de :<ul> <li>Son chemin absolu depuis la racine (ex :  /home/sue/Pictures/family/nom.jpg )</li> <li>Son chemin relatif depuis le r\u00e9pertoire courant. Par exemple, si je suis  dans pets : ../../family/nom.jpg </li> </ul> </li> <li>/: s\u00e9pare les noms de fichiers  </li> <li>\u02dc : r\u00e9pertoire racine du Home  </li> </ul>"},{"location":"Linux/1-Linux/#commentaire","title":"Commentaire","text":"<p>Les commentaires ne sont pas interpr\u00e9t\u00e9s :  </p> <ul> <li>La commande kalin n'existe pas, elle soul\u00e8ve une erreur :  </li> </ul> <pre><code>$ kalin\nLa commande &lt;&lt; kalin &gt;&gt; n'a pas \u00e9t\u00e9 trouv\u00e9e, ...  \n</code></pre> <p>Le caract\u00e8re # n'est pas interpr\u00e9t\u00e9. On peut \u00e9crire kalin sans  erreur :</p> <pre><code>$ # kalin\n$\n</code></pre>"},{"location":"Linux/1-Linux/#contenu-dun-repertoire","title":"Contenu d'un r\u00e9pertoire \u2665","text":"<p>La commande ls donne le contenu d'un r\u00e9pertoire :</p> <ul> <li>sans argument : les entr\u00e9es du r\u00e9pertoire courant ls</li> <li>avec argument : les entr\u00e9es rep\u00e9r\u00e9es par le (ou les) argument(s) :  ls myFile, ls myRep, ls /etc /usr/bin </li> <li>pour afficher les fichiers cach\u00e9s ls -a (indique notamment  .bashrc si je suis en \u02dc )</li> <li>pour pour tous les attributs (type, droits, liens physiques, propri\u00e9taire,  groupe, taille, date, nom) ls -l</li> <li>ls -al au lieu de ls -a -l.</li> </ul> <pre><code>$ls -lh\ntotal 1,8M\n-rw-rw-r--1 ivan ivan 67k ao\u00fbt 35 2021 accesDirect.png\n-rw-rw-r--1 ivan ivan 138k ao\u00fbt 35 2021 accesSequentiel.png\n</code></pre> <p>Dans l'ordre : droits, nombres d'alias, username, groupname, taille  (par d\u00e9faut en octet), date de derni\u00e8re modif., nom de fichier.</p> <p>ls -i affiche le num\u00e9ro d'inode.  </p>"},{"location":"Linux/1-Linux/#affichage-dune-chaine-de-caractere","title":"Affichage d'une cha\u00eene de caract\u00e8re","text":"<p>La commande echo affiche une ligne de texte</p> <p>(Le caract\u00e8re # indique le d\u00e9but d'un commentaire)</p> <pre><code>$echo 'coucou' # afficher coucou\ncoucou\n</code></pre> <p>Le choix des guillements est important : \" \\('\\) \" (<code>touche 4</code>),  \" \\(\"\\) \" (<code>touche 3</code>) et \" $<code>$ \" (\u00e0LT GR + 7</code>) n'ont pas le m\u00eame sens. Pour afficher le contenu d'une variable d'environnement :</p> <pre><code>$ echo $LANG  \nfr_FR.UTF-8  \n</code></pre>"},{"location":"Linux/1-Linux/#les-metacaracteres","title":"Les m\u00e9tacaract\u00e8res","text":"<p>Les m\u00e9tacaract\u00e8res du shell permettent :  </p> <ul> <li>de construire des cha\u00eenes de caract\u00e8res g\u00e9n\u00e9riques  </li> <li>de modifier l'interpr\u00e9tation d'une commande  </li> </ul>"},{"location":"Linux/1-Linux/#metacaracteres-de-construction","title":"M\u00e9tacaract\u00e8res de construction","text":"<p>Prioritaires : *, ?  </p> <ul> <li><code>*</code> d\u00e9signe une cha\u00eene de caract\u00e8res quelconque \u2665</li> <li><code>?</code> d\u00e9signe un caract\u00e8re quelconque \u2665</li> <li><code>[...]</code> d\u00e9signe les caract\u00e8res entre crochets, d\u00e9finis par \u00e9num\u00e9ration  ou par un intervalle :  <ul> <li>[Aa] d\u00e9signe les caract\u00e8res \\(A\\) ou \\(a\\),  </li> <li>[0-9a-zA-Z] d\u00e9signe un caract\u00e8re alphanum\u00e9rique quelconque.  </li> <li>[!0-9] d\u00e9signe l'ensemble des caract\u00e8res sauf les chiffres.  </li> </ul> </li> </ul> <p>Voici le contenu du r\u00e9pertoire courant :  </p> <pre><code>$ ls  \nalain Ali tata titi toto tutu zut\n</code></pre> <ul> <li>ls t[ao]t[ao] retourne tata et toto ,  </li> <li>ls ??? retourne les noms de \\(3\\) lettres donc zut et Ali </li> <li>ls A retourne les noms qui commencent par \\(A\\) donc Ali*  </li> <li>ls t??o retourne les noms de \\(4\\) lettres qui terminent par \\(o\\) et  commencent par \\(t\\) donc toto </li> <li>ls [!b-z]* d\u00e9signe les noms qui ne commencent pas par une lettre  entre \\(b\\) et \\(z\\) donc alain et Ali .  </li> </ul>"},{"location":"Linux/1-Linux/#metacaracteres-de-modification-pi","title":"M\u00e9tacaract\u00e8res de modification (PI)","text":"<ul> <li><code>;</code> s\u00e9pare deux commandes sur une m\u00eame ligne  </li> <li>Les guillemets verticaux simples \\('\\) (<code>touche 4</code>) d\u00e9limitent une ha\u00eene  de caract\u00e8res contenant des espaces (\u00e0 l'int\u00e9rieur, tous les m\u00e9tacaract\u00e8res perdent leur signification);</li> <li>Les guillemets verticaux doubles \\(\u201d\\) (<code>touche 3</code>) d\u00e9limitent une cha\u00eene de caract\u00e8res contenant des espaces (\u00e0 l'int\u00e9rieur, tous les m\u00e9tacaract\u00e8res perdent leur signification, \u00e0 l'exception des m\u00e9tacaract\u00e8res \\(\u2018\\) et \\(\\$\\)) ;  </li> <li>Les guillemets obliques gauche-droite \\(\u2018\\) (\u00e0LT GR + 7`) \"capturent\" la sortie standard pour former un nouvel argument ou une nouvelle commande ;</li> </ul> <pre><code>$ echo \u201d$LANG\u201d; echo '$LANG' # deux commandes successives\nfr FR.UTF\u22128\n$LANG\n$ echo \u201don est `date` \u201d # observer les guillemets\non est jeu. 25 janv. 2024 19:17:45 CET\n</code></pre> <ul> <li>\\(\\backslash\\) annule la signification du m\u00e9tacaract\u00e8re qui suit : c'est un  caract\u00e8re dit d'\u00e9chappement.  </li> </ul> <pre><code>$ echo \u201don est \\`date\\` \u201d\non est `date`\n</code></pre> <p>le &amp; \u00e0 la fin d'une commande permet de lancer celle-ci en t\u00e2che de  fond, donc sans bloquer le terminal.</p> <pre><code>$emacs toto # mon terminal va se bloquer\n</code></pre> <p><code>CTRL + C</code> pour quitter brutalement. Ou mieux <code>CTRL + Z</code> (passage \u00e0 l'\u00e9tat zombi) suivi de bg (remise en t\u00e2che de fond)</p> <pre><code>$emacs toto &amp; # mon terminal ne va pas se bloquer\n</code></pre>"},{"location":"Linux/1-Linux/#parentheses","title":"Parenth\u00e8ses","text":"<ul> <li>(...) : les parenth\u00e8ses encadrent une suite de commandes qui sont  ex\u00e9cut\u00e9es par un shell secondaire. En particulier, les assignements  n'ont pas d'effet en dehors des parenth\u00e8ses.  </li> <li>{...} : les accolades encadrent une suite de commandes qui sont  ex\u00e9cut\u00e9es par le shell principal. En particulier, les assignements ont un  effet en dehors des accolades.</li> <li>[...] : les crochets sont utilis\u00e9s pour les instructions  conditionnelles. Ils encadrent une expression \u00e0 valeur boul\u00e9enne.</li> </ul> <pre><code>$ [\u2212d presentationLinux.tex] # est\u2212ce un dossier ?\n$ echo $? # afficher la r\u00e9ponse du test pr\u00e9c\u00e9dent\n1\n</code></pre> <p>On obtient \\(0\\) si le fichier existe et est un r\u00e9pertoire, \\(1\\) sinon. ...  </p>"},{"location":"Linux/1-Linux/#utiliser-le-resultat-dune-commande-comme-argument-dune-autre-pi","title":"Utiliser le r\u00e9sultat d'une commande comme argument d'une autre (PI)","text":"<p>Pour info. Les \\(\u2018\\) (ALT GR + 7) entourant une commande permettent d'utiliser le r\u00e9sultat de cette commande comme argument(s) dans la ligne  de commande.</p> <pre><code>$ echo \" Nous sommes le\" `date +% d /% m /% y`\nNous sommes le 27/08/21\n</code></pre> <p>Affiche la date du jour avec un format choisi.</p> <pre><code>$ echo \" 2 + 2  = \" \u00e8xpr 2 + 2`\n2 + 2 = 4  \n</code></pre>"},{"location":"Linux/1-Linux/#positionnementrecherche-dans-larborescence","title":"Positionnement/recherche dans l'arborescence \u2665","text":"<p>pwd</p> <p>\\(\\color{blue}\\text{pwd}\\) affiche le nom absolu du r\u00e9pertoire de travail</p> <p>cd</p> <p>\\(\\color{blue}\\text{cd}\\) change le r\u00e9pertoire de travail.</p> <ul> <li>Avec argument : se rend \u00e0 la destination indiqu\u00e9e.  cd ../Rep1 ;  </li> <li>Sans argument : retourne au r\u00e9pertoire de connexion du  user. cd </li> </ul> <p>ls</p> <p>\\(\\color{blue}\\text{ls}\\) liste les entr\u00e9es d'un r\u00e9pertoire (d\u00e9j\u00e0 vu) ls .</p> <p>find</p> <p>\\(\\color{blue}\\text{find}\\) pour chercher r\u00e9cursivement un ou plusieurs fichiers dans une arborescence. Beaucoup d'options (consulter le manuel).</p>"},{"location":"Linux/1-Linux/#rechercher","title":"Rechercher","text":"<p>find cherche r\u00e9cursivement dans l'arborescence \u00e0 partir du point indiqu\u00e9. find /usr -name \"ls*\" cherche les fichiers dont le nom commence par ls dans le r\u00e9pertoire /usr et ses sous-r\u00e9pertoires. Il y en a beaucoup ! \u2665</p> <p>L'option -type permet de ne chercher que les fichiers (<code>f</code>) ou les r\u00e9pertoires (<code>d</code>).  find /var/log/ -type d -name \"*sm*\" : chercher les r\u00e9pertoires dont le nom contient sm  `</p> <p>Recherche par taille :  find /T\u00e9l\u00e9chargements -size +20M -size -40M  cherche les fichiers dont la taille est comprise entre \\(20\\)Mo et \\(40\\)Mo.  </p> <p>Recherche par utilisateur : find /tmp -user adrien cherche dans /tmp les fichiers dont le propri\u00e9taire est adrien.</p> <p>Beaucoup d'autres options : par date de cr\u00e9ation, date de derni\u00e8re  modification, par type de permissions, recherche de fichiers vides etc...  </p>"},{"location":"Linux/1-Linux/#consulter-le-contenu-dun-fichier-texte","title":"Consulter le contenu d'un fichier texte \u2665","text":"<p>Commandes de base :</p> <ul> <li>cat monfichier , more monfichier : affichage simple et page par page ;  </li> <li>head monfichier , head -n monfichier : affichage des \\(n\\) premi\u00e8res lignes ;  </li> <li>tail monfichier , tail -n monfichier : affichage des \\(n\\) derni\u00e8res lignes ;  </li> <li>wc monfichier : affichage du nombre de lignes, de mots, de  caract\u00e8res. Options -l, -w et -c pour les nombres de lignes, de mots et de caract\u00e8res.  </li> <li>cat toto titi : affiche le contenu de titi \u00e0 la suite de celui de toto (cat pour concat\u00e8ne).  </li> </ul>"},{"location":"Linux/1-Linux/#historique","title":"Historique \u2665","text":"<p>Le shell bash enregistre toutes les commandes tap\u00e9es et permet de  les rappeler pour les r\u00e9-ex\u00e9cuter soit telles quelles, soit modifi\u00e9es.</p> <p>La commande history permet de lister le contenu de l'historique des commandes, de fa\u00e7on num\u00e9rot\u00e9e. Le caract\u00e8re ! permet de rappeler une commande.</p> <ul> <li>\\(\\color{blue}\\text{!!}\\) rappelle la derni\u00e8re commande</li> <li>\\(\\color{blue}\\text{!n}\\) rappelle la commande num\u00e9ro \\(n\\)</li> <li>\\(\\color{blue}\\text{!chaine}\\) rappelle la derni\u00e8re commande commen\u00e7ant par chaine</li> </ul> <p>On peut aussi utiliser les \ufb02\u00e8ches haut et bas pour naviguer dans  l'historique des commandes.  </p>"},{"location":"Linux/1-Linux/#taille-du-contenu-dun-repertoire","title":"Taille du contenu d'un r\u00e9pertoire","text":"<p>du -h -d 1 monRepertoire : taille des fichiers et sous-r\u00e9pertoires.  (du pour Disk User)</p> <ul> <li>L'option -h force un affichage \"human readable\" (par exemple, \\(1k\\),  \\(236M\\), \\(2G\\)).  </li> <li>L'option -d affiche la taille totale du r\u00e9pertoire explor\u00e9 et pas  seulement la taille de ses constituants. Et le param\u00e8tre \\(1\\) indique la  profondeur de l'exploration (ici, on s'arr\u00eate aux fils, avec \\(2\\) comme  param\u00e8tre , ce serait aux petits-fils)</li> </ul> <p>La commande ncdu nomDuRepertoire, plus conviviale, permet de  conna\u00eetre la place prise par les fichiers et dossiers en navigant dans  l'arborescence. Par exemple ncdu /home indique les tailles des  diff\u00e9rents r\u00e9pertoires utilisateurs.  </p>"},{"location":"Linux/1-Linux/#creer-et-supprimer","title":"Cr\u00e9er et supprimer","text":"<ul> <li>Cr\u00e9er un r\u00e9pertoire vide : mkdir Rep1 </li> <li>Supprimer un r\u00e9petoire vide : rmdir Rep1</li> <li>Cr\u00e9er un fichier vide : touch file1 </li> <li>Supprimer un fichier rm file1 , supprimer tous les fichiers du  r\u00e9pertoire rm * </li> <li>Cr\u00e9er un chemin complet mkdir -p R1/R2 cr\u00e9e dans la foul\u00e9e R1 puis son sous-r\u00e9pertoire R2.  </li> </ul>"},{"location":"Linux/1-Linux/#copier-cp-et-deplacer-mv","title":"Copier (cp) et d\u00e9placer (mv) \u2665","text":"<p>Situation : un r\u00e9pertoire parent P poss\u00e8de deux sous-r\u00e9pertoires Rep1 et Rep2. Dans Rep1 on trouve le fichier file1.  </p> <ul> <li>Copier le fichier file1 du r\u00e9pertoire Rep1 dans le r\u00e9pertoire Rep2 sans changer le nom : cp Rep1/file1 Rep2/</li> <li>Copier le fichier file1 du r\u00e9pertoire Rep1 dans le r\u00e9pertoire Rep2 en changeant le nom : cp Rep1/file1 Rep2/file2 </li> <li>Je suis dans Rep1. Changer le nom du fichier file1 en restant dans le m\u00eame r\u00e9pertoire : mv file1 file2.</li> <li>Je suis dans Rep1. d\u00e9placer le fichier file1 sans changer son nom mv file1 ../Rep2/.</li> <li>Je suis dans le r\u00e9pertoire parent de P. Je veux copier r\u00e9cursivement P et tout ce qu'il contient (donc aussi les sous-r\u00e9pertoires) dans un nouveau r\u00e9pertoire P2 : cp -r P1 P2 </li> </ul>"},{"location":"Linux/1-Linux/#creer-remplir-vider-supprimer-un-repertoire","title":"Cr\u00e9er, remplir, vider, supprimer un r\u00e9pertoire","text":"<pre><code>$ mkdir Asup # Creer r\u00e9pertoire Asup\n\n$ cd Asup # aller au r\u00e9pertoire Asup\n$ ls # pas de contenu\n\n$ touch asup # cr\u00e9er le fichier vide asup\n$ ls \u2212al # afficher fichiers cach\u00e9s\ntotal 8\ndrwxrwxr\u2212x 2 ivan ivan 4096 ao\u02c6ut 19 15:28 .\ndrwxrwxr\u2212x 3 ivan ivan 4096 ao\u02c6ut 19 15:28 ..\n\u2212rw\u2212rw\u2212r\u2212\u2212 1 ivan ivan 0 ao\u02c6ut 19 15:28 asup\n\n$ rm asup # supprimer asup\n$ ls # plus de contenu\n\n$ cd .. # revenir au p\u00e8re\n$ rmdir Asup # supprime rep Asup\n</code></pre> <p>Les r\u00e9pertoires Nouveau et son fils AutreNouveau sont cr\u00e9\u00e9s simultann\u00e9ment puis supprim\u00e9s de m\u00eame</p> <pre><code>$ mkdir \u2212p Nouveau/AutreNouveau # creer un r\u00e9pertoire et son fils\n$ rmdir \u2212p Nouveau/AutreNouveau # supprimer un r\u00e9pertoire et son fils\n</code></pre>"},{"location":"Linux/1-Linux/#explorer-un-fichier","title":"Explorer un fichier","text":"<p>grep affiche les lignes v\u00e9rifiant un pattern.</p> <p>Contenu d'un fichier \\(\\texttt{myfile}\\) : </p> <p>\\(\\begin{matrix} \\texttt{toto et gogo}\\\\ \\texttt{tot et gogo}\\\\ \\texttt{totoooo et gaga}\\\\ \\texttt{atoto et titi}\\\\ \\texttt{titi et tutu} \\end{matrix}\\)</p> <ul> <li>grep \"toto\" myfile cherche le mot \"toto\" dans myfile </li> <li>grep -c \"toto\" myfile cherche le nombre d'occurences du mot \"toto\" dans myfile.  </li> <li>Option grep -n \"toto\" pour afficher les num\u00e9ros de lignes.  </li> <li>Le joker * n'a pas ici la m\u00eame signification que le m\u00e9tacaract\u00e8re du  shell ! grep \"toto*\" myfile cherche les lignes contenant au moins un tot suivi par \\(0\\), \\(1\\) ou plusieurs lettres \"o\" (renvoie, tot, toto, totoo et atoto)</li> <li>grep \"toto$\" myfile : les lignes qui terminent par toto  </li> <li>grep \"^toto\" myfile : les lignes qui commencent par toto  </li> <li>grep -v \"toto\" myfile : les lignes ne contenant pas toto  </li> <li>grep -E \"toto?\" myfile : les lignes qui contiennent tot, toto mais pas totoo. L'option E permet de b\u00e9n\u00e9ficer des expression r\u00e9guli\u00e8res \u00e9tendues.</li> </ul>"},{"location":"Linux/1-Linux/#sed","title":"sed","text":"<p>sed</p> <p>sed (stream editor) permet de modifier ou de supprimer une partie d'une cha\u00eene de caract\u00e8res, par exemple pour remplacer un caract\u00e8re par un autre dans un fichier, ou encore supprimer des cha\u00eenes de caract\u00e8res inutiles.</p> <ul> <li>sed 's/occurence_cherch\u00e9e/occurence_substitu\u00e9e/g' fichier Option s pour substituer, g pour appliquer r\u00e9cursivement la subsitution.</li> </ul> <pre><code>$ sed \u201ds/ //g\u201d myfile # supprime tous les espaces\ntotoetgogo\ntotetgogo\n...\n$ sed \u201ds/o/AAA/g\u201d myfile #remplace o par AA\ntAAAtAAA et gAAAgAAA\ntAAAt et gAAAgAAA\n</code></pre> <ul> <li>Normalistation des espaces (on les affiche pour comprendre)</li> </ul> <pre><code>$ export chaine=\u201dun et deux\u201d #cr\u00e9ation d\u2019une variable\n$ echo $chaine | sed \u201ds/ / /g\u201d #normalisation des espaces\nun et deux\n</code></pre>"},{"location":"Linux/1-Linux/#montage-et-demontage","title":"Montage et d\u00e9montage","text":"<p>L'arborescence de fichier de Linux inclut tous les p\u00e9riph\u00e9riques  externes.</p> <p>Le syst\u00e8me d'exploitation d'un ordinateur basique est install\u00e9 sur le  disque dur. L'utilisateur peut d\u00e9cider d'ins\u00e9rer un p\u00e9riph\u00e9rique externe  (ex : une cl\u00e9 USB).</p> <p>Les p\u00e9riph\u00e9riques de stockage sont associ\u00e9s \u00e0 un r\u00e9pertoire particulier. Par exemple le disque dur principal sur lequel l'OS est install\u00e9 est  associ\u00e9 au r\u00e9pertoire \\(\\color{blue}\\text{/}\\)</p> <p>L'utilisateur peut choisir de monter temporairement un syst\u00e8me de  fichier par ses propres moyens gr\u00e2ce \u00e0 la commande mount. En g\u00e9n\u00e9ral le montage se fait dans le r\u00e9pertoire \\(\\color{blue}\\text{/mnt}\\). Les op\u00e9rations de montage manuel n\u00e9cessitent g\u00e9n\u00e9ralement les droits du superuser.</p> <p>Les m\u00e9dias amovibles (comme une cl\u00e9 USB) sont, sous Ubuntu, mont\u00e9s automatiquement (i.e. appel automatique de mount) dans le r\u00e9pertoire \\(\\color{blue}\\text{/media}\\).</p> <p>Par exemple si l'utilisateur toto ins\u00e8re une cl\u00e9 USB, son arborescence de fichier est visible dans un r\u00e9pertoire comme \\(\\color{blue}\\text{/media/toto/CLE}\\). </p> <p>Tous les fichiers de la cl\u00e9s sont disponibles dans ce r\u00e9pertoire.</p> <p>Et les cr\u00e9ations/modifications/suppressions de fichier dans ce  r\u00e9pertoire sont r\u00e9percut\u00e9es sur la cl\u00e9.  </p> <p>Pour d\u00e9monter un m\u00e9dia amovible, il y a en g\u00e9n\u00e9ral une interface  graphique.  </p> <p></p> <p>Figure \u2013 Un bouton pour \"\u00e9jecter\" la cl\u00e9</p> <p>Pour d\u00e9monter manuellement un syst\u00e8me de fichier, on utilise la commande umount .  </p> <p>Cette commande requiert en g\u00e9n\u00e9ral les droits du superuser.  </p>"},{"location":"Linux/2-Fichiers/","title":"Fichiers, syst\u00e8mes de fichiers","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Un cours du site Malekal</li> <li>Un cours de Eric Thirion ici</li> </ul>"},{"location":"Linux/2-Fichiers/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"Linux/2-Fichiers/#introduction","title":"Introduction","text":"<p>La RAM est volatile. Mais les codes et les donn\u00e9es des programmes stock\u00e9s dans la m\u00e9moire centrale (et en particulier ceux du syst\u00e8mes d'exploitation) ont besoin d'\u00eatre conserv\u00e9 au del\u00e0 de l'arrept de l'ordinateur.</p> <p>C'est le r\u00f4le du syst\u00e8me de gestion de fichiers qui assure la conservation des donn\u00e9es sur un support de masse non volatile (disque dur, DVD, cl\u00e9 USB...).</p> <p>Le syst\u00e8me d'exploitation offre \u00e0 l'utilisateur une interface de stockage ind\u00e9pendante des propri\u00e9t\u00e9s physiques des supports de conservation. Son unit\u00e9 de base est le fichier.</p> <p>Le concept de fichier pr\u00e9sente deux niveaux :</p> <ul> <li>le fichier logique repr\u00e9sente les donn\u00e9es incluses dans le fichier telles qu'elles sont vues par l'utilisateur;</li> <li>le fichier physique repr\u00e9sente le fichier tel qu'il est allou\u00e9 physiquement sur la m\u00e9moire de masse.</li> </ul> <p>Le syst\u00e8me d'exploitation g\u00e8re ces deux niveaux et assure la correspondance entre eux via la notion de r\u00e9pertoire</p>"},{"location":"Linux/2-Fichiers/#quest-ce-quun-fichier","title":"Qu'est-ce qu'un fichier","text":"<p>Fichier</p> <p>Un fichier est un ensemble de donn\u00e9es num\u00e9riques r\u00e9unies sous un m\u00eame nom, enregistr\u00e9 sur un suport de stockage permanent appel\u00e9 m\u00e9moire de masse (ex : disque dur, cl\u00e9 USB, m\u00e9moire flash etc...).</p> <p>Afin de faciliter leur organisation, les fichiers sont dispos\u00e9s dans des syst\u00e8mes de fichiers qui permettent de les placer dans des emplacements appel\u00e9s r\u00e9pertoires eux-m\u00eame organis\u00e9s selon le m\u00eame principe. On obtient alors une hierarchie arborescente.</p> <p>Un fichier poss\u00e8de toujours (au moins) un nom qui sert \u00e0 d\u00e9signer le contenu pour l'utilisateur humain et \u00e0 y acc\u00e9der. Le syst\u00e8me, lui, utilise plut\u00f4t un num\u00e9ro d'inode.</p> <p>Chaque fichier poss\u00e8de en outre des m\u00e9tadonn\u00e9es (des informations sur le fichier lui-m\u00eame) comme sa longueur, son auteur, les personnes autoris\u00e9es \u00e0 le manipuler ou la date de derni\u00e8re modification.</p>"},{"location":"Linux/2-Fichiers/#opertation-sur-les-fichiers","title":"Op\u00e9rtation sur les fichiers","text":""},{"location":"Linux/2-Fichiers/#fichier-logique","title":"Fichier logique","text":"<p>Correspond \u00e0 la vue que l'utilisateur a de la conservation de ces donn\u00e9es :</p> <ul> <li>C'est un type de donn\u00e9es standard d\u00e9fini dans les langages de programmation que l'on peut cr\u00e9er, ouvrir, fermer, d\u00e9truire. Les op\u00e9rations de cr\u00e9ations et de fermeture effectuent la liaison du fichier logique avec le fichier physique. Les op\u00e9rations de destruction et de fermeture rompent cette liaison.</li> <li>C'est \u00e9galement un ensemble d'enregistrements (ou articles) sur le mod\u00e8le des structures en C.</li> </ul>"},{"location":"Linux/2-Fichiers/#operations","title":"Op\u00e9rations","text":"<p>Les langages de programmation permettent de :</p> <ul> <li>cr\u00e9er des fichiers</li> <li>enregistrer des informations dans un fichier (c'est l'acc\u00e8s en \u00e9criture)</li> <li>lire des informations dans un fichier (c'est l'acc\u00e8s en lecture).</li> <li>Que ce soit en lecture ou en \u00e9criture, il y a deux fa\u00e7ons d'acc\u00e9der au contenu d'un fichier<ul> <li>acc\u00e8s s\u00e9quentiel</li> <li>et acc\u00e8s direct</li> </ul> </li> </ul>"},{"location":"Linux/2-Fichiers/#sequence-de-manipulation-des-fichiers","title":"S\u00e9quence de manipulation des fichiers","text":"<ul> <li>Ouvrir le fichier : on informe le syst\u00e8me que l'on a l'intention d'acc\u00e8der au fichier. C'est ici que peuvent survenir les erreurs d'acc\u00e8s.</li> <li>Lire des informations / Ecrire des informations</li> <li>Fermer le fichier. On informe le syst\u00e8me que le programm a fini d'utiliser le fichier. Un autre programme ou un autre utilisateur pourra donc y acc\u00e9der \u00e0 son tour.</li> <li>Quand on acc\u00e8de en \u00e9criture \u00e0 un fichier qui n'existe pas, le syst\u00e8me le cr\u00e9e. En revanche l'acc\u00e8s en lecture \u00e0 un fichier qui n'existe pas soul\u00e8ve une erreur.</li> </ul>"},{"location":"Linux/2-Fichiers/#erreurs-dacces","title":"Erreurs d'acc\u00e8s","text":"<p>Le syst\u00e8me d'exploitation peut refuser l'acc\u00e8s \u00e0 un fichier pour diverses raisons :</p> <ul> <li>acc\u00e8s en lecture \u00e0 un fichier qui n'existe pas,</li> <li>acc\u00e8s en lecture sur un fichier dont on n'a pas les droits (ce fichier appartient \u00e0 un autre utilisateur)</li> <li>acc\u00e8s en \u00e9criture sur un fichier alors qu'on n'a pas le droit d'\u00e9criture dessus.</li> <li>acc\u00e8s en \u00e9criture sur un fichier alors qu'un autre utilisateur est en train de l'exploiter (en lecture ou \u00e9criture),</li> <li>acc\u00e8s en \u00e9criture sur un fichier alors que le p\u00e9riph\u00e9rique qui le contient est plein.</li> <li>quand on essaye d'acc\u00e8der \u00e0 une ligne apr\u00e8s la derni\u00e8re ligne du fichier.</li> </ul> <p>Cette liste n'est pas exhaustive.</p>"},{"location":"Linux/2-Fichiers/#acces-sequentiel","title":"Acc\u00e8s s\u00e9quentiel","text":"<p>Dans l'acc\u00e8s s\u00e9quentiel, une op\u00e9ration de lecture ou d'\u00e9criture se fait toujours juste apr\u00e8s la derni\u00e8re partie du fichier lue ou \u00e9crite (voir figure \\(1\\) ci-dessous).</p> <ul> <li>Les fichiers texte n'autorisent que ce type d'acc\u00e8s.</li> <li>Les fichiers structur\u00e9s autorisent les deux types d'acc\u00e8s (s\u00e9quentiel ou direct).</li> </ul> <p></p> <p>Figure 1 \u2013 Acc\u00e8s s\u00e9quentiel : on acc\u00e8de au \\(53\\)\u00e8me \u00e9l\u00e9ment \\(\\underline{\\textsf{apr\u00e8s}}\\) le \\(52\\)\u00e8me. (d'apr\u00e8s E. Thirion)</p>"},{"location":"Linux/2-Fichiers/#acces-direct","title":"Acc\u00e8s direct","text":"<p>L'acc\u00e8s direct n'est possible que pour les fichiers dits structur\u00e9s : ils sont d\u00e9finis comme une suite de blocs de taille fixe que l'on appelle enregistrements. (voir figure \\(2\\) ci-dessous).</p> <p>Le terme \"acc\u00e8s direct\" signifie qu'il est possible d'acc\u00e9der directement \u00e0 un enregistrement \u00e0 partir de sa position dans le fichier : par exemple lire (ou modifier) le \\(53\\)\u00e8me enregistrement du fichier ou le modifier sans avoir lu ou modifi\u00e9 ceux qui pr\u00e9c\u00e8dent.</p> <p></p> <p>Figure 2 \u2013 Acc\u00e8s direct : on acc\u00e8de au \\(53\\)\u00e8me enregistrement \\(\\underline{\\textsf{directement}}\\) sans passer par les pr\u00e9c\u00e9dents. (d'apr\u00e8s E. Thirion)</p>"},{"location":"Linux/2-Fichiers/#manipuler-un-fichier-texte","title":"Manipuler un fichier texte","text":"<p>L'acc\u00e8s se fait en lecture ou en \u00e9criture mais (en g\u00e9n\u00e9ral) pas les deux. Deux options pour le mode \u00e9criture : \u00e9criture au d\u00e9but (donc avec \u00e9crasement du contenu) ou bien, \u00e0 la fin, en conservant le contenu pr\u00e9c\u00e9dent (dans ce cas, on parle de mode ajout).</p> <p>On acc\u00e8de aux informations s\u00e9quentiellement, le \"grain\" de la s\u00e9quence \u00e9tant soit la ligne soit le caract\u00e8re. On indique ici ce qu'il se passe dans le mode par ligne :</p> <ul> <li>Apr\u00e8s l'ouverture du fichier en lecture on acc\u00e8de \u00e0 sa premi\u00e8re ligne. Le contenu d'une ligne est recopi\u00e9 dans une variable de type cha\u00eene de caract\u00e8res pour un usage imm\u00e9diat ou ult\u00e9rieur. D\u00e8s qu'une ligne \\(i\\) est lue, un \"curseur\" se d\u00e9place dans le fichier pour acc\u00e9der \u00e0 la ligne suivante.</li> <li>Apr\u00e8s l'ouverture en \u00e9criture, on acc\u00e8de aussi \u00e0 la premi\u00e8re ligne. On peut alors \u00e9crire dans cette ligne une cha\u00eene de caract\u00e8re (par exemple, le contenu d'une variable). Puis on passe \u00e0 la seconde ligne si on d\u00e9cide d'en ajouter une etc.</li> </ul>"},{"location":"Linux/2-Fichiers/#partitions-peripheriques","title":"Partitions p\u00e9riph\u00e9riques","text":""},{"location":"Linux/2-Fichiers/#presentation_1","title":"Pr\u00e9sentation","text":"<p>Partition</p> <p>Une partition est une section d'un support de stockage (disque dur, SSD, carte-m\u00e9moire...).</p> <p>Partitionnement</p> <p>Le partitionnement est l'op\u00e9ration qui consiste \u00e0 diviser ce support en partitions dans lesquelles le syst\u00e8me d'exploitation peut g\u00e9rer les informations de mani\u00e8re s\u00e9par\u00e9e, g\u00e9n\u00e9ralement en y cr\u00e9ant un syst\u00e8me de fichiers, une mani\u00e8re d'organiser l'espace disponible.</p> <p>Faux ami</p> <p>Le sens math\u00e9matique est diff\u00e9rent.</p> <p><p></p></p> <p>Figure 3 \u2013 Exemple sch\u00e9matique de partitionnement d'un support mixtebLinux/Windows, avec des liens entre les partitions (Wikipedia)</p>"},{"location":"Linux/2-Fichiers/#peripheriques","title":"P\u00e9riph\u00e9riques","text":"<p>P\u00e9riph\u00e9rique</p> <p>Un p\u00e9riph\u00e9rique est un mat\u00e9riel (physique) connect\u00e9 \u00e0 l'unit\u00e9 centrale d'un ordinateur : disque, souris, \u00e9cran, r\u00e9seau... Les p\u00e9riph\u00e9riques sont rep\u00e9rables par un nom dans l'arborescence (sous /dev).</p> <p>Pilote de p\u00e9riph\u00e9rique/ Driver</p> <p>Un pilote de p\u00e9riph\u00e9riques ou driver est une fonction du syst\u00e8me d'exploitation permettant de manipuler une cat\u00e9gorie de p\u00e9riph\u00e9riques via les op\u00e9rations classiques autoris\u00e9es par les inodes : open, read, write, close.</p> <p>Pseudo-p\u00e9riph\u00e9rique</p> <p>Un pseudo-p\u00e9riph\u00e9rique est une entr\u00e9e g\u00e9r\u00e9e comme un p\u00e9riph\u00e9rique bien que non associ\u00e9e \u00e0 un \u00e9l\u00e9ment physique.</p> <ul> <li>Utilisation \\(1\\) : rep\u00e9rage de p\u00e9riph\u00e9riques dits virtuels, i.e. des parties de p\u00e9riph\u00e9riques (physiques), par exemple : les \u00e9crans virtuels de l'\u00e9cran (physique), partitions (logiques) du disque (physique)...</li> <li>Utilisation \\(2\\) : mise en \u00e9vidence de fonctionnalit\u00e9s du syst\u00e8me d'exploitation dans l'arborescence, par exemple : la \"poubelle\" qui a pour nom /dev/null.</li> </ul> <p>Pour l'OS, p\u00e9riph\u00e9riques et pseudo-p\u00e9riph\u00e9riques sont des fichiers.</p>"},{"location":"Linux/2-Fichiers/#connaitre-les-systemes-de-fichiers-montes","title":"Conna\u00eetre les syst\u00e8mes de fichiers mont\u00e9s","text":"<p>Il suffit d'entrer la commande mount.</p> <p>Par exemple :</p> <pre><code>$mount\n...\n/dev/sdc1 on /media/ivan/KINGSTON type vfat (...)\n...\n</code></pre> <p>On constate que ma cl\u00e9 usb est rep\u00e9r\u00e9e par sdc1, qu'elle est mont\u00e9e sur /media/ivan/KINGSTOM et que son syst\u00e8me de fichier est \\(\\text{VFAT}\\)</p>"},{"location":"Linux/2-Fichiers/#udev","title":"udev","text":"<p>Le d\u00e9mon \\(udev\\) est charg\u00e9 de g\u00e9rer les device-nodes : pseudos-fichiers stock\u00e9s normalement dans /dev charg\u00e9s de repr\u00e9senter les p\u00e9riph\u00e9riques.</p> <p>Ce sont en r\u00e9alit\u00e9 des points d'entr\u00e9es vers le noyau caract\u00e9ris\u00e9s par un type d'acc\u00e8s (bloc ou char) et deux nombres, un majeur et un mineur :</p> <ul> <li>le type d\u00e9finit le mode d'acc\u00e8s (donc par bloc ou par caract\u00e8re) au p\u00e9riph\u00e9rique</li> <li>le majeur permet au noyau de conna\u00eetre le driver qui g\u00e8re le p\u00e9riph\u00e9rique</li> <li>le mineur permet au driver de savoir quel p\u00e9riph\u00e9rique parmi ceux qu'il g\u00e8re (il peut y en avoir plusieurs) est utilis\u00e9.</li> </ul>"},{"location":"Linux/2-Fichiers/#majeurs-et-mineurs","title":"Majeurs et mineurs","text":"<p>La commande ls -l nous donne les informations sur le type d'acc\u00e8s et les majeurs et mineurs (entre autres) J'interroge ci-dessous le syst\u00e8me \u00e0 propos de mon disque dur NVMe :</p> <pre><code>$ls \u2212l /dev/nvme0n1\nbrw\u2212rw\u2212\u2212\u2212\u22121 root disk 259, 0 ao\u00fbt 19 09:57 /dev/nvme0n1\n</code></pre> <ul> <li>le b en d\u00e9but de ligne indique qu'il s'agit d'un p\u00e9riph\u00e9rique avec acc\u00e8s par bloc.</li> <li>le majeur est \\(259\\), il indique quel driver est utilis\u00e9</li> <li>le mineur est \\(0\\) : il indique quel p\u00e9riph\u00e9rique est ici g\u00e9r\u00e9 par ce driver.</li> </ul> <p>P\u00e9riphe\u00e9rique avec acc\u00e8s s\u00e9quentiel</p> <p>J'interroge ci-dessous le syst\u00e8me \u00e0 propos de ma souris :</p> <pre><code>ls \u2212l /dev/input/mouse1\ncrw\u2212rw\u2212\u2212\u2212\u22121 root input 13, 33 janv. 11 17:25 /dev/input/mouse1\n</code></pre> <p>le c en d\u00e9but de ligne indique qu'il s'agit d'un p\u00e9riph\u00e9rique avec acc\u00e8s par octet (ou par caract\u00e8re). le majeur est \\(13\\), il indique quel driver est utilis\u00e9 le mineur est \\(33\\) : il indique quel p\u00e9riph\u00e9rique est ici g\u00e9r\u00e9 par ce driver.</p>"},{"location":"Linux/2-Fichiers/#les-fichiers","title":"Les fichiers","text":""},{"location":"Linux/2-Fichiers/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":"<p>Sous Linux, consid\u00e9rons un fichier :</p> <ul> <li>Il est toujours d\u00e9sign\u00e9 par un nom</li> <li>Il poss\u00e8de un unique inode (certaines informations concernant le fichier). C'est une structure cr\u00e9\u00e9e au m\u00eame moment que le fichier afin de contenir ses informations fondamentales. Tous les inodes sont conserv\u00e9s dans une table, et sont identifi\u00e9s par un INumber (num\u00e9ro d'index ou d'inode).</li> <li>Le syst\u00e8me fournit \u00e0 propos de ce fichier des primitives permettant de :<ul> <li>l'ouvrir</li> <li>le fermer</li> <li>le lire</li> <li>le modifier</li> </ul> </li> </ul>"},{"location":"Linux/2-Fichiers/#les-types-de-fichiers","title":"Les types de fichiers","text":"<p>Pour chaque type de fichier, on donne \u00e9galement la convention d'affichage utilis\u00e9e par la commande ls -l nomDuFichier</p> <p>\\(\\color{blue}\\text{ordinaire}\\) : (on dit aussi r\u00e9gulier ou normal). (-)</p> <p>\\(\\color{blue}\\text{r\u00e9pertoire}\\) : ils contiennent seulement la liste des noms des fichiers qui y sont stock\u00e9s ainsi que leurs num\u00e9ros d'inode. (d)</p> <p>\\(\\color{blue}\\text{lien symbolique}\\) : (l)</p> <p>\\(\\color{blue}\\text{pseudo-fichier}\\) :</p> <ul> <li>P\u00e9riph\u00e9riques :<ul> <li>avec acc\u00e8s par caract\u00e8res (c). Exemple : souris, clavier.</li> <li>avec acc\u00e8s par blocs (b). Les p\u00e9riph\u00e9riques blocs (disque dur, lecteurs de DVD) g\u00e8rent une certaine quantit\u00e9 d'information par groupe de bloc.</li> </ul> </li> <li>dispositif de communication (p) pour les canaux de communication des pipes.</li> <li>les sockets (s) (r\u00e9seaux)</li> </ul>"},{"location":"Linux/2-Fichiers/#peripheriques_1","title":"P\u00e9riph\u00e9riques","text":"<p>Dans /dev/input on trouve la plupart des p\u00e9riph\u00e9riques d'entr\u00e9es sur l'ordinateur (mais pas tous -par ex. : les microphones-).</p> <p>Ci-dessous, les event repr\u00e9sentent des \u00e9v\u00e8nements en rapport avec le clavier (m\u00eame en rapport lointain, ma webcam est consid\u00e9r\u00e9e comme faisant partie du clavier !) et mouse...</p> <pre><code>$ls \u2212l /dev/input/\ncrw\u2212rw\u2212\u2212\u2212\u22121 root input 13,74 ao\u00fbt 19 09:57 event10\ncrw\u2212rw\u2212\u2212\u2212\u22121 root input 13,75 ao\u00fbt 19 09:57 event11\n...\ncrw\u2212rw\u2212\u2212\u2212\u22121 root input 13,32 ao\u00fbt 19 09:57 mouse0\ncrw\u2212rw\u2212\u2212\u2212\u22121 root input 13,33 ao\u00fbt 19 09:57 mouse1\n</code></pre> <p>La souris est bien un p\u00e9riph\u00e9rique en mode caract\u00e8re (la premi\u00e8re lettre de la ligne). L'\u00e9v\u00e8nement \\(11\\) est curieusement associ\u00e9 \u00e0 ma cam\u00e9ra (comme on peut le voir en entrant xinput list)</p>"},{"location":"Linux/2-Fichiers/#bloc","title":"Bloc","text":"<p>Bloc</p> <p>Un bloc (ou en anglais cluster) est la plus petite unit\u00e9 de stockage du syst\u00e8me de fichiers d'une m\u00e9moire de masse. Le choix de la taille de bloc est effectu\u00e9 lors du formatage, et influe sur les performances et sur la capacit\u00e9 utile.</p> <p>Bloc logique</p> <p>Le bloc logique est la plus petite unit\u00e9 transf\u00e9rable (en lecture/\u00e9criture) du disque. Sa taille peut \u00eatre diff\u00e9rente de celle d'un bloc physique.</p> <p>Syt\u00e8me de fichiers</p> <p>Un syst\u00e8me de fichiers est une s\u00e9quence de blocs logiques d\u00e9compos\u00e9es hi\u00e9rarchiquement comme suit :</p> <ul> <li>\\(\\color{blue}\\text{bloc amorce}\\) : contient le chargeur primaire (ou secteur de boot) ;</li> <li>\\(\\color{blue}\\text{superbloc}\\) : informations sur le syst\u00e8me de fichiers ;</li> <li>\\(\\color{blue}\\text{table des inodes}\\) : un inode contient des informations sur un fichier ;</li> <li>\\(\\color{blue}\\text{blocs de donn\u00e9es}\\) : le contenu d'un m\u00eame fichier est r\u00e9parti sur un ou plusieurs blocs.</li> </ul>"},{"location":"Linux/2-Fichiers/#organisation-du-super-bloc","title":"Organisation du super-bloc","text":"<p>On donne avant la d\u00e9finition suivante :</p> <p>Bitmap</p> <p>Pour un disque de \\(n\\) blocs, le bitmap est un tableau de \\(n\\) bits tel que le bit \\(x\\) est \u00e0 \\(0\\) si le bloc \\(x\\) est occup\u00e9 et \u00e0 \\(1\\) sinon.</p> <p>Un super-bloc contient les informations suivantes</p> <ul> <li>nombre total de blocs de la partition ;</li> <li>nombre et bitmap de blocs libres ;</li> <li>nombre total d'inodes ;</li> <li>nombre d'inodes libres ;</li> <li>t\u00eate de la liste cha\u00een\u00e9e des inodes libres.</li> </ul>"},{"location":"Linux/2-Fichiers/#vue-dun-disque-logique","title":"Vue d'un disque logique","text":"<p>Figure 4 \u2013 Un disque logique</p>"},{"location":"Linux/2-Fichiers/#inodes","title":"Inodes","text":"<p>Noeud d'index ou inode</p> <p>Un noeud d'index ou inode (contraction de l'anglais index et node) est une structure de donn\u00e9es contenant des informations \u00e0 propos d'un fichier ou r\u00e9pertoire.</p> <p>\u00c0 chaque fichier correspond un num\u00e9ro d'inode (i-number) dans le syst\u00e8me de fichiers dans lequel il r\u00e9side, unique dans la partition sur laquelle est situ\u00e9e le syst\u00e8me de fichiers.</p> <p>Chaque fichier a un seul inode mais peut avoir plusieurs noms (lesquels font r\u00e9f\u00e9rence au m\u00eame inode). Un nom de fichier est aussi appel\u00e9 un lien.</p> <p>Les inodes contiennent toutes les informations sur les fichiers \u00e0 part le ou les noms.</p> <p>Les inodes sont cr\u00e9\u00e9s en m\u00eame temps que le syst\u00e8me de fichier auxquels ils appartiennent. Leur nombre est donc fixe et d\u00e9pend de la taille de la partition \u00e0 laquelle est associ\u00e9 le syst\u00e8me de fichier.</p>"},{"location":"Linux/2-Fichiers/#connaitre-linode-dun-fichier","title":"Conna\u00eetre l'inode d'un fichier","text":"<p>Pour conna\u00eetre le num\u00e9ro d'inode d'un fichier :</p> <pre><code>$ls \u2212i asup # num d'inode du fichier asup\n10224747 asup\n</code></pre>"},{"location":"Linux/2-Fichiers/#nombre-dinodes-utilisees","title":"Nombre d'inodes utilis\u00e9es","text":"<p>On a des informations sur les inodes utilis\u00e9s par les partitions avec df -i :</p> <pre><code>$df \u2212i\nSys. de fichiers Inoeuds IUtil. ILibre IUti% Mont\u00e9 sur\nudev 2016836 580 2016256 1% /dev\ntmpfs 2032479 1076 2031403 1% /run\n/dev/nvme0n1p5 31227904 736385 30491519 3% /\ntmpfs 2032479 1 2032478 1% /dev/shm\ntmpfs 2032479 5 2032474 1% /run/lock\ntmpfs 2032479 18 2032461 1% /sys/fs/cgroup\n/dev/loop1 10803 10803 0 100% /snap/core18/2074\n/dev/loop2 293 293 0 100% /snap/discord/122\n</code></pre>"},{"location":"Linux/2-Fichiers/#champs-dun-inode","title":"Champs d'un inode","text":"<p>Les inodes sont tous de m\u00eame taille et contiennent les informations suivantes :</p> <ul> <li>type du fichier (- d l c p b...)</li> <li>droits d'acc\u00e8s ou mode (-rw-rw-r\u2013)</li> <li>nombres de liens physiques sur le fichier</li> <li>num\u00e9ro de l'utilisateur et du groupe auquel appartient le fichier.</li> <li>Taille en byte du fichier</li> <li>Deux tableaux contenant un total de \\(13\\) \"adresses disques\" (ce sont des pointeurs) (\\(13\\) pour le standard ext2, \\(15\\) pour ext4). \\(10\\) adresses directes, une adresse indirecte \u00e0 un niveau d'indirection, une adresse indirecte \u00e0 deux niveaux d'indirection et une adresse indirecte \u00e0 trois niveaux.</li> <li>Informations de dates :<ul> <li>date et heure (ctime) de derni\u00e8re modification de l'inode (ls -lc)</li> <li>derni\u00e8re date et heure (mtime) auxquelles le fichier a \u00e9t\u00e9 modifi\u00e9 (ls -l)</li> <li>date et heure (atime) de cr\u00e9ation (ls -lu)</li> </ul> </li> </ul> <pre><code>UFS$ls \u2212lu slides ufs.tex\n\u2212rw\u2212rw\u2212r\u2212\u22121 ivan ivan 42531 janv. 9 2023 slides ufs.tex\nUFS$ls \u2212lc slides ufs.tex\n\u2212rw\u2212rw\u2212r\u2212\u22121 ivan ivan 42531 janv. 17 10:43 slides ufs.tex\n$ls \u2212l slides ufs.tex\n\u2212rw\u2212rw\u2212r\u2212\u22121 ivan ivan 42531 janv. 17 10:43 slides ufs.tex\n</code></pre>"},{"location":"Linux/2-Fichiers/#vue-schematique-pour-le-format-ext4","title":"Vue sch\u00e9matique pour le format ext4","text":"<p>Figure 5 \u2013 Une inode avec ses liens directs et les indirections de niveau 1,2,3 (cf SCO Group)</p>"},{"location":"Linux/2-Fichiers/#taille-maximale-dun-fichier-regulier","title":"Taille maximale d'un fichier r\u00e9gulier","text":"<p>En exercice</p>"},{"location":"Linux/2-Fichiers/#ajouter-deplacer-supprimer-lier","title":"Ajouter, d\u00e9placer, supprimer, lier","text":"<p>Figure 6 \u2013 Un r\u00e9pertoire contenant un fichier toto</p> <p><p></p></p>"},{"location":"Linux/2-Fichiers/#copier","title":"Copier","text":"<p>Figure 7 \u2013 cp toto titi duplique les donn\u00e9es de toto. Un inode autre que celui de toto pointe sur les donn\u00e9es dupliqu\u00e9es.</p>"},{"location":"Linux/2-Fichiers/#renommage-ou-deplacement","title":"Renommage ou d\u00e9placement","text":"<p>Figure 8 \u2013 D\u00e9placement mv toto R2/titi : par rapport \u00e0 la figure \\(6\\), titi de R2 (inode \\(236\\)) \\(\\underline{\\textsf{est}}\\) l'ancien toto de R1 (inode \\(128\\))</p>"},{"location":"Linux/2-Fichiers/#lien-physique","title":"Lien physique","text":"<p>Lien physique</p> <p>Un lien physique est une r\u00e9f\u00e9rence directe \u00e0 un fichier via son inode.</p> <p>Avantage : On peut changer le contenu ou la localisation du fichier original, le lien physique restera valide.</p> <p>Inconv\u00e9nient : un lien physique r\u00e9f\u00e9rence un num\u00e9ro d'inode ce qui impose de rester dans la m\u00eame partition (en effet : deux disques logiques diff\u00e9rents peuvent avoir chacun une inode \\(47\\)).</p> <p>Inconv\u00e9nient : on ne peut pas faire un lien physique avec un r\u00e9pertoire.</p> <p>syntaxe : ln toto ../R2/titi.</p> <p>Je peux changer toto de place (dans la m\u00eame partition), le lien entre toto et titi ne dispara\u00eet pas.</p> <p></p> <p>Figure 9 \u2013 Lien physique : Dans le r\u00e9pertoire courant, on entre ln toto R2/titi : titi et toto pointent vers le m\u00eame inode. Pas de duplication des donn\u00e9es.</p> <p>Situation initiale : un fichier toto de \\(121\\) octets et \\(1\\) seul alias.</p> <pre><code>$ls \u2212ali toto\n2373803 \u2212rw\u2212rw\u2212r\u2212\u22121 ivan ivan 121 janv. 11 22:03 toto\n</code></pre> <p>Cr\u00e9ation d'un lien symbolique :</p> <pre><code>$ln toto titi\n$ls \u2212ali toto\n2373803 \u2212rw\u2212rw\u2212r\u2212\u22122 ivan ivan 121 janv. 11 22:03 toto\n(base) ivan@fixe: \u0303/.../UFS$ls \u2212ali titi\n2373803 \u2212rw\u2212rw\u2212r\u2212\u22122 ivan ivan 121 janv. 11 22:03 titi\n</code></pre> <p>Le nombre d'alias de toto est maintenant \\(2\\). toto et titi partagent le m\u00eame inode \\(2373803\\).</p>"},{"location":"Linux/2-Fichiers/#suppression-et-inode","title":"Suppression et inode","text":"<p>En supprimant un fichier (rm pour remove), tout ce qui se passe est la suppression de l'un des noms pointant vers un num\u00e9ro d'inode sp\u00e9cifique.</p> <p>Les donn\u00e9es resteront jusqu'\u00e0 la suppression de tous les noms associ\u00e9s au m\u00eame num\u00e9ro d'inode. Les syst\u00e8mes Linux se mettent \u00e0 jour sans n\u00e9cessiter de red\u00e9marrage du syst\u00e8me en grande partie \u00e0 cause du fonctionnement des inodes.</p> <p>Dans la situation de l'exemple pr\u00e9c\u00e9dent , entrons rm toto : l'inode de toto n'est pas lib\u00e9r\u00e9 puisque le lien de titi existe toujours. Voir figure \\(10\\) ci dessous .</p> <p>Entrons rm titi. Les blocs de donn\u00e9es et l'inode correspondant sont lib\u00e9r\u00e9s : le syst\u00e8me pourra les attribuer \u00e0 d'autres fichiers. Voir figure \\(11\\).</p> <p><p></p></p> <p>Figure 10 \u2013 Suppression rm toto : l'inode \\(47\\) et ses donn\u00e9es ne sont pas lib\u00e9r\u00e9s</p> <p><p></p></p> <p>Figure 11 \u2013 Suppression rm titi : l'inode \\(47\\) et ses donn\u00e9es sont lib\u00e9r\u00e9es</p>"},{"location":"Linux/2-Fichiers/#lien-symbolique","title":"Lien symbolique","text":"<p>Lien symbolique</p> <p>Un lien symbolique est une r\u00e9f\u00e9rence \u00e0 un nom (i.e. un chemin absolu ou relatif). Tandis qu'un lien physique r\u00e9f\u00e8re plut\u00f4t un inode.</p> <p>Avec un lien symbolique on peut traverser les partitions.</p> <p>Cr\u00e9ation avec l'option s de ln : ln -s /path/to/original symlink. Par exemple ln -s R1/toto titi cr\u00e9e un lien symbolique entre titi du r\u00e9pertoire courant et toto du r\u00e9pertoire R1.</p> <p>Par d\u00e9faut, le lien symbolique doit \u00eatre cr\u00e9\u00e9 dans le r\u00e9pertoire courant. Si on veut sp\u00e9cifier aussi un chemin relatif pour le lien symbolique, utiliser l'option r :</p> <pre><code>\u2212r, \u2212\u2212relative\ncreate symbolic links relative to link location\n</code></pre> <p>ln -sr R1/toto R2/titi. Voir la figure 12 ci-dessous.</p> <p>Si on d\u00e9place ou renomme la source, le lien est cass\u00e9.</p> <p></p> <p>Figure 12 - Lien symbolique ln -sr R1/toto R2/titi</p> <pre><code>$stat toto\nFichier: toto\nTaille: 121 Blocs: 8 Blocs d'E/S: 4096 fichier\n...\n$ln \u2212s toto lstoto\n$ls \u2212al toto lstoto\nlrwxrwxrwx 1 ivan ivan 4 janv. 17 11:33 lstoto \u2212&gt;toto\n\u2212rw\u2212rw\u2212r\u2212\u22122 ivan ivan 121 janv. 11 2023 toto\n$stat lstoto\nFichier: lstoto \u2212&gt;toto\nTaille: 4 Blocs: 0 Blocs d'E/S: 4096 lien symbolique\n</code></pre> <p>La taille de toto est de \\(121\\) bytes (\\(121\\) carcat\u00e8res), celle du lien symbolique de \\(4\\).</p> <p>On constate que la premi\u00e8re lettre du retour de ls est l. Et qu'un lien symbolique poss\u00e8de tous les droits par d\u00e9faut.</p>"},{"location":"Linux/3-Droits/","title":"Acc\u00e8s droits et attributs sous Linux","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Avant-propos</p> <ul> <li>La documentation Ubuntu</li> </ul>"},{"location":"Linux/3-Droits/#proprietaire","title":"Propri\u00e9taire","text":"<p>Le propri\u00e9taire d'un fichier est l'utilisateur qui le poss\u00e8de. C'est souvent l'auteur du fichier mais pas toujours. Il y a trois degr\u00e9s de possession d'un fichier :</p> <ul> <li>\\(\\color{blue}\\text{l'}\\textit{utilisateur}\\) du fichier (u). C'est souvent le propri\u00e9taire. Remarquons qu'un fichier cr\u00e9\u00e9 avec la commande sudo appartient \u00e0 l'utilisateur root.</li> <li>\\(\\color{blue}\\text{le }\\textit{groupe propri\u00e9taire}\\) du fichier (g). Si un utilisateur est membre d'un groupe qui poss\u00e8de la propri\u00e9t\u00e9 d'un fichier, l'utilisateur aura aussi certaines permissions sur ce fichier.</li> <li>\\(\\color{blue}\\text{les }\\textit{autres}\\) (ou other (o)). Tous ceux qui ne sont pas dans le groupe propri\u00e9taire du fichier.</li> </ul> <p>L'attribut de propri\u00e9t\u00e9 d'un fichier prend donc \\(3\\) valeurs : u,g,o.</p>"},{"location":"Linux/3-Droits/#permissions","title":"Permissions","text":"<p>Les permissions d\u00e9signent ce que les diverses cat\u00e9gories d'utilisateurs ont l'autorisation d'effectuer sur un fichier donn\u00e9 (lecture, \u00e9criture, ex\u00e9cution). Il y a \\(3\\) cat\u00e9gories de permission : lecture (r), \u00e9criture (w) et eX\u00e9cution (x).</p>"},{"location":"Linux/3-Droits/#pour-un-fichier-regulier","title":"Pour un fichier r\u00e9gulier","text":"<ul> <li>\\(\\color{blue}\\text{lecture}\\) : N\u00e9cessaire pour pouvoir acc\u00e9der au contenu d'un fichier (\u00e9couter une piste audio, visionner un film, lire un texte). Notation r (pour Read, lire).</li> <li>\\(\\color{blue}\\text{\u00e9criture}\\) : N\u00e9cessaire pour pouvoir apporter des modifications \u00e0 un fichier (corriger un texte et enregistrer les changements ; effacer les yeux rouges dans une photo et enregistrer la correction etc.). Notation w (pour Write, \u00e9crire).</li> <li>\\(\\color{blue}\\text{ex\u00e9cution}\\) : N\u00e9cessaire pour les programmes, afin qu'ils puissent \u00eatre ex\u00e9cut\u00e9s. Cette permission est not\u00e9e x (pour eXecute, ex\u00e9cuter).</li> </ul>"},{"location":"Linux/3-Droits/#pour-un-repertoire","title":"Pour un r\u00e9pertoire","text":"<ul> <li>\\(\\color{blue}\\text{lecture}\\) : les droits en lecture permettent de lister le contenu d'un r\u00e9pertoire</li> <li>\\(\\color{blue}\\text{\u00e9criture}\\) : les droits en \u00e9criture signifient qu'on peut modifier le contenu donc ajouter, modifier, renommer ou supprimer un fichier dans un dossier.</li> <li>\\(\\color{blue}\\text{ex\u00e9cution}\\) : Pour un r\u00e9pertoire, la permission x permet d'en faire le r\u00e9pertoire courant et donc d'y acc\u00e9der par cd</li> </ul> <p>Supposons que l'utilisateur toto dispose des droits de lecture et d'ex\u00e9cution sur le r\u00e9pertoire Foo mais pas du droit d'\u00e9criture. Alors toto peut lister le contenu de Foo et se rendre dans Foo ex\u00e9cuter les programmes contenus dans Foo et lire leur contenu. Mais il ne peut pas ajouter/supprimer de fichiers dans Foo.</p>"},{"location":"Linux/3-Droits/#9-caracteres-pour-definir-tous-les-droits","title":"\\(9\\) caract\u00e8res pour d\u00e9finir tous les droits","text":"<p>Pour chacune des trois cat\u00e9gories d'utilisateurs (propri\u00e9taire, membres du groupe propri\u00e9taire et reste du monde) sont d\u00e9finies ces trois permissions :</p> <ul> <li>le propri\u00e9taire dispose ou non de la permission de lecture, d'\u00e9criture et d'ex\u00e9cution sur un fichier,</li> <li>le membre du groupe propri\u00e9taire dispose ou non de la permission de lecture, d'\u00e9criture et d'ex\u00e9cution sur un fichier,</li> <li>tous les autres utilisateurs disposent ou non de la permission de lecture, d'\u00e9criture et d'ex\u00e9cution sur un fichier.</li> </ul> <p>Les droits sont donc affich\u00e9s par une s\u00e9rie de \\(9\\) caract\u00e8res, associ\u00e9s \\(3\\) par \\(3\\) (rwx rwx rwx) qui d\u00e9finissent les droits des \\(3\\) identit\u00e9s (u, g ,o dans cet ordre).</p> <p>Il y a encore deux droits sp\u00e9ciaux s,t (hors programme), qu'on n'aborde pas ici.</p>"},{"location":"Linux/3-Droits/#droits-speciaux-hors-programme","title":"Droits sp\u00e9ciaux (Hors Programme)","text":"<p>Le bit Set-User-ID permet \u00e0 un utilisateur d'ex\u00e9cuter le programme avec les droits du propri\u00e9taire, c'est ainsi que sudo nous permet d'ex\u00e9cuter des commandes en \u201droot\u201d</p> <pre><code>$ls \u2212l /usr/bin | grep sudo\n\u2212rwsr\u2212xr\u2212x 1 root root 166056 avril 4 2023 sudo\n</code></pre> <p>le bit Set-Group-ID agit comme Set-User-ID mais pour le groupe</p> <pre><code>$ls \u2212l /usr/bin | grep ssh\u2212agent\n\u2212rwxr\u2212sr\u2212x 1 root ssh 350504 janv. 2 18:13 ssh\u2212agent\n</code></pre> <p>Le bit \"restriction de suppression \"ou Sticky permet quant \u00e0 lui de restreindre la suppression d'un fichier ou r\u00e9pertoire \u00e0 son seul propri\u00e9taire. C'est le cas du r\u00e9pertoire /tmp :</p> <pre><code>$ls \u2212ld /t\u2217/\ndrwxrwxrwt 21 root root 36864 janv. 24 11:46 /tmp/\n</code></pre> <p>Le t au lieu du x pour les autres utilisateurs nous informe que ce r\u00e9pertoire ne peut \u00eatre supprim\u00e9 que par l'utilisateur root</p> <p>On peut donc en mode octal accorder ces droits sp\u00e9ciaux en ajoutant une quatri\u00e8me information. Pour activer le sticky bit et le Set-GroupID sur le script renomme mes photos.sh, on entre :</p> <pre><code>$chmod 3777 renomme mes photos.sh\n</code></pre>"},{"location":"Linux/3-Droits/#notations-octales","title":"Notations octales","text":"<p>Chaque groupe de trois caract\u00e8res de permissions (comme rw- ou \u2013x) est repr\u00e9sent\u00e9 par un chiffre entre \\(0\\) et \\(7\\) et chaque droit correspond \u00e0 une valeur :</p> <ul> <li>r (read) = \\(4\\)</li> <li>w (write) = \\(2\\)</li> <li>x (execute) = \\(1\\)</li> <li>- = \\(0\\)</li> <li>Par exemple pour le triplet :<ul> <li>rwx, on a : \\(4+2+1=7\\)</li> <li>rw-, on a : \\(4+2+0=6\\)</li> <li>r\u2013, on a : \\(4+0+0=4\\)</li> </ul> </li> </ul> <p>On obtient ainsi toutes les combinaisons :</p> 0 - - - (aucun droit) 1 - - x (ex\u00e9cution) 2 - w - (\u00e9criture) 3 - w x (\u00e9criture et ex\u00e9cution) 4 r - - (lecture seule) 5 r - x (lecture et ex\u00e9cution) 6 r w - (lecture et \u00e9criture) 7 r w x (lecture, \u00e9criture et ex\u00e9cution) <p>Consid\u00e9rons un r\u00e9pertoire dont les attributs sont drwxr- x- - - (\"d\" pour r\u00e9pertoire) :</p> <ul> <li>r w x : (\\(4+2+1\\)) soit \\(7\\)</li> <li>r - x : (\\(4+0+1\\)) soit \\(5\\)</li> <li>- - - : (\\(0+0+0\\)) soit \\(0\\)</li> <li>les droits de ce r\u00e9pertoire sont donc r\u00e9sum\u00e9s par le nombre \\(750\\)</li> </ul>"},{"location":"Linux/3-Droits/#changer-les-droits-dun-fichier","title":"Changer les droits d'un fichier","text":"<p>L'outil chmod (de \"change mode\" en anglais) permet de modifier les permissions sur un fichier. Il s'emploie de deux fa\u00e7ons :</p> <ul> <li>soit en pr\u00e9cisant les permissions de mani\u00e8re octale : on entre alors une suite de trois chiffres entre 0 et 7 pour d\u00e9signer l'utilisateur, son groupe et le reste du monde.</li> <li>soit en pr\u00e9cisant \u00e0 qui s'adresse le changement et en ajoutant ou retirant des permissions</li> </ul> <p>En g\u00e9rant les droits s\u00e9par\u00e9ment, on choisit dans l'ordre :</p> <ul> <li>\\(\\color{blue}\\text{Qui est concern\u00e9}\\) : cela peut \u00eatre<ul> <li>u (user, utilisateur) repr\u00e9sente la cat\u00e9gorie \u201dpropri\u00e9taire\u201d,</li> <li>g (group, groupe) repr\u00e9sente la cat\u00e9gorie \u201dgroupe propri\u00e9taire\u201d,</li> <li>o (others, autres) repr\u00e9sente la cat\u00e9gorie \u201dreste du monde\u201d,</li> <li>a (all, tous) repr\u00e9sente l'ensemble des trois cat\u00e9gories.</li> </ul> </li> <li>\\(\\color{blue}\\text{La modification}\\) : ajouter ou supprimer<ul> <li>+ pour ajouter un droit</li> <li>- pour supprimer un droit</li> <li>= pour \u00e9craser les \\(3\\) droits et en mettre de nouveaux</li> </ul> </li> <li>\\(\\color{blue}\\text{Le droit modifi\u00e9}\\) : r, w ou x</li> </ul> <ul> <li>chmod o=r myfile : donne les droits de lecture (et pas au groupe ni au propri\u00e9taire) aux autres utilisateurs sans se pr\u00e9occuper des anciens droits qu'avait o.</li> <li>chmod 644 myfile : droit utilis\u00e9 traditionnellement sur les fichiers. Donne au propri\u00e9taire les droits de modification et lecture, aux membres du groupe et aux autres uniquement les droits de lecture.</li> <li>chmod 755 mydir : droit utilis\u00e9 traditionnellement sur les r\u00e9pertoires. Donne au propri\u00e9taire tous les droits, aux membres du groupe et aux autres les droits de lecture (par ls) et d'acc\u00e8s (par cd).</li> <li>chmod u+x myfile : donne au propri\u00e9taire les droits d'ex\u00e9cutions sur myfile. chmod a+x myfile donne \u00e0 tout le monde les droits d'ex\u00e9cution.</li> <li>chmod -R a+rx mydir : donne \u00e0 tous les utilisateurs les droits en lecture et en ex\u00e9cution \u00e0 tout ce que contient le dossier mydir.</li> </ul> <p>Exercice</p> <ul> <li>\u00c9crire un fichier de script bash myscript.sh qui affiche \"coucou\" \u00e0 l'\u00e9cran (la premi\u00e8re ligne d'un tel fichier est \\(\\texttt{\\#!/bin/bash}\\)). Cela doit se faire en une seule ligne de commande sans ouvrir \\(\\texttt{vim}\\), \\(\\texttt{nano}\\), \\(\\texttt{gedit}\\) ou \\(\\texttt{emacs}\\).</li> <li>L'ex\u00e9cuter avec .\\myscript.sh. Que constate-t-on ?</li> <li>Rem\u00e9dier \u00e0 ce probl\u00e8me.</li> </ul>"},{"location":"Linux/4-Redirections/","title":"Redirections","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Un cours sur les fichiers de Bernard Goossens</li> <li>Une page de Wikipedia</li> </ul>"},{"location":"Linux/4-Redirections/#table-des-descripteurs-de-fichiers-des-fichiers-ouvert-des-inodes-libres","title":"Table des descripteurs de fichiers, des fichiers ouvert, des inodes libres","text":""},{"location":"Linux/4-Redirections/#tdf-tfo","title":"TDF, TFO","text":"<p>Dans POSIX, Un descripteur de fichier est un entier qui d\u00e9signe une position dans une table appel\u00e9e table des descripteurs de fichiers (TDF).</p> <p>Chaque processus (c'est \u00e0 dire un programme en cours d'ex\u00e9cution) est cr\u00e9\u00e9 avec sa propre TDF : elle indique les fichiers utilis\u00e9s par ce processus. Il y a donc une TDF par processus.</p> <p>Ce qui nous int\u00e9resse ici, ce sont les \\(3\\) premi\u00e8res entr\u00e9es de la TDF : les \\(3\\) flux standards.</p> <p>A chaque entr\u00e9e de la TDF on trouve une structure qui contient un champ d'attributs du descripteur (des informations sur le fichier correspondant) et un pointeur vers la table des fichiers ouverts (TFO), laquelle est unique pour le syst\u00e8me.</p> <p>Il y a donc dans le syst\u00e8me une seule TFO et une multitude de TDF (une pour chaque processus).</p>"},{"location":"Linux/4-Redirections/#tfo-tim","title":"TFO, TIM","text":"<p>Chaque entr\u00e9e de la TFO se compose</p> <ul> <li>d'un champ compteur de r\u00e9f\u00e9rences (nombre de pointeurs tdf) sur cette entr\u00e9e,</li> <li>d'un champ mode d'ouverture du fichier (lecture, \u00e9criture, etc.),</li> <li>d'un champ de position dans le fichier (d\u00e9placement en octet par rapport au d\u00e9but)</li> <li>et d'un champ pointeur sur la table des inodes en m\u00e9moire (TIM)</li> </ul> <p>A leur tour les entr\u00e9es de la TFO pointent vers une table des inodes en m\u00e9moire, laquelle est \u00e9galement unique.</p> <p>Les \u00e9l\u00e9ments de le TIM sont des structures qui contiennent</p> <ul> <li>des informations sur le nombre de pointeurs TFO vers cet inode,</li> <li>le device de l'inode (quel disque ou partition),</li> <li>son num\u00e9ro,</li> <li>son statut (modifi\u00e9 ou non),</li> <li>une copie de l'inode et notamment de sa table des blocs.</li> </ul>"},{"location":"Linux/4-Redirections/#les-3-premieres-entrees-de-la-tdf-posix","title":"Les 3 premi\u00e8res entr\u00e9es de la TDF (POSIX)","text":"<p>Le programme de MP2I ne mentionne que les \\(3\\) premi\u00e8res entr\u00e9es de la TDF. Elles correspondent aux flux standards (voir figure \\(\\color{red}1\\)) :</p> <ul> <li>l'entr\u00e9e standard ou point de lecture des processus en avant-plan. C'est un tuyau de donn\u00e9es (flux), que l'on branche sur un p\u00e9riph\u00e9rique. Elle est repr\u00e9sent\u00e9e par la constante STDIN_FILENO qui vaut \\(0\\). Par d\u00e9faut, ce flux est associ\u00e9 au clavier.</li> <li>La sortie standard ou point d'\u00e9criture des processus en avant-plan. C'est un flux qui est repr\u00e9sent\u00e9 par la constante STDOUT FILENO, laquelle vaut \\(1\\). Par d\u00e9faut, ce flux est associ\u00e9 \u00e0 la console d'o\u00f9 l'application \u00e0 \u00e9t\u00e9 lanc\u00e9e.</li> <li>la sortie standard d'erreur ou point d'\u00e9criture des erreurs des processus en avant-plan. C'est un flux repr\u00e9sent\u00e9 par la constante STDERR_FILENO qui vaut \\(2\\). Par d\u00e9faut, ce flux est associ\u00e9 \u00e0 la console d'o\u00f9 l'application \u00e0 \u00e9t\u00e9 lanc\u00e9e.</li> </ul>"},{"location":"Linux/4-Redirections/#les-3-premieres-entrees-de-la-tdf","title":"Les 3 premi\u00e8res entr\u00e9es de la TDF","text":"<p>Figure 1 \u2013 Les descripteurs de fichiers pour l'entr\u00e9e, la sortie et les erreurs (d'apr\u00e8s Wikipedia).Par d\u00e9faut, quand un programme fonctionne dans un terminal, l'entr\u00e9e standard correspond au clavier, et la sortie standard ainsi que l'erreur standard sont affich\u00e9es dans ce terminal.</p>"},{"location":"Linux/4-Redirections/#lien-avec-le-c","title":"Lien avec le C","text":"<p>Le fichier d'en-t\u00eate stdio.h de la biblioth\u00e8que standard du C d\u00e9finit trois pointeurs de type FILE* qui repr\u00e9sentent les flux standard :</p> <ul> <li>stdin pour l'entr\u00e9e standard,</li> <li>stdout pour la sortie standard,</li> <li>stderr pour l'erreur standard.</li> </ul> <p>Ces pointeurs peuvent \u00eatre utilis\u00e9s directement avec la majorit\u00e9 des fonctions qui agissent sur les fichiers. Par exemple :</p> <ul> <li>La fonction scanf utilise le flux stdin.</li> <li>La fonction printf utilise le flux stdout.</li> </ul>"},{"location":"Linux/4-Redirections/#les-redirections","title":"Les Redirections","text":""},{"location":"Linux/4-Redirections/#rappel","title":"Rappel","text":"<p>Pour dialoguer avec son ordinateur, on utilise un terminal. Par d\u00e9faut les commandes du terminal r\u00e9cup\u00e8rent les donn\u00e9es tap\u00e9es par l'utilisateur au clavier. Le r\u00e9sultat de leur ex\u00e9cution s'affiche \u00e0 l'\u00e9cran. En cas d'erreur \u00e0 l'ex\u00e9cution, les messages d'erreur apparaissent aussi \u00e0 l'\u00e9cran.</p>"},{"location":"Linux/4-Redirections/#redirections-dentreessorties","title":"Redirections d'entr\u00e9es/sorties","text":"<p>Il est possible d'indiquer au terminal que des donn\u00e9es en entr\u00e9e ou sortie doivent \u00eatre r\u00e9cup\u00e9r\u00e9es/stock\u00e9es dans un fichier plut\u00f4t qu'au clavier ou \u00e0 l'\u00e9cran. Voici la syntaxe des commandes de redirection :</p> <ul> <li>\\(&lt;\\)entree signifie que les donn\u00e9es de la commande seront lues dans le fichier de nom entree plut\u00f4t qu'au clavier. On veut qu'un fichier soit l'entr\u00e9e d'une commande qui, normalement, n'accepte pas un fichier comme option.</li> <li>\\(&gt;\\)sortie signifie que les donn\u00e9es g\u00e9n\u00e9r\u00e9es par la commande seront \u00e9crites dans le fichier de nom sortie plut\u00f4t qu'\u00e0 l'\u00e9cran. Si le fichier sortie existait d\u00e9j\u00e0, son ancien contenu est effac\u00e9, sinon ce fichier est cr\u00e9\u00e9 au lancement de la commande.</li> <li>\\(&gt;&gt;\\)sortie semblable au cas pr\u00e9c\u00e9dent sauf que si le fichier sortie existait d\u00e9j\u00e0, son ancien contenu est conserv\u00e9 et les nouvelles donn\u00e9es sont copi\u00e9es \u00e0 la suite.</li> </ul>"},{"location":"Linux/4-Redirections/#redirections-derreurs","title":"Redirections d'erreurs","text":"<ul> <li>2\\(&gt;\\)erreur signifie que les messages d'erreur g\u00e9n\u00e9r\u00e9s par la commande seront \u00e9crits dans le fichier de nom erreur plut\u00f4t qu'\u00e0 l'\u00e9cran. Si le fichier erreur existait d\u00e9j\u00e0, son ancien contenu est effac\u00e9, sinon ce fichier est cr\u00e9\u00e9 au lancement de la commande.</li> <li>2\\(&gt;&gt;\\)erreur semblable au cas pr\u00e9c\u00e9dent sauf que si le fichier erreur existait d\u00e9j\u00e0, son ancien contenu est conserv\u00e9 et les nouveaux messages d'erreur sont copi\u00e9s \u00e0 la suite.</li> </ul> <p>Redirection d'entr\u00e9e</p> <pre><code>ivan@fixe: ~/.../UFS$touch file.txt\nivan@fixe: ~/.../UFS$echo \u201dHello world\u201d &gt;file.txt\nivan@fixe: ~/.../UFS$cat file.txt\nHello world\nivan@fixe: ~/.../UFS$wc \u2212l file.txt\n1 file.txt\nivan@fixe: ~/.../UFS$wc \u2212l &lt;file.txt\n1\n</code></pre> <ul> <li>On cr\u00e9e un fichier vide (touch file.txt) dont on \u00e9crit une ligne avec echo \u201dHello world\u201d &gt;file.txt</li> <li>La commande wc -l file.txt compte le nombre de ligne d'un fichier et affiche le nom de ce fichier.</li> <li>Avec la redirection \\(&lt;\\), on redirige l'entr\u00e9e standard vers file.txt. On obtient <code>1</code> comme sortie puisque la commande supppose qu'elle prend son entr\u00e9e dans <code>stdin</code> plut\u00f4t que dans un fichier. Le nom de fichier a disparu !</li> </ul>"},{"location":"Linux/4-Redirections/#fusion-des-sorties-et-des-erreurs","title":"Fusion des sorties et des erreurs","text":"<p>Supposons que dans un r\u00e9pertoire on dispose d'un fichier asup mais pas de asip.</p> <ul> <li>La commande ls -l asup asip va afficher avec succ\u00e8s les attributs de asup mais va exprimer une erreur pour asip.</li> </ul> <pre><code>$ls \u2212l asup asip\nls: impossible d'acc\u00e9der \u00e0'asip': Aucun fichier ou dossier de ce type\n\u2212rw\u2212rw\u2212r\u2212\u2212 1 ivan ivan 0 ao\u00fbt 26 2021 asup\n</code></pre> <ul> <li>On veut \u00e9crire dans \\(\\underline{\\textsf{un m\u00eame}}\\) fichier ces deux sorties. On utilise pour cela l'op\u00e9rateur de redirection 2\\(&gt;\\)1&amp; :</li> </ul> <pre><code>$ls \u2212l asup asip &gt;foo 2&gt;&amp;1 # fusion des sorties et erreurs dans foo\n$cat foo # affichage du contenu de foo\nls: impossible d'acc\u00e9der \u00e0'asip': Aucun fichier ou dossier de ce type\n\u2212rw\u2212rw\u2212r\u2212\u2212 1 ivan ivan 0 ao\u00fbt 26 11:15 asup\n</code></pre> <ul> <li>L'instruction ls asup asip 2\\(&gt;\\)foo 1\\(&gt;\\)&amp;2 aurait le m\u00eame effet.</li> </ul> <p>Exercices</p> <p>Exercice \\(1\\) :</p> <p>Ecrire un programme simple.c dont le main fait un affichage mais sans aucune inclusion de biblioth\u00e8que. Le compiler avec gcc et rediriger les erreurs vers un fichier erreursimple.txt</p> <p>Exercice \\(2\\) : </p> <ul> <li>Consulter le manuel de tr</li> <li>Supprimer la lettre \"o\" de tous les mots de myfile</li> </ul> <p>Exercice \\(3\\) :</p> <p>Avec la commande ls lister les droits du contenu du r\u00e9pertoire courant et d'un fichier t_oufoukoa qui n'existe pas. La sortie de ls doit \u00eatre redirig\u00e9e vers un fichier liste_fichiers tandis que les erreurs sont envoy\u00e9es vers erreurls.</p>"},{"location":"Linux/4-Redirections/#les-pipes","title":"Les pipes","text":"<p>Un pipe (mot anglais signifiant \u201dtuyau\u201d) permet de passer le r\u00e9sultat d'une commande shell \u00e0 une autre commande shell.</p> <p>Les donn\u00e9es en sortie d'une commande sont utilis\u00e9es en entr\u00e9e de la commande suivante sans qu'il soit n\u00e9cessaire de recourir \u00e0 des fichiers interm\u00e9diaires.</p>"},{"location":"Linux/4-Redirections/#syntaxe-des-pipes","title":"Syntaxe des pipes","text":"<p>La syntaxe g\u00e9n\u00e9rale pour les pipes est</p> <pre><code>commande1 options arguments | commande2 options | commande3...\n</code></pre> <p>Cette barre verticale, le pipe, s'obtient avec la combinaison de touche <code>ALT GR + 6</code> (touche <code>ALT GR</code> maintenue enfonc\u00e9e pendant qu'on presse <code>6</code>).</p> <p>Par exemple, on liste le contenu du r\u00e9pertoire courant et on envoie le r\u00e9sultat \u00e0 la commande sort avec l'option -r (pour reverse). L'affichage du contenu se fera dans l'ordre alphab\u00e9tique inverse (\u00e0 cause du r) :</p> <pre><code>$ls # affichage habituel de ls\nbla bli foo zut\n$ls | sort \u2212r # trier le r\u00e9sultat dans l'ordre alphab\u00e9tique inverse\nzut\nfoo\nbli\nbla\n</code></pre>"},{"location":"Logique/1-Logique/","title":"Logique","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <p>Wikipedia, Mansuy, Becirspahic.  </p>"},{"location":"Logique/1-Logique/#introduction","title":"Introduction","text":""},{"location":"Logique/1-Logique/#proposition","title":"Proposition","text":"<p>Notion affin\u00e9e au cours des si\u00e8cles.  </p> <p>Une proposition est une construction syntaxique pens\u00e9e parler de  v\u00e9rit\u00e9. La d\u00e9finition pr\u00e9cise de ce concept est l'un des objectifs du  calcul des propositions.  </p> <p>\"Pourvu que je n'attrape pas le Coronavirus !\" exprime un souhait  et pas un fait. Il n'est pas mod\u00e9lis\u00e9 par une proposition.  </p> <p>Il n'y a pas de quantification en calcul des propositions. Ainsi \"M.  Noyer marche sur les eaux\" est exprimable comme une proposition  mais pas \"tous les marseillais marchent sur les eaux\" ni \"il existe  un marseillais qui marche sur les eaux\" (d'ailleurs c'est M. Noyer !)  </p> <p>Le calcul des propositions est la premi\u00e8re \u00e9tape dans la d\u00e9finition de  la logique et du raisonnement. Etape suivante : calcul des pr\u00e9dicats.  </p>"},{"location":"Logique/1-Logique/#contenu-des-propositions","title":"Contenu des propositions","text":"<p>Une proposition donne une information \u00e9valuable sur quelque chose.  </p> <p>Exemple</p> <p>\\(2 + 2 = 4\\) ou \"la maison de Pierre est rose\" ou \"si \\(a \u2264 b\\)  et \\(f(a)f(b) &lt; 0\\) alors il existe \\(c\\in \\left ] a,b \\right [\\) tel que \\(f(c) = 0\\)\".  </p> <p>L'id\u00e9e est qu'on puisse attribuer une valeur de v\u00e9rit\u00e9 \u00e0 toute  proposition.</p> <p>Par exemple \\(2 + 2 = 4\\) a pour valeur Vrai, la seconde phrase est  v\u00e9rifiable en se rendant chez Pierre, la derni\u00e8re d\u00e9pend du type et de  la continuit\u00e9 de \\(f\\) .  </p> <p>Contre-exemple</p> <p>\"\u00c0 quelle heure finit le cours ?\" ou \"Travaille  davantage !\". Ces phrases n'apportent pas d'information.  Il est difficile de leur attribuer une valeur.</p> <p>Les valeurs attribu\u00e9es aux propositions sont en g\u00e9n\u00e9ral \\(0\\) ou \\(1\\), True  ou False, Vrai ou Faux.  </p>"},{"location":"Logique/1-Logique/#logique-classique","title":"Logique classique","text":"<p>C'est celle du cours de maths en CPGE.  </p> <p>Quand le cardinal de l'ensemble des valeurs possibles que peuvent  prendre les propositions est \\(2\\), on parle de logique classique ou  boul\u00e9enne.  </p> <p>Il existe d'autres logiques. Elles sont parfois tri-valu\u00e9es. Par exemple Vrai, Faux, Je ne sais pas.</p> <p>Pourquoi faudrait-il d'autres logiques ? \\(\\color{red} \\text {En logique classique \"je suis ici ou ailleurs\" (= tiers exclu) est toujours vrai.}\\) Cependant \"si \\(x\\in \\mathbb{Q}\\) alors machin  sinon truc\" n'est exploitable que si on poss\u00e8de un test  d'appartenance \u00e0 \\(\\mathbb{Q}\\) en temps fini, ce qui n'est pas le cas. Les logiciens intuitionnistes refusent le tiers exclu.  </p>"},{"location":"Logique/1-Logique/#tiers-exclu","title":"Tiers exclu","text":"<p>Le principe du tiers exclu a \u00e9t\u00e9 introduit par Aristote comme  cons\u00e9quence du principe de non-contradiction. Le principe de  non-contradiction stipule que pour toute proposition \\(P\\) on ne peut pas avoir \\(P\\) et \\(\\neg P\\) (non \\(P\\)) en m\u00eame temps.  </p> <p>La proposition \\(\\neg (P \\wedge  \\neg P)\\) (toujours vraie dans toute les logiques)  \u00e9quivaut s\u00e9mantiquement (par utilisation de r\u00e8gle de De Morgan) \u00e0  \\(\\neg P \\vee  \\neg \\neg P\\). On retrouve le tiers exclu SI ON ACCEPTE que \\(\\neg \\neg P\\) et \\(P\\) sont  s\u00e9mantiquement \u00e9quivalents.  </p>"},{"location":"Logique/1-Logique/#dautres-mathematiques","title":"D'autres math\u00e9matiques","text":"<p>La logique intuitionniste qui engendre les math\u00e9matiques constructives, admet le principe de non-contradiction mais r\u00e9fute celui  du tiers exclu.  </p> <p>Pour un constructiviste, le raisonnement \"si \\(a \\in A\\) alors bla sinon  bli\" n'a de sens que s'il existe un test pour d\u00e9terminer l'appartenance  \u00e0 \\(A\\).  </p> <p>Les constructivistes r\u00e9futent aussi l'axiome du choix qui dit en  substance que \"dans un ensemble infini, je peux choisir un \u00e9l\u00e9ment\", au motif que \"je ne peux pas choisir si je ne sais pas comment choisir\".</p> <p>La plupart des th\u00e9or\u00e8mes de CPGE sont adaptables en  math\u00e9matiques constructives (parfois, les \u00e9nonc\u00e9s sont les m\u00eames,  d'autre fois, il faut adapter). En revanche l'affirmation \"tout \\(\ud835\udd42\\)-espace vectoriel admet une base \" n'est pas constructive (oui pour la dimension finie mais pas en dimension quelconque)  </p> <p>Une preuve de math\u00e9matiques constructives est bien adapt\u00e9e \u00e0  l'informatique en ce sens qu'elle est pratiquement donn\u00e9e sous forme  d'algorithme.  </p>"},{"location":"Logique/1-Logique/#structure-dapres-wikipedia","title":"Structure (d'apr\u00e8s Wikipedia)","text":"<p>Dans les th\u00e9ories de la logique math\u00e9matique, on consid\u00e8re deux  points de vue dits syntaxique et s\u00e9mantique, c'est le cas en calcul des  propositions.  </p> <ul> <li>La forme : Aspect syntaxique. Il s'agit de d\u00e9finir le langage du calcul des propositions par les r\u00e8gles d'\u00e9criture des propositions. On d\u00e9crit donc ce qu'EST une proposition.  </li> <li>Le fond : Aspect s\u00e9mantique. Il s'agit de donner un sens aux symboles repr\u00e9sentant les connecteurs logiques. Il y a deux fa\u00e7ons de donner un tel sens :<ul> <li>Soit par s\u00e9mantique : en munissant d' une interpr\u00e9tation (un sens) les connecteurs logique. On peut alors d\u00e9finir inductivement une interpr\u00e9tation pour toute proposition complexe. Ex: table de v\u00e9rit\u00e9.</li> <li>Soit par d\u00e9duction : On se donne des r\u00e8gles purement syntaxiques qui permettent de d\u00e9duire une proposition d'un ensemble d'autres : les r\u00e8gles d'inf\u00e9rence (Par exemple : calcul des s\u00e9quents ou d\u00e9duction naturelle).   On ne se pr\u00e9occupe donc pas du sens, juste de la d\u00e9ductibilit\u00e9.</li> </ul> </li> </ul>"},{"location":"Logique/1-Logique/#semantique-vs-deduction","title":"S\u00e9mantique VS d\u00e9duction","text":"<p>D\u00e9finition: Une interpr\u00e9tation</p> <p>La fonction \"qui donne du sens\" est appel\u00e9 une interpr\u00e9tation.</p> <p>On construit un arbre d'inf\u00e9rence et on dit qu'une formule est  prouvable si toutes les feuilles de l'arbre sont des axiomes. On appelle th\u00e9or\u00e8me une proposition prouvable.  </p> <p>En calcul des propositions, tout ce qui est vrai est prouvable et  r\u00e9ciproquement.  </p> <p>Si on reste en logique du 1er ordre (en ajoutant quantificateurs,  termes et pr\u00e9dicats au cours de 1ere ann\u00e9e) alors ce qui est vrai est prouvable et r\u00e9ciproquement.  </p>"},{"location":"Logique/1-Logique/#pour-avoir-mal-a-la-tete","title":"Pour avoir mal \u00e0 la t\u00eate","text":"<p>La logique du 1er ordre (telle qu'enseign\u00e9e en MP2I/MPI) est \\(\\color{red}\\text{coh\u00e9rente : on ne peut pas d\u00e9montrer \u00e0 la fois une formule et son contraire}\\); ce qui revient \u00e0 dire qu'on ne peut pas d\u00e9montrer le faux.</p> <p>Le calcul des pr\u00e9dicats est \\(\\color{red}\\text{complet : ce qui est vrai est prouvable et  r\u00e9ciproquement}\\).  </p> <p>Aucun syst\u00e8me logique coh\u00e9rent (comme la d\u00e9duction naturelle ou le  calcul des s\u00e9quents) ne peut d\u00e9montrer tous les r\u00e9sultats de  l'arithm\u00e9tique. \\(\\color{red}\\text{Quel que soit le syst\u00e8me, s'il est assez riche pour exprimer l'arithm\u00e9tique, on peut}\\) \\(\\color{red}\\text{trouver un \u00e9nonc\u00e9 valide qui ne sera  pas d\u00e9montrable dans ce syst\u00e8me}\\).  </p> <p>\\(\\color{red}\\text{Aucun syst\u00e8me logique coh\u00e9rent assez riche pour exprimer  l'arithm\u00e9tique ne peut}\\) \\(\\color{red}\\text{d\u00e9montrer sa propre coh\u00e9rence}\\). Par exemple,  les math\u00e9matiques ens\u00e9eign\u00e9es en CPGE ne peuvent pas \u00e9tablir la  preuve qu'elles sont sans contradiction.  </p>"},{"location":"Logique/1-Logique/#syntaxe","title":"Syntaxe","text":""},{"location":"Logique/1-Logique/#lalphabet","title":"L'alphabet","text":"<p>D\u00e9finition</p> <p>On consid\u00e8re un alphabet \\(\\Sigma\\) constitu\u00e9 :</p> <ul> <li>de symboles Vrai et Faux not\u00e9s V et F,  </li> <li>de variables propositionnelles en nombre d\u00e9nombrable not\u00e9es dans ce cours en lettres romaines \\(a, b\\), \\(\\dotsb\\) , \\(a_1\\), \\(\\dotsb\\) , \\(z_{32}\\), \\(\\dotsb\\)</li> <li>de deux symboles de parenth\u00e8ses \"(\\(,\\))\" (ouvrante et fermante).  </li> <li>d'un connecteur unaire \\(\\neg\\)  dit de n\u00e9gation  </li> <li>de trois connecteurs binaires not\u00e9s \\(\\vee , \\wedge , \\rightarrow\\) et appel\u00e9s connecteurs logiques de disjonction, conjonction et d'implication.  </li> </ul> <p>Remarque</p> <ul> <li>On dit aussi op\u00e9rateur pour \"connecteur\"  </li> <li>Dans certains cours, on ajoute aussi l'op\u00e9rateur \\(\\Leftrightarrow\\) et le XOR. Dans certains autres, seulement \\(\\neg , \\vee , \\wedge\\) , voire m\u00eame \\(\\neg , \\wedge\\) .</li> <li>Le NAND (\\(A\\) NAND \\(B\\) vaut \\(\\neg (A \\wedge  B)\\)) est universel.  </li> </ul>"},{"location":"Logique/1-Logique/#ensemble-des-propositions","title":"Ensemble des propositions","text":"<p>D\u00e9finition</p> <p>On appelle langage des propositions le langage d\u00e9fini inductivement par :</p> <ul> <li>les constantes et les variables propositionnelles sont dans le langage,</li> <li>si \\(A\\) est dans le langage, alors \\((A)\\) aussi,</li> <li>si \\(A\\) est dans le langage \\((\\neg A)\\) aussi, </li> <li>si \\(A, B\\) sont dans le langage alors \\((A \\vee  B)\\), \\((A \\wedge  B)\\) et \\((A \\rightarrow B)\\) aussi.  </li> </ul>"},{"location":"Logique/1-Logique/#representation-arborescente","title":"Repr\u00e9sentation arborescente","text":"<p>\\((((\\neg a) \\vee  b) \\wedge  (\\neg c))\\) se repr\u00e9sente sous la forme d'un arbre binaire (dit arbre syntaxique) :</p> <p></p> <p>Remarque</p> <p>Puisque les propositions sont construites comme des arbres binaires, il est naturel de parler de leur taille et de leur hauteur.</p>"},{"location":"Logique/1-Logique/#simplification-de-lecriture","title":"Simplification de l'\u00e9criture","text":"<p>On ne note pas les parenth\u00e8ses autour de la racine.  </p> <p>On convient (souvent, mais je ne trouve pas \u00e7a si commode) que  l'op\u00e9rateur de n\u00e9gation \\(\\neg a\\) priorit\u00e9 sur les autres, que la conjonction et la disjonction ont priorit\u00e9 sur l'implication, et enfin que la  conjonction a priorit\u00e9 sur la disjonction. C'est tr\u00e8s classique !  </p> <p>Remarque</p> <p>C'est \u00e0 dire : \\(\\neg \\gg \\wedge \\gg \\vee \\gg \\text{ } \\rightarrow\\)</p> <p>Pour passer des \u00e9critures sans parenth\u00e8ses aux \u00e9critures avec  parenth\u00e8ses, une r\u00e8gle simple : plus l'op\u00e9rateur est prioritaire, plus il a  de parenth\u00e8ses autour de lui.  </p>"},{"location":"Logique/1-Logique/#priorites-en-python","title":"Priorit\u00e9s en Python","text":"<p>Figure \u2013 R\u00e8gles de priorit\u00e9 de la plus haute (en haut) \u00e0 la plus basse (en bas). Les op\u00e9rateurs de m\u00eame niveau sont \u00e9valu\u00e9s de gauche \u00e0 droite</p> <p>Exercice</p> <p>Remettre des parenth\u00e8ses  </p> <ul> <li>\\(\\neg a \\vee  b \\wedge  c\\) </li> <li>\\(((\\neg a) \\vee  (b \\wedge  c))\\) </li> <li>\\(\\neg a \\wedge  b \\vee  c\\) </li> <li>\\((((\\neg a) \\wedge  b) \\vee  c)\\) </li> <li>\\(a \\vee  \\neg b \\wedge  c \\rightarrow  a \\wedge  c\\) </li> <li>\\([(a \\vee  ((\\neg b) \\wedge  c)) \\rightarrow  (a \\wedge  c)]\\) </li> </ul>"},{"location":"Logique/1-Logique/#semantique","title":"S\u00e9mantique","text":""},{"location":"Logique/1-Logique/#contexte","title":"Contexte","text":"<p>D\u00e9finition: Un contexte</p> <p>Un contexte (ou une distribution de v\u00e9rit\u00e9) sur un ensemble de variables propositionnelles \\({\\displaystyle {\\mathcal {V}}}\\) est une application de \\({\\displaystyle {\\mathcal {V}}}\\) dans l'ensemble des boul\u00e9ens \\({\\displaystyle {\\mathcal {B}}}\\).</p> <p>Remarque</p> <ul> <li>Si \\(|{\\displaystyle {\\mathcal {V}}}| = n\\) alors il y a \\(2^n\\) distributions de v\u00e9rit\u00e9.</li> <li>L'ensemble des boul\u00e9ens peut \u00eatre repr\u00e9sent\u00e9 de diff\u00e9rentes fa\u00e7ons.</li> <li>Dans ce cours, on pose \\({\\displaystyle {\\mathcal {B}}} = {0, 1}\\), et on identifie \\({\\displaystyle {\\mathcal {B}}}\\) avec l'anneau \\(\\mathbb{Z}/2\\mathbb{Z}\\) (donc \\(1 + 1 = 0\\) en particulier.)</li> <li>La multiplication est l'interpr\u00e9tation de la conjonction, \\(0\\) celle de F, \\(1\\) celle de V, l'addition celle du XOR.  </li> </ul>"},{"location":"Logique/1-Logique/#interpretation","title":"Interpr\u00e9tation","text":"<p>D\u00e9finition: Une \u00e9valuation / interpr\u00e9tation</p> <p>Soit \\(\\mu\\) un contexte sur un ensemble de variables \\({\\displaystyle {\\mathcal {V}}}\\) \u00e0 valeur dans \\({\\displaystyle {\\mathcal {B}}} = \u2124/2\u2124\\). On appelle \u00e9valuation (ou encore interpr\u00e9tation) associ\u00e9e \u00e0 \\(\\mu\\) l'application not\u00e9e \\(\\varepsilon_\\mu\\) d\u00e9finie sur l'ensemble des propositions par :</p> <ul> <li>\\(\\varepsilon_\\mu(V ) = 1, \\varepsilon_\\mu(F ) = 0\\)</li> <li>pour toute variable \\(v \\in {\\displaystyle {\\mathcal {V}}}, \\varepsilon_\\mu(v ) = \\mu(v )\\)</li> <li>pour toute expression \\(p, \\varepsilon_\\mu(\\neg p) = 1 \u2212 \\varepsilon_\\mu(p)\\)</li> <li>pour toutes expressions \\(p_1\\) et \\(p_2\\) : </li> </ul> \\[\\begin{matrix}     \\varepsilon_\\mu(p_1 \\wedge p_2) &amp;=&amp; \\varepsilon_\\mu(p_1)\\varepsilon_\\mu(p_2)\\\\     \\varepsilon_\\mu(p_1 \\vee p_2) &amp;=&amp; \\varepsilon_\\mu(p_1) + \\varepsilon_\\mu(p_2) \u2212 \\varepsilon_\\mu(p_1)\\varepsilon_\\mu(p_2)\\\\      \\varepsilon_\\mu(p_1 \\rightarrow p_2) &amp;=&amp; 1 \u2212 \\varepsilon_\\mu(p_1) + \\varepsilon_\\mu(p_2)\\varepsilon_\\mu(p_1). \\end{matrix}\\] <p>Remarque</p> <p>Observer l'analogie avec les fonctions caract\u00e9ristiques.</p>"},{"location":"Logique/1-Logique/#implication","title":"Implication","text":"<ul> <li>Comme on va le voir \\(a \\rightarrow b\\) est s\u00e9mantiquement \u00e9quivalent \u00e0  \\(\\neg a \\vee b\\), c'est \u00e0 dire que les deux propositions ont la m\u00eame valeur de  v\u00e9rit\u00e9 pour toute interpr\u00e9tation.</li> <li>L'interpr\u00e9tation de l'implication donn\u00e9e au transparent pr\u00e9c\u00e9dent  s'obtient par calcul :  </li> </ul> \\[ \\begin{matrix} \\varepsilon_\\mu((\\neg p_1) \\vee  p_2)     &amp;=&amp;  \\varepsilon_\\mu(\\neg p_1) + \\varepsilon_\\mu(p_2) \u2212 \\varepsilon_\\mu(\\neg p_1)\\varepsilon_\\mu(p_2)  \\\\     &amp;=&amp; (1 \u2212 \\varepsilon_\\mu(p_1)) + \\varepsilon_\\mu(p_2) \u2212 (1 \u2212 \\varepsilon_\\mu(p_1))\\varepsilon_\\mu(p_2)  \\\\     &amp;=&amp; 1 \u2212 \\varepsilon_\\mu(p_1) + \\varepsilon_\\mu(p_2) \u2212 \\varepsilon_\\mu(p_2) + \\varepsilon_\\mu(p_1)\\varepsilon_\\mu(p_2)  \\\\     &amp;=&amp; 1 \u2212 \\varepsilon_\\mu(p_1) + \\varepsilon_\\mu(p_2)\\varepsilon_\\mu(p_1)  \\\\     &amp;=&amp;\\varepsilon_\\mu(p_1 \\rightarrow  p_2) \\end{matrix} \\]"},{"location":"Logique/1-Logique/#tables-de-verite","title":"Tables de v\u00e9rit\u00e9","text":""},{"location":"Logique/1-Logique/#equivalence-semantique","title":"Equivalence s\u00e9mantique","text":"<p>D\u00e9finition: S\u00e9mantiquement \u00e9quivalent</p> <p>Deux propositions \\(p, q\\) sont dites s\u00e9mantiquement \u00e9quivalentes si elles ont m\u00eame table de v\u00e9rit\u00e9. Ceci revient \u00e0 dire que pour tout contexte \\(\\mu\\), si \\(\\varepsilon_\\mu\\) de l'une vaut \\(1\\), alors pour l'autre aussi.On note \\(p\\) \\(\\equiv\\) \\(q\\).</p> <p>D\u00e9finition: Tautologie</p> <p>On dit qu'une proposition \\(p\\) est une tautologie lorsque \\(p\\) \\(\\equiv\\) \\(V\\) (c'est \u00e0 dire que la derni\u00e8re colonne de sa table de v\u00e9rit\u00e9 ne contient que des \\(1\\)).</p> <p>Remarque</p> <ul> <li>Par exemple \\(a \\wedge V\\) est s\u00e9mantiquement \u00e9quivalente \u00e0 \\(a\\).  </li> <li>Montrer que le tiers exclu \\(a \\vee \\neg a\\) est une tautologie.  </li> <li>Certains auteurs parlent d'\u00e9quivalence logique.  </li> </ul>"},{"location":"Logique/1-Logique/#xor","title":"XOR","text":"<p>Exercice</p> <p>D\u00e9finir l'op\u00e9rateur XOR au moyen des op\u00e9rateurs usuels</p> <p>La table du XOR (=OU du cantinier)</p> \\[\\begin{array}{c|c|c} a &amp; b &amp; a \\oplus b\\\\ \\hline 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 0 &amp; 1 \\\\ 0 &amp; 1 &amp; 1 \\\\ 0 &amp; 0 &amp; 0 \\end{array}\\] <p>Correction</p> <p>\\((\u00ac A \u2228 \u00ac B) \u2227 (A \u2228 B)\\)</p>"},{"location":"Logique/1-Logique/#priorites","title":"Priorit\u00e9s","text":"<ul> <li>Les op\u00e9rateurs \\(\\wedge\\)  et \\(\\vee\\)  sont associatifs : en cons\u00e9quence on peut \u00e9crire  ((\\(a \\vee b\\)) \\(\\vee\\)  (\\(c\\) \\(\\vee\\) \\(d\\))) comme \\(a \\vee  b \\vee  c \\vee  d\\)</li> <li>\\(\\rightarrow\\)  n'est pas associatif : \\(a\\) \\(\\rightarrow\\)  (\\(b\\) \\(\\rightarrow\\) \\(c\\)) n'est pas s\u00e9mantiquement  \u00e9quivalent \u00e0 (\\(a\\) \\(\\rightarrow\\) \\(b\\)) \\(\\rightarrow\\)  c</li> <li>Exercice : montrer ces assertions par des tables de v\u00e9rit\u00e9.  </li> <li>L'implication n'est pas associative mais par convention  \\(A\\) \\(\\rightarrow\\) \\(B\\) \\(\\rightarrow\\) \\(C\\) \\(\\rightarrow\\) \\(D\\) se lit \\(A\\) \\(\\rightarrow\\)  (\\(B\\) \\(\\rightarrow\\)  (\\(C\\) \\(\\rightarrow\\) \\(D\\))).</li> </ul> <p>Observer l'analogie avec une fonction f de type <code>a-&gt;b-&gt;c-&gt;d</code> en  OCaml : <code>f x</code> est de type <code>b-&gt;c-&gt;d</code>.  </p>"},{"location":"Logique/1-Logique/#dautres-operateurs","title":"D'autres op\u00e9rateurs","text":"<p>Exercice</p> <ul> <li>Montrer qu'on peut se passer de l'op\u00e9rateur d'implication.  </li> <li>L'op\u00e9rateur binaire \\(\\Leftrightarrow\\) est d\u00e9fini ainsi : \\(a \\Leftrightarrow  b\\) a la table de  \\((a \\rightarrow b) \\wedge  (b \\rightarrow   a)\\). Montrer que \\(a\\) XOR \\(b\\) est s\u00e9mantquement  \u00e9quivalent \u00e0 \\(\\neg (a \\Leftrightarrow  b)\\).  </li> </ul> Calcul \u00e0 partir de l'arbre syntaxique <p>\\((a \\vee n) \\rightarrow ((\\neg c)\\vee (b \\wedge V)), \\mu(a) = 1; \\mu(b) = \\mu(c) = 0\\). Commencer par les feuilles et remonter aux p\u00e8res.</p> <p><p></p></p> <p><p></p></p> <p><p></p></p> <p><p></p></p> <p><p></p></p>"},{"location":"Logique/1-Logique/#satisfiabilite","title":"Satisfiabilit\u00e9","text":""},{"location":"Logique/1-Logique/#tautologies","title":"Tautologies","text":""},{"location":"Logique/1-Logique/#tautologie-proposition-satisfiable","title":"Tautologie, proposition satisfiable","text":"<p>D\u00e9finition: Tautologie, mod\u00e8le et antilogie</p> <ul> <li>On appelle tautologie toute expression \u00e9valu\u00e9e \u00e0 \\(1\\) dans tout contexte.</li> <li>Une proposition \\(p\\) est dite satisfiable ou satisfaisable si il existe un contexte \\(\\mu\\) tel que  \\(\\varepsilon_\\mu(p) = 1\\). On dit que \\(\\mu\\) est un mod\u00e8le de \\(p\\) et on note \\(\\mu \\models p\\).  </li> <li>Une proposition qui n'est pas satisfiable est apell\u00e9e une antilogie. On  dit aussi que l'expression est insatisfiable.  </li> </ul> <p>Exemples</p> <ul> <li>Le tiers exclu \\(a \\vee  \\neg a\\) est une tautologie, \\((a \\wedge  b) \\rightarrow  b\\) aussi.  </li> <li>\\(a \\rightarrow  b\\) est satisfiable mais n'est pas une tautologie.  </li> <li>\\(a \\wedge  \\neg a\\) est insatisfiable.  </li> <li>Montrer que \\((\\neg A \\rightarrow  A) \\rightarrow  A\\) est une tautologie  </li> </ul>"},{"location":"Logique/1-Logique/#notation","title":"Notation","text":"<ul> <li>Pour indiquer qu'une proposition \\(a\\) est s\u00e9mantiquement \u00e9quivalente \u00e0  une proposition \\(b\\), il n'est pas suffisant d'\u00e9crire \\(a \\Leftrightarrow b\\).</li> <li>En effet \\(a \\Leftrightarrow b\\) est juste une proposition. Celle-ci peut \u00eatre  satisfiable ou non (peut-\u00eatre m\u00eame pas, comme \\(V \\Leftrightarrow F\\) ).  </li> <li>La bonne fa\u00e7on d'indiquer cette \u00e9quivalence est de d\u00e9clarer  \"\\(a \\Leftrightarrow b\\) est une tautologie\".</li> <li>Les math\u00e9maticiens sont parfois paresseux : il leur arrive d'\u00e9crire  \"\\(a \\Leftrightarrow b\\)\" au lieu de \"\\(a \\Leftrightarrow b\\) est vraie (ce qui signifie vraie  pour tout contexte)\".  </li> <li>On \u00e9crit \\(a \\equiv b\\) pour indiquer que \\(a \\Leftrightarrow b\\) est une tautologie.  </li> <li>Attention, \"\\(\\equiv\\)\" n'est pas un op\u00e9rateur (il n'appartient pas au  langage) mais un m\u00e9ta-op\u00e9rateur.  </li> </ul> <p>A ce propos, un principe empirique est que, pour exprimer des id\u00e9es  sur un langage, il faut souvent \"sortir\" du langage.  </p>"},{"location":"Logique/1-Logique/#notion-de-consequence","title":"Notion de cons\u00e9quence","text":"<p>D\u00e9finition: Cons\u00e9quence</p> <p>On consid\u00e8re une expression logique \\(p\\) et \\(\\chi\\) un ensemble d'expressions logiques. On dit que \\(p\\) est une cons\u00e9quence de \\(\\chi\\) si toute interpr\u00e9tation qui satisfait toutes les formules de l'ensemble \\(\\chi\\) satisfait \\(p\\). Si c'est le cas, on note : \\(\\chi \\models p\\).</p> <p>Notation</p> <p>Si \\(\\chi = \\left \\{  h_1, \\dotsb , h_n \\right \\}\\), on \u00e9crit aussi \\(h_1, \\dotsb , h_n \\models p\\).  Si \\(\\chi = \\left \\{h \\right \\}\\), on \u00e9crit \\(h \\models p\\)  Par convention, \\(\\models p\\) indique que \\(p\\) est une tautologie.  </p>"},{"location":"Logique/1-Logique/#proprietes-de-leftrightarrow","title":"Propri\u00e9t\u00e9s de \\(\\Leftrightarrow\\)","text":"<p>Pour toutes propositions \\(p_1, p_2, p_3\\), les propositions suivantes sont des tautologies :</p> <p>Propori\u00e9t\u00e9 de \\(\\Leftrightarrow\\)</p> <ul> <li>R\u00e9flexivit\u00e9 \\(p_1 \\Leftrightarrow p_1\\)</li> <li>Sym\u00e9trie \\((p_1 \\Leftrightarrow p_2) \\Leftrightarrow (p_2 \\Leftrightarrow p_1)\\)</li> <li>Transitivit\u00e9 \\(((p_1 \\Leftrightarrow p_2) \\wedge  (p_2 \\Leftrightarrow p_3)) \\Leftrightarrow (p_1 \\Leftrightarrow p_3)\\)</li> </ul>"},{"location":"Logique/1-Logique/#proprietes-de-wedge","title":"Propri\u00e9t\u00e9s de \\(\\wedge\\)","text":"<p>Pour toutes propositions \\(p_1, p_2, p_3\\), les propositions suivantes sont des tautologies :</p> <p>Propori\u00e9t\u00e9 de \\(\\wedge\\)</p> <ul> <li>\u00c9l\u00e9ment neutre \\((p_1 \\wedge  V ) \\Leftrightarrow p_1\\)</li> <li>\u00c9l\u00e9ment absorbant \\((p_1 \\wedge  F )\\Leftrightarrow F\\)</li> <li>Commutativit\u00e9 \\((p_1 \\wedge  p_2) \\Leftrightarrow (p_2 \\wedge  p_1)\\)</li> <li>Associativit\u00e9 \\((p_1 \\wedge  (p_2 \\wedge  p_3))\\Leftrightarrow ((p_1 \\wedge  p_2) \\wedge  p_3)\\)</li> <li>Idempotence \\((p_1 \\wedge  p_1) \\Leftrightarrow p_1\\)</li> </ul>"},{"location":"Logique/1-Logique/#proprietes-de-vee","title":"Propri\u00e9t\u00e9s de \\(\\vee\\)","text":"<p>Pour toutes propositions \\(p_1, p_2, p_3\\), les propositions suivantes sont des tautologies :</p> <p>Propri\u00e9t\u00e9s de \\(\\vee\\)</p> <ul> <li>\u00c9l\u00e9ment neutre \\((p_1 \\vee  F ) \\Leftrightarrow p_1\\)</li> <li>\u00c9l\u00e9ment absorbant \\((p_1 \\vee  V ) \\Leftrightarrow V\\)</li> <li>Commutativit\u00e9 \\((p_1 \\vee  p_2) \\Leftrightarrow (p_2 \\vee  p_1)\\)</li> <li>Associativit\u00e9 \\((p_1 \\vee  (p_2 \\vee  p_3)) \\Leftrightarrow ((p_1 \\vee  p_2) \\vee  p_3)\\)</li> <li>Idempotence \\((p_1 \\vee  p_1) \\Leftrightarrow p_1\\)</li> </ul>"},{"location":"Logique/1-Logique/#relations-entre-vee-et-wedge","title":"Relations entre \\(\\vee\\)  et \\(\\wedge\\)","text":"<p>Pour toutes propositions \\(p_1, p_2, p_3\\), les propositions suivantes sont des tautologies :</p> <ul> <li>Subsomption \\((p_1 \\vee  (p_1 \\wedge  p_2)) \\Leftrightarrow p_1\\)</li> <li>Subsomption \\((p_1 \\wedge  (p_1 \\vee  p_2)) \\Leftrightarrow p_1\\)</li> <li>Distributivit\u00e9 \\((p_1 \\wedge  (p_2 \\vee  p_3)) \\Leftrightarrow (p_1 \\wedge  p_2) \\vee  (p_1 \\wedge  p_3)\\)</li> <li>Distributivit\u00e9 \\((p_1 \\vee  (p_2 \\wedge  p_3)) \\Leftrightarrow (p_1 \\vee  p_2) \\wedge  (p_1 \\vee  p_3)\\)</li> <li>Premi\u00e8re loi de De Morgan \\(\\neg (p_1 \\wedge  p_2) \\Leftrightarrow (\\neg p_1) \\vee  (\\neg p_2)\\)</li> <li>Seconde loi de De Morgan \\(\\neg (p_1 \\vee  p_2) \\Leftrightarrow (\\neg p_1) \\wedge  (\\neg p_2)\\)</li> </ul>"},{"location":"Logique/1-Logique/#proprietes-de-rightarrow","title":"Propri\u00e9t\u00e9s de \\(\\rightarrow\\)","text":"<p>Pour toutes propositions \\(p_1, p_2, p_3\\), les propositions suivantes sont des tautologies :</p> <p>Propri\u00e9t\u00e9s de \\(\\rightarrow\\)</p> <ul> <li>Modus ponens \\((p_1 \\wedge  (p _1\\rightarrow  p_2)) \\rightarrow  p_2\\)</li> <li>Double implication \\(((p_1 \\rightarrow  p_2) \\wedge  (p_2 \\rightarrow  p_1)) \\Leftrightarrow (p_1 \\Leftrightarrow p_2)\\)</li> </ul>"},{"location":"Logique/1-Logique/#raisonnement-en-mathematiques","title":"Raisonnement en math\u00e9matiques","text":"<p>Pour toutes propositions \\(p_1, p_2\\), les propositions suivantes sont des tautologies :</p> <ul> <li>Disjonction de cas \\(((p_1 \\rightarrow  p_2) \\wedge  (\\neg p_1 \\rightarrow  p_2)) \\Leftrightarrow p_2\\)</li> <li>Contraposition \\((p_1 \\rightarrow  p_2) \\Leftrightarrow (\\neg p_2 \\rightarrow  \\neg p_1)\\)</li> <li>Raisonnement par l'absurde \\((\\neg p_1 \\rightarrow  F ) \\Leftrightarrow p_1\\)</li> </ul> <p>Exercice</p> <p>Montrer qu'on a bien des tautologies en consruisant des tables de v\u00e9rit\u00e9.</p>"},{"location":"Logique/1-Logique/#formes-normales","title":"Formes normales","text":""},{"location":"Logique/1-Logique/#ecriture-simplifiee","title":"Ecriture simplifi\u00e9e","text":"<p>Pour travailler avec une proposition \\(p\\), il est souvent utile de consid\u00e9rer une expression s\u00e9mantiquement \u00e9quivalente \u00e0 \\(p\\) mais plus simple :  </p> <ul> <li>Ce peut \u00eatre une version standardis\u00e9e, dite normale (Analogie :  \\(\\frac{6}{4}\\) a pour forme normale \\(\\frac{3}{2}\\) )</li> <li>ou encore une version avec moins de connecteurs : \\(F\\) pour \\(a \\wedge  (\\neg a)\\) (Analogie : \\(6\\) pour \\(1 + 2 + 3\\)).  </li> </ul>"},{"location":"Logique/1-Logique/#litteraux","title":"Litt\u00e9raux","text":"<p>D\u00e9finition: Litt\u00e9ral</p> <p>On appelle litt\u00e9ral toute proposition de la forme \\(v\\) ou \\(\\neg v\\) o\u00f9 \\(v\\) est une variable propositionnelle.</p> <p>D\u00e9finition: Conjonction et disjonction</p> <p>On appelle conjonction (resp. disjonction) des propositions \\(p_1, \\dotsb , p_n\\) (\\(n \\geq 1\\)), la proposition \\(p_1 \\wedge  p_2 \\dotsb \\wedge  p_n\\) (resp. \\(p_1 \\vee  p_2 \\dotsb \\vee  p_n\\))</p> <p>Remarque</p> <p>Par convention :</p> <ul> <li>Une conjonction de \\(0\\) proposition est \\(V\\) </li> <li>Une disjonction de \\(0\\) proposition est \\(F\\) </li> <li>Tout litt\u00e9ral est \u00e0 la fois une conjonction et une disjonction.  </li> </ul>"},{"location":"Logique/1-Logique/#clauses-monomes","title":"Clauses, Mon\u00f4mes","text":"<p>D\u00e9finition: Clause</p> <p>On appelle clause toute disjonction de litt\u00e9raux. \\(F\\) , disjonction de z\u00e9ro litt\u00e9ral, est appel\u00e9 la clause vide. (Moyen mn\u00e9motechnique : claUse \\(\\leftrightarrow \\cup  \\leftrightarrow \\vee\\) )</p> <p>D\u00e9finition: Mon\u00f4me</p> <p>On appelle mon\u00f4me toute conjonction de litt\u00e9raux. \\(V\\) , conjonction de z\u00e9ro litt\u00e9ral, est appel\u00e9 le mon\u00f4me vide. (Moyen mn\u00e9motechnique : mon\u00f4me \\(\\leftrightarrow \\wedge\\))</p> <p>D\u00e9finition: Forme normale conjonctive</p> <p>On appelle forme normale conjonctive (FNC) toute conjonction de clauses et forme normale disjonctive (FND) toute disjonction de mon\u00f4mes.</p> <p>Remarque</p> <p>On consid\u00e8re implicitement qu'il n'y a pas \\(2\\) fois la m\u00eame variable dans une clause ou mon\u00f4me.</p>"},{"location":"Logique/1-Logique/#forme-normale-conjonctivedisjonctive","title":"forme normale conjonctive/disjonctive","text":"<p>Proposition</p> <p>Toute proposition est s\u00e9mantiquement \u00e9quivalente \u00e0 une forme normale conjonctive (resp. forme normale disjonctive).</p> <p>Remarque</p> <ul> <li>Fait : On n'a besoin que des \\(3\\) op\u00e9rateurs \\(\\neg , \\vee , \\wedge\\)</li> <li>Convertir une proposition en forme normale conjonctive requiert  l'utilisation de r\u00e8gles de transformation logiques, comme l'\u00e9limination de double n\u00e9gations, les lois de De Morgan, et la loi de distributivit\u00e9.</li> <li>Principe : ramener la n\u00e9gation \"au contact\" des variables (de Morgan), \"remonter\" les \\(\\wedge\\) (distibutivit\u00e9) et supprimer les \\(\\neg \\neg\\). Par exemple, si \\(v_1, v_2, v_3, v_4\\) sont des variables :</li> </ul> \\[\\begin{matrix} \\underset{\\textsf{F. ni conjonctive ni disjonctive}}{\\underbrace{\\neg(v_1\\wedge (v_2\\vee \\neg v_3)) \\vee v_4}} &amp;\\equiv&amp; \\neg v_1 \\vee \\neg(v_2 \\vee \\neg v_3) \\vee v_4 \\\\  &amp;\\equiv&amp; \\neg v_1 \\vee (\\neg v_2 \\wedge \\neg \\neg v_3) \\vee v_4 \\\\ &amp;\\equiv&amp; (\\neg v_1 \\vee \\neg v_2 \\vee v_4) \\wedge (\\neg v_1 \\vee v_3 \\vee v_4) \\end{matrix}\\] <ul> <li>Les formes normales conjonctives ou disjonctives de litt\u00e9raux ne sont  en g\u00e9n\u00e9ral pas uniques !  </li> </ul> <p>Exemples</p> <p>Les propositions suivantes, dans lesquelles \\(a, b, c, d, e, f\\) sont des litt\u00e9raux,  sont des formes conjonctives :  </p> <ul> <li>\\(a \\wedge  b\\)</li> <li>\\(a \\vee  b\\) (oui car c'est une clause - il y a z\u00e9ro conjonction-)  </li> <li>\\(a\\) </li> <li>\\((a \\vee  b) \\wedge  c\\)</li> <li>\\((a \\vee  \\neg b \\vee  \\neg c) \\wedge  (\\neg d \\vee  e \\vee  f )\\) </li> </ul> <p>Contre exemples</p> <p>Les propositions suivantes, dans lesquelles \\(a, b, c, d, e, f\\) sont des variables,  ne sont pas des formes conjonctives :  </p> <ul> <li>\\(\\neg (a \\wedge  b)\\) : la n\u00e9gation \\(\\neg\\)  est devant la proposition \\((a \\wedge  b)\\) qui n'est  pas atomique (ce n'est pas un litt\u00e9ral)  </li> <li>\\(a \\wedge  (b \\vee  (c \\wedge  d))\\) : un \\(\\wedge\\) est imbriqu\u00e9 dans un \\(\\vee\\) .  </li> </ul>"},{"location":"Logique/1-Logique/#reecriture","title":"R\u00e9\u00e9criture","text":"<p>Pour obtenir une FNC \u00e0 partir d'une proposition \\(p\\) :</p> <ul> <li>Supprimer les constantes : \\(V\\) est remplac\u00e9 par \\(v \\vee \\neg v\\) ; \\(F\\) par \\(v \\wedge \\neg v\\) o\u00f9 \\(v\\) est une variable.</li> <li>Supprimer les implications : on exprime la proposition uniquement avec des \\(\\neg, \\vee, \\wedge\\)</li> <li>On descend \\(\\neg\\) par les lois de De Morgan au contact des variables. -On applique la distributivit\u00e9 pour faire descendre les \\(\\vee\\) et remonter les \\(\\wedge\\).</li> </ul>"},{"location":"Logique/1-Logique/#uniquement-des-neg-et-des-wedge","title":"Uniquement des \\(\\neg\\)  et des \\(\\wedge\\)","text":"<p>Toute proposition peut \"s'exprimer\" sans constante : V est remplac\u00e9 par \\(v \\vee \\neg v\\) ; F par \\(v \\wedge  \\neg v\\) o\u00f9 \\(v\\) est une variable.  </p> <p>Tous les op\u00e9rateurs peuvent se d\u00e9finir avec \\(\\neg , \\wedge , \\vee\\)  uniquement.  </p> <p>Une disjonction \\(a \\vee  b\\) peut s'exprimer comme la n\u00e9gation d'une  conjonction \\(\\neg (\\neg a \\wedge  \\neg b)\\) </p> <p>En appliquant ces r\u00e8gles, on obtient que toute proposition est  s\u00e9mantiquement \u00e9quivalente \u00e0 une expression ne contenant que des  variables et les connecteurs \\(\\neg , \\wedge\\) . Ceci nous sert au transparent  suivant.  </p> <p>Preuve d'existence d'une forme normale conjonctive</p> <p>R\u00e9currence sur la taille de la proposition p. </p> <p>HR : \\(p\\) est \u00e9quivalente \u00e0 FNC.</p> <ul> <li>Si \\(p\\) est un litt\u00e9ral : ok.</li> <li> <p>Si \\(p = \\neg q\\), on applique l'hypoth\u00e8se de r\u00e9currence \u00e0 \\(q\\) qui s'\u00e9crit donc  \\(c_1 \\wedge  \\dotsb \\wedge  c_n\\) o\u00f9 les \\(c_i\\) sont des clauses.</p> <ul> <li>Par les lois de De Morgan, chaque clause \\(c_i\\) s'\u00e9crit comme un \\(\\neg m_i\\) o\u00f9  \\(m_1\\) est un mon\u00f4me mi =  \\(\\bigwedge_{k_i=1}^{n_i} l_{i,k_i}\\)(les \\(l_{i,k_i}\\) sont des litt\u00e9raux).</li> <li>Alors par De Morgan (encore) : \\(p \\equiv \\neg (\\neg m_1 \\wedge  \\dotsb \\wedge  \\neg m_n) \\equiv (\\neg \\neg m_1) \\vee  \\dotsb \\vee  (\\neg \\neg m_n) \\equiv m_1 \\vee  \\dotsb \\vee  m_n\\). </li> <li>On a bien ce qu'on veut : $$ p \\equiv \\bigvee_{i=1}^n (\\bigwedge_{k_i=1}^{n_i} l_{i,k_i})  \\underset{\\textsf{distributivit\u00e9}}{\\underbrace{\\equiv}}~~\\overbrace{\\underset {\\underset {k_n \\in [![1~,~n_n]!]}{\\vdots}}{\\bigwedge_{k_1 \\in [![1~;~ n_1]!]}}\\underset{\\textsf{clause}}{l_{1,k_1 \\vee \\dotsb \\vee l_{n,k_n}}}}^{\\textsf{conjonction de clauses}} $$</li> </ul> </li> <li> <p>Si \\(p = f_1 \\wedge  f_2,\\) par HR \\(f_1 \\equiv p_1 \\wedge  \\dotsb \\wedge  p_n\\) et \\(f_2 \\equiv q_1 \\wedge  \\dotsb \\wedge  q_n\\) o\u00f9 les  \\(p_k , q_r\\) sont des clauses. $$ p \\underset{\\textsf{assoc. de}~\\wedge}{\\underbrace{\\equiv}}  \\underset{\\textsf{conjonction de clauses}}{\\underbrace{p_1 \\wedge  \\dotsb \\wedge  p_{n_1} \\wedge  q_1 \\wedge  \\dotsb \\wedge  q_{n_2}}} $$ Ce qu'on veut.  </p> </li> <li> <p>Si \\(p = f_1 \\vee f_2\\) alors, par HR, \\(p\\) est \u00e9quivalent \u00e0 une formule de la forme \\((p_1 \\wedge \\dotsb \\wedge p_{n_1} ) \\vee (q_1 \\wedge \\dotsb \\wedge q_{n_2} )\\) o\u00f9 les \\(p_i ,q_j\\) sont des clauses. Et par distributivit\u00e9 : \\(p \\equiv \\underset{(k_1,k_2)\\in [\\![1,n_1]\\!] \\times [\\![1, n_2]\\!] }{\\bigwedge} ~(p_{k_1} \\vee q_{k_2 }) : \\textsf{OK}\\)</p> </li> </ul>"},{"location":"Logique/1-Logique/#forme-normale-disjonctive","title":"Forme normale disjonctive","text":"<ul> <li>On sait que toute proposition peut s'exprimer comme conjonction de  clause.</li> </ul> <ul> <li>Soit \\(p\\) une proposition, alors \\(\\neg p\\) s'\u00e9crit sous la forme \\(\\neg p \\equiv c_1 \\wedge  \\dotsb \\wedge  c_n\\) avec \\(c_i = l_{i,1} \\vee  \\dotsb \\vee  l_{i,n_i}\\) .  </li> <li>Donc \\(p \\equiv \\neg \\neg p \\equiv \\neg c_1 \\vee  \\dotsb \\vee  \\neg c_n\\) par De Morgan.  </li> <li>Or chaque \\(\\neg c_i\\) est \u00e9quivalent s\u00e9mantiquement \u00e0 une conjonction de litt\u00e9raux (par De Morgan) : \\(\\neg c_i \\equiv \\neg l_{i,1} \\wedge  \\dotsb \\wedge  \\neg l_{i,n_i}\\).</li> </ul> <ul> <li>Donc toute proposition peut s'\u00e9crire comme disjonction de mon\u00f4mes.  </li> <li>PB : ces r\u00e9\u00e9critures ne sont pas uniques.  </li> </ul>"},{"location":"Logique/1-Logique/#explosion-combinatoire","title":"Explosion combinatoire","text":"<p>Consid\u00e9rons la proposition en forme disjonctive :  \\((\\textsf{x}_1 \\wedge  \\textsf{y}_1) \\vee  (\\textsf{x}_2 \\wedge  \\textsf{y}_2) \\vee  \\dotsb \\vee  (\\textsf{x}_n \\wedge  \\textsf{y}_n)\\) de taille lin\u00e9aire  </p> <p>Par distributivit\u00e9, sa FNC, de taille \\(2^n\\), est de la forme :  </p> \\[ \\begin{align} (\\textsf{x}_1 \\vee  \\textsf{x}_2 \\vee  \\dotsb \\vee  \\textsf{x}_{n-1} \\vee  \\textsf{x}_n) \\wedge  (\\textsf{x}_1 \\vee  \\textsf{x}_2 \\vee  \\dotsb \\vee  \\textsf{x}_{n-1} \\vee  \\textsf{y}_n) \\wedge  \\dotsb \\\\ \\dotsb \\wedge  (\\textsf{x}_1 \\vee  \\textsf{x}_2 \\vee  \\dotsb \\vee  \\textsf{x}_k \\vee  \\textsf{y}_{k+1} \\vee  \\dotsb \\vee  \\textsf{y}_{n-1} \\vee  \\textsf{y}_n) \\wedge  \\dotsb \\\\ \\wedge (\\textsf{x}_1 \\vee  \\textsf{y}_2 \\vee  \\dotsb \\vee  \\textsf{y}_{n-1} \\vee  \\textsf{y}_n) \\wedge  (\\textsf{y}_1 \\vee  \\textsf{y}_ 2\\vee  \\dotsb \\vee  \\textsf{y}_{n-1} \\vee  \\textsf{y}_n) \\end{align} \\]"},{"location":"Logique/1-Logique/#mintermes-maxtermes","title":"Mintermes, maxtermes","text":"<p>D\u00e9finition: Minterme / Maxterme</p> <p>Soient \\(v_1, \\dotsb , v_n\\) des variables distinctes.</p> <ul> <li>On appelle minterme de \\(v_1, \\dotsb , v_n\\), tout mon\u00f4me o\u00f9 chaque variable  \\(v_i\\) appara\u00eet exactement une fois (et il n'y a pas d'autre variable).  </li> <li>On appelle mAxterme de \\(v_1, \\dotsb , v_n\\), une clAuse o\u00f9 chaque variable \\(v_i\\)  appara\u00eet exactement une fois (et il n'y a pas d'autre variable).  </li> </ul> <p>Remarque</p> <p>Les \\(4\\) (\u00e0 l'ordre pr\u00e8s) maxtermes de \\(v_1\\) et \\(v_2\\) sont \\(v_1 \\vee  v_2, v_1 \\vee  \\neg v_2, \\neg v_1 \\vee  v_2, \\neg v_1 \\vee  \\neg v_2\\). On confond les maxtermes \\(v_1 \\vee  v_2\\) et \\(v_2 \\vee  v_1\\).  </p>"},{"location":"Logique/1-Logique/#forme-normale-conjonctive","title":"Forme normale conjonctive","text":"<p>D\u00e9finition: Forme normale conjonctive/disjonctive compl\u00e8te</p> <p>On dit qu'une proposition est en forme normale conjonctive compl\u00e8te (i.e. avec maxtermes) (FNCC), si elle s'\u00e9crit comme une conjonction de maxtermes tous distincts.</p> <p>On dit qu'une proposition est en forme normale disjonctive compl\u00e8te (i.e. avec mintremes) (FNDC), si elle s'\u00e9crit comme une disjonction de mintermes tous distincts.</p> <p>Remarque</p> <p>Mettre une proposition sous FNCC, c'est donner une expression en  FNCC s\u00e9mantiquement \u00e9quivalente \u00e0 cette proposition.</p> <p>\\((v_1 \\vee  \\neg v_2 \\vee  v_3) \\wedge  (v_1 \\vee  v_2 \\vee  \\neg v_3)\\) est une FNCC sur les variables  \\(v_1, v_2, v_3\\) mais pas \\((v_1\\vee  \\neg v_2 \\vee  v_3) \\wedge  \\neg (v_1 \\vee  v_2 \\vee  \\neg v_3)\\) car la n\u00e9gation  n'est pas au contact des variables. \\((v_1 \\vee v_2 \\vee \\neg v_3 ) \\wedge (v_1 \\vee v_3 )\\) non plus car il manque une variable. </p> <p>Utilisation : d\u00e9monstration automatique de th\u00e9or\u00e8mes ou PB SAT.      </p> <p>Exemple</p> <p>Soit \\(p\\) une proposition \u00e0 \\(3\\) variables dont la table est : \\(\\text{Table de } p\\)</p> \\[\\begin{array}{c|c|c|c}  a &amp; b &amp; c &amp; p \\\\  \\hline  1 &amp; 1 &amp; 1 &amp; 0 \\\\  1 &amp; 1 &amp; 0 &amp; '1' \\\\  1 &amp; 0 &amp; 1 &amp; '1' \\\\  1 &amp; 0 &amp; 0 &amp; 0 \\\\  0 &amp; 1 &amp; 1 &amp; '1' \\\\  0 &amp; 1 &amp; 0 &amp; 0 \\\\  0 &amp; 0 &amp; 1 &amp; 0 \\\\  0 &amp; 0 &amp; 0 &amp; 1  \\end{array}\\] <ul> <li> <p>\\(p\\) est s\u00e9pantiquement \u00e9quivalent \u00e0 la disjonction de mintermes \\(q\\) suivante : \\((a \u2227 b \u2227 \u00acc) \u2228 (a \u2227 \u00acb \u2227 c) \u2228 (\u00aca \u2227 b \u2227 \u00acc) \u2228 (\u00aca \u2227 \u00acb \u2227 \u00acc)\\)</p> </li> <li> <p>En effet, \\(p\\) prend la valeur \\(1\\) pour les m\u00eames cpntextes exactement que la FNDC \\(q\\) (une disjonction vaut \\(1\\) si et seulement si un terme vaut \\(1\\)).</p> </li> <li> <p>\\(\u00acp\\) est s\u00e9mantiquement \u00e9quivalente \u00e0 la disjonction de mintermes \\(q'\\) suivante : \\((a \u2227 b \u2227 c) \u2228 (a \u2227 \u00acb \u2227 \u00acc) \u2228 (\u00aca \u2227 b \u2227 \u00acc) \u2228 (\u00aca \u2227 \u00acb \u2227 c)\\)</p> </li> <li> <p>Donc \\(\u00ac\u00acp\\) est s\u00e9mantiquement \u00e9quivalente \u00e0 : \\((\u00aca \u2228 \u00acb \u2228 \u00acc) \u2227 (\u00aca \u2228 b \u2228 c) \u2227 (a \u2228 \u00acb \u2228 c) \u2227 (a \u2228 b \u2228 \u00acc)\\)</p> </li> <li> <p>Lire positivement les variables des lignes \u00e0 \\(1\\) pour la FND</p> </li> <li>Lire n\u00e9gativement les variables des lignes \u00e0 \\(0\\) pour la FNC</li> </ul> <p>Proposition</p> <p>Toute proposition est s\u00e9mantiquement \u00e9quivalente \u00e0 une FNCC (resp. FNDC) unique \u00e0 l'ordre des maxtermes (resp. mintermes) pr\u00e8s (et \u00e0 ordre  des litt\u00e9raux pr\u00e8s dans chaque maxterme -resp. minterme-).  </p> <p>Remarque</p> <p>Soit \\(P\\) une antilogie : ladisjonction \u00e0 z\u00e9ro minterme est \\(F\\) par convention. Or \\(F \u2261 P\\), donc \\(P\\) est bien une disjonction de minterme.</p> <p>Soit \\(P\\) une tautologie : la conjonction \u00e0 z\u00e9ro maxterme est \\(V\\) par convention. Or \\(V \u2261 P\\)^, donc P est une conjonction de maxterme.</p> <p>Un minterme est satisfait par un seul contexte ; un maxterme par tous les contextes sauf \\(1\\).</p> <p>Dans ce qui suit on dit que deux FNDC sont \u00e9gales si elles ont les m\u00eames mintermes (les mintermes sont donn\u00e9s \u00e0 l'ordre des litt\u00e9raux pr\u00e8s).</p>"},{"location":"Logique/1-Logique/#existence-de-la-fndc","title":"Existence de la FNDC","text":"<p>D\u00e9monstration</p> <ul> <li>On construit la table de v\u00e9rit\u00e9 de la proposition : il y a \\(2^n\\) lignes  correspondants aux valeurs de v\u00e9rit\u00e9 des \\(n\\) variables de \\(p\\).  </li> <li>Chaque ligne satisfaisant l'expression (\\(1\\) dans la derni\u00e8re colonne)  donne un minterme. Toutes les variables sont pr\u00e9sentes et une variable \\(v\\) \\(y\\) appara\u00eet positivement (\\(v\\)) si sa valeur de v\u00e9rit\u00e9 dans la ligne est \\(1\\), n\u00e9gativement (\\(\\neg v\\)) sinon.  </li> <li>On consid\u00e8re la disjonction de tous les mintermes ainsi obtenus. C'est une expression \\(q\\) en FNDC. Possiblement \\(q\\) est vide.  </li> <li>Soit \\(\\mu\\) un contexte. Si \\(\\varepsilon_\\mu(p) = 1\\), alors le minterme associ\u00e9 \u00e0 \\(\\mu\\) est  vrai pour \\(\\mu\\) donc \\(\\varepsilon_\\mu(q) = 1\\).  </li> <li>Si \\(\\varepsilon_\\mu(p) = 0\\), alors \\(q\\) ne contient pas le minterme associ\u00e9 \u00e0 \\(\\mu\\). Ainsi, pour tout minterme \\(m\\) de \\(q\\), on a \\(\\varepsilon_\\mu(m)=0\\) et donc \\(\\varepsilon_\\mu(q) = 0\\). </li> <li>\\(\\color{red}{\\textsf{Donc } p \\textsf{ et } q \\textsf{ prennent bien la m\u00eame valeur pour tout contexte.}}\\) </li> </ul>"},{"location":"Logique/1-Logique/#unicite-de-la-fndc-a-lordre-pres","title":"Unicit\u00e9 de la FNDC \u00e0 l'ordre pr\u00e8s","text":"<p>Soient \\(p \\equiv q\\) deux FNDC. Elles ont donc m\u00eame table.</p> <ul> <li>Si \\(p \\neq q\\) et \\(p, q\\) ne poss\u00e8dent qu'un minterme :  </li> <li>Si \\(p, q\\) ont deux litt\u00e9raux \\(l, l'\\) de la m\u00eame variable \\(v\\) distincts, l'un des  litt\u00e9raux vaut \\(\\neg v\\) l'autre \\(v\\) . Autrement dit \\(l \\equiv \\neg l'\\)</li> <li>Comme \\(p\\) est une conjonction, il n'y a qu'un seul contexte \\(c\\) (i.e. une  seule ligne) dans lequel \\(p\\) vaut \\(1\\).</li> <li>Alors \\(l\\) vaut aussi \\(1\\) dans ce contexte (\\(p\\) \u00e9tant une conjonction).</li> <li>Donc \\(l'\\) vaut \\(0\\) dans \\(c\\). Et donc \\(q\\) vaut \\(0\\) dans \\(c\\). \\(p\\) et \\(q\\) ne peuvent avoir m\u00eame table.</li> <li>De ce qui pr\u00e9c\u00e8de, on d\u00e9duit aussi que des mintermes (ayant les m\u00eames  variables) distincts ne valent jamais \\(1\\) en m\u00eame temps.  </li> <li>On a vu que si \\(p \\neq q\\) et \\(p, q\\) ne poss\u00e8dent qu'un minterme, leurs tables sont diff\u00e9rentes. On en d\u00e9duit que des mintermes distincts ne valent jamais \\(1\\) en m\u00eame temps.</li> <li>Si \\(p\\) et \\(q\\) sont des disjonctions de mintermes, et si un minterme \\(m\\) de \\(p\\) ne se retrouve pas dans \\(q\\) :  </li> <li>Lorsque \\(m\\) vaut \\(1\\), \\(p\\) aussi (comme disjonction). Tous les autres  mintermes valent \\(0\\) (puisque un seul minterme vaut \\(1\\) pour un contexte donn\u00e9), ceux de \\(p\\) comme ceux de \\(q\\).  </li> <li>Alors dans ce contexte, comme disjonction de \\(0\\), \\(q\\) vaut \\(0\\).  </li> <li>Et donc \\(p\\) et \\(q\\) ne peuvent avoir m\u00eame table.  </li> </ul>"},{"location":"Logique/1-Logique/#fncc","title":"FNCC","text":"<p>Soit une expression \\(p\\) \u00e0 \\(n\\) variables,</p> <p>Existence</p> <ul> <li>\\(\\neg p\\) a une FNDC \\(c_1 \\vee \\dotsb \\vee  c_n\\) o\u00f9 les \\(c_i\\) sont des mintermes.</li> <li>Donc \\(p\\) se r\u00e9\u00e9crit comme \\((\\neg c_1) \\wedge  \\dotsb \\wedge (\\neg c_n)\\). Or les n\u00e9gations de mintermes se r\u00e9\u00e9crivent en maxtermes (par De Morgan).</li> <li>Et donc \\(p\\) se r\u00e9\u00e9crit en une FNCC. Voil\u00e0 pour l'existence.</li> </ul> <p>Unicit\u00e9</p> <p>Si \\(p\\) avait deux FNCC distinctes, par De Morgan \\(\\neg p\\) aurait deux FNDC distinctes. Or il y a une seule FNDC possible pour une formule.</p>"},{"location":"Logique/1-Logique/#probleme-sat","title":"Probl\u00e8me SAT","text":""},{"location":"Logique/1-Logique/#probleme-sat-et-n-sat","title":"Probl\u00e8me SAT et \\(n\\)-SAT","text":""},{"location":"Logique/1-Logique/#presentation-du-probleme-2-sat","title":"Pr\u00e9sentation du probl\u00e8me \\(2\\)-SAT","text":"<ul> <li>Le probl\u00e8me SAT qui consiste \u00e0 d\u00e9terminer si une proposition est  satisfiable ou non est en g\u00e9n\u00e9ral de complexit\u00e9 exponentielle en le  nombre de variables.  </li> <li>Le probl\u00e8me CNF-SAT est la restriction du probl\u00e8me SAT aux formes  normales conjonctives.  </li> <li>Le probl\u00e8me \\(n\\)-SAT est la restriction du probl\u00e8me SAT aux formes  normales conjonctives avec au plus \\(n\\) litt\u00e9raux par clause. Nous verrons l'alogrithme de Quin qui r\u00e9soud le porbl\u00e8me CNF-STAT : il est souvent m\u00e9illeur que la recherche exhaustive en force brute.</li> <li>Le probl\u00e8me \\(2\\)-SAT consiste \u00e0 d\u00e9terminer si une forme conjonctive  dont les clauses ont seulement deux litt\u00e9raux est satisfiable. Il admet des solutions polyn\u00f4miales.  </li> </ul>"},{"location":"Logique/1-Logique/#le-probleme-sat","title":"Le probl\u00e8me SAT","text":"<ul> <li>Comment tester qu'une proposition est satisfiable ? Il s'agit du  probl\u00e8me dit SAT.  </li> <li>Comment tester qu'une proposition \\(p\\) est une tautologie ? Si on sait  r\u00e9soudre le probl\u00e8me SAT, il suffit de montrer que \\(\\neg p\\) est insatisfiable.  </li> <li>Pour le probl\u00e8me SAT, on peut simplement calculer sa table. Mais on  a alors une complexit\u00e9 en \\(O(2^n)\\), si \\(n\\) est le nombre de variables.  </li> <li>Des algorithmes plus efficaces (en pratique, c'est \u00e0 dire sauf cas  pathologiques) existent (DPLL) et passent par une mise sous FNC.  Mais dans le pire des cas ce passage \u00e0 la FNC est lui-m\u00eame de  complexit\u00e9 exponentielle.  </li> </ul>"},{"location":"Logique/1-Logique/#probleme-2-sat","title":"Probl\u00e8me 2-SAT","text":""},{"location":"Logique/1-Logique/#2-sat","title":"2-SAT","text":"<p>Cette section est laiss\u00e9e pour info mais sera trait\u00e9e en seconde ann\u00e9e.  </p>"},{"location":"Logique/1-Logique/#probleme-2-sat-aspvall-plass-tarjan","title":"Probl\u00e8me 2-SAT (Aspvall-Plass-Tarjan)","text":"<p>Soit \\(p\\) une proposition mise sous forme conjonctive avec des \\(2\\)-clauses</p> <ul> <li>On construit un graphe orient\u00e9 :  </li> <li>Ses sommets sont tous les litt\u00e9raux form\u00e9s avec les variables  apparaissant dans la proposition.</li> <li>Les arcs sont des couples de litt\u00e9raux de la forme \\((a, \\neg b)\\) ou \\((\\neg a, b)\\)  mais pas tous ...</li> <li>Pour deux litt\u00e9raux \\(a, b\\), l'arc \\((\\neg a, b)\\) est pr\u00e9sent si et seulement si la  disjonction \\(a \\vee b\\) est dans \\(p\\). Et dans ce cas \\((a, \\neg b)\\) est pr\u00e9sent aussi.</li> <li>Ceci correspond \u00e0 \\(a \\vee  b \\equiv (\\neg a \\rightarrow  b) \\wedge  (\\neg b \\rightarrow  a)\\) </li> <li>Une fois ce graphe construit, on examine la composante fortement  connexe de toute variable \\(v\\) de \\(p\\). Si \\(\\neg v\\) est dedans, il y a un chemin d'implications \\(v \\rightarrow  \\dotsb \\rightarrow  \\neg v\\) et un autre \\(\\neg v \\rightarrow  \\dotsb \\rightarrow  v\\).  </li> <li>Alors \\(v \\Leftrightarrow \\neg v\\) est une cons\u00e9quence de \\(p : p \\models v \\Leftrightarrow \\neg v\\) (ce qui  signifie que tout mod\u00e8le satisfaisant p, satisfait \\(v \\Leftrightarrow \\neg v\\) ). Donc si \\(p\\) est satisfiable, \\(v \\Leftrightarrow \\neg v\\) aussi : ABSURDE.  </li> <li>Donc si \\(v\\) et \\(\\neg v\\) sont dans la m\u00eame composante connexe, \\(p\\) n'est pas satisfiable (Aspvall-Plass-Tarjan).  </li> </ul> <p>Exemple (Mansuy)</p> <p>\\(p = (v_1 \\vee  v_2) \\wedge  (\\neg v_1 \\vee  v_3) \\wedge  (v_1 \\vee  \\neg v_2) \\wedge  (\\neg v_2 \\vee  v_3) \\wedge  (\\neg v_1 \\vee  \\neg v_3)\\) donne le graphe  </p> <p><p></p></p> <ul> <li>\\(\\neg v_1\\) acc\u00e8de \u00e0 \\(v_1\\) via \\(v_2\\) et</li> <li>\\(v_1\\) acc\u00e8de \u00e0 \\(\\neg v_1\\) via \\(\\neg v_3\\) </li> <li>Donc \\(v_1\\) et \\(\\neg v_1\\) sont dans la m\u00eame composante connexe.</li> <li>Par suite \\(p\\) n'est pas satisfiable.  </li> </ul>"},{"location":"Logique/1-Logique/#conclusion-pour-le-probleme-sat","title":"Conclusion pour le probl\u00e8me SAT","text":"<ul> <li>Le probl\u00e8me SAT est le probl\u00e8me algorithmique qui consiste, \u00e9tant  donn\u00e9e une formule \u00e0 d\u00e9cider en FNC si elle valide ou non.  </li> <li>Le probl\u00e8me est NP-complet, m\u00eame pour le cas particulier \\(3\\)-SAT o\u00f9 on n'autorise que les clauses d'au plus trois litt\u00e9raux.</li> <li>Un probl\u00e8me \\({\\displaystyle {\\mathcal {P}}}\\) NP-complet v\u00e9rifie :  </li> <li>Il est possible de v\u00e9rifier une solution de \\({\\displaystyle {\\mathcal {P}}}\\) efficacement (en temps  polynomial) : on me donne un candidat solution, et je peux v\u00e9rifier en temps polynomial ce qu'il en est. La classe des probl\u00e8mes v\u00e9rifiant cette propri\u00e9t\u00e9 est not\u00e9e NP.</li> <li>tous les probl\u00e8mes de la classe NP se ram\u00e8nent \u00e0 \\({\\displaystyle {\\mathcal {P}}}\\) via une r\u00e9duction polynomiale. Cela signifie que le probl\u00e8me est au moins aussi difficile que tous les autres probl\u00e8mes de la classe NP (aspect \"complet\"). Appliqu\u00e9 \u00e0 la satisfiabilit\u00e9, cela signifie que si on me donne un probl\u00e8me de la classe NP, je peux le transformer en temps polynomial en un probl\u00e8me de satisfiabilit\u00e9.</li> <li>Bien s\u00fbr, un probl\u00e8me de la classe P (polynomial) v\u00e9rifie la premi\u00e8re  condition. On a donc P \\(\\subset\\) NP, mais a-t-on NP \\(\\subset\\) P ?  </li> </ul>"},{"location":"Logique/2-Quine/","title":"Algorithme de Quine","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Un cours de mon coll\u00e8gue Q. fortier</li> <li>Ce cours de l\u2019universit\u00e9 de Montpellier : ici</li> </ul>"},{"location":"Logique/2-Quine/#substitution","title":"Substitution","text":"<p>Notation</p> <ul> <li> <p>Si \\(x\\) est une variable, la notation \\([x \u2190 T]\\) d\u00e9signe le contexte partiel qui remplace \\(x\\) par \\(T\\) (True) et n\u2019affecte aucune autre variable.</p> </li> <li> <p>La notation \\([x \u2190 T][y \u2190 F]\\) d\u00e9signe le contexte partiel qui remplace \\(x\\) par \\(T\\) (True) ; \\(y\\) par \\(F\\) (False) et n\u2019affecte aucune autre variable. De m\u00eame : \\(\\sum_{i=1}^n{[x_i \u2190 C_i]}\\) d\u00e9signe contexte partiel qui remplace chaque \\(x_i\\) par la constante \\(C_i\\) (vrai ou faux).</p> </li> <li> <p>Si \\(P\\) est une proposition et \\(x\\) une variable, \\(P[x \u2190 T]\\) d\u00e9signe \\(P\\) dans laquelle toutes les occurrences de \\(x\\) sont remplac\u00e9es par \\(T\\) (True). Et \\(P\\) \\(\\sum_{i=1}^n{[x_i \u2190 C_i]}...\\) \u00e0 votre avis ?</p> </li> </ul>"},{"location":"Logique/2-Quine/#satisfiabilite-par-backtracking","title":"Satisfiabilit\u00e9 par backtracking","text":"<p>On dispose de <code>evaluer (P:prop., \u00b5:ctxt complet)</code></p> Listing 1 \u2013 Algorithme de satisfiabilit\u00e9<pre><code>fonction sat (P : proposition ;\n              L : ensemble de variables \u00e0 remplacer par T/F,\n              \u00b5 : contexte partiel)\n    sortie : un boul\u00e9en\n    si L est vide renvoyer evaluer (P, \u00b5)\n    prendre x \u2208 L\n    si sat (P, L\\{x}, \u00b5 \u25e6 [x \u2190 T])\n        alors renvoyer Vrai\n    sinon renvoyer sat (P, L\\{x}, \u00b5 \u25e6 [x \u2190 F])\n</code></pre> <p>Cette fonction r\u00e9alise donc un bactracking et teste potentiellement \\(2^{\\text{nb de variables de P}}\\) contextes.</p> <p>appel initial : <code>evaluer(P, liste var de P)</code>.</p>"},{"location":"Logique/2-Quine/#lalgorithme-de-quine","title":"L'Algorithme de Quine","text":"<p>L\u2019algorithme de Quine prend en param\u00e8tre une proposition en FNC et r\u00e9alise un backtracking (comme la recherche de satisfiabilit\u00e9 en force brute).</p> <pre><code>prendre une variable x restante dans la formule\ntester r\u00e9cursivement si P[x \u2190 T] est satisfiable\ntester r\u00e9cursivement si P[x \u2190 F] est satisfiable\n</code></pre> <p>En revanche, chaque substitution est l\u2019occasion de supprimer un litt\u00e9ral d\u2019une clause ou une clause de la formule.</p>"},{"location":"Logique/2-Quine/#suppression-de-litteral-ou-de-clause","title":"Suppression de litt\u00e9ral ou de clause","text":"<p>Soit \\(x\\) une variable et \\(P\\) une proposition en forme normale conjonctive : \\(P = c_1 \u2227 c_2 \u2227 \u00b7 \u00b7 \u00b7 \u2227 c_n\\). Lors de la substitution \\(P[x \u2190 T]\\) on effectue des simplifications :</p> <ul> <li> <p>Si une clause contient le litt\u00e9ral \\(x\\), on enl\u00e8ve cette clause car elle est de la forme \\(v_1 \u2228 v_2 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \\underbrace{T}_{\\text{emplacement de } x} \u2228 \u00b7 \u00b7 \u00b7 \u2228 v_k\\) donc vraie.</p> </li> <li> <p>Si une clause contient \\(\u00acx\\), on supprime ce litt\u00e9ral de cette clause car il est faux (\\(F\\) est l\u2019\u00e9l\u00e9ment neutre de la disjonction). \\(v_1 \u2228 v_2 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \\underbrace{\u00acT}_{\\text{emplacement de } x} \u2228 \u00b7 \u00b7 \u00b7 \u2228 v_k\\)</p> </li> </ul> <p>Lors de la substitution \\(P[x \u2190 F]\\) on effectue des simplifications :</p> <ul> <li>Si une clause contient \\(\u00acx\\), on enl\u00e8ve cette clause car elle est de la forme \\(v_1 \u2228 v_2 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \\underbrace{\u00acF}_{\\text{emplacement de } x} \u2228 \u00b7 \u00b7 \u00b7 \u2228 v_k\\) donc vraie.</li> <li>Si une clause contient \\(x\\), on supprime ce litt\u00e9ral de cette clause car il est faux. \\(v_1 \u2228 v_2 \u2228 \u00b7 \u00b7 \u00b7 \u2228 \\underbrace{F}_{\\text{emplacement de } x} \u2228 \u00b7 \u00b7 \u00b7 \u2228 v_k\\) donc vraie.</li> </ul>"},{"location":"Logique/2-Quine/#proposition-ou-clause-vide","title":"Proposition ou clause vide","text":"<p>On supprime \u00e0 chaque \u00e9tape soit une/des clause(s) soit un/des litt\u00e9ral/litt\u00e9raux.</p> <p>Si une clause devient vide (disjonction de \\(0\\) propositions), la clause est fausse donc la formule (qui est une conjonction de clause) est fausse aussi. On backtrack.</p> <p>Si la proposition devient vide (conjonction de \\(0\\) propositions), la formule est vraie. C\u2019est gagn\u00e9 !</p>"},{"location":"Nombres/1-Entiers/","title":"Repr\u00e9sentation des entiers","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Wikip\u00e9dia : Compl\u00e9ment \u00e0 deux et ce Wiki</li> <li>cpprefrence (Fonction de biblioth\u00e8ques en C)</li> <li>Les cours de mes coll\u00e8gues Nicolas P\u00e9cheux et Quentin Fortier</li> </ul>"},{"location":"Nombres/1-Entiers/#boutisme","title":"Boutisme","text":"<p>En informatique, certaines donn\u00e9es telles que les nombres entiers peuvent \u00eatre repr\u00e9sent\u00e9es sur plusieurs octets. L'ordre dans lequel ces octets sont organis\u00e9s en m\u00e9moire ou dans une communication est appel\u00e9 endianness (mot anglais traduit par \"boutisme\" ou par \"endianisme\" ).</p> <p>De la m\u00eame mani\u00e8re que certains langages humains s'\u00e9crivent de gauche \u00e0 droite, et d'autres s'\u00e9crivent de droite \u00e0 gauche, il existe une alternative majeure \u00e0 l'organisation des octets repr\u00e9sentant une donn\u00e9e : l'orientation big-endian et l'orientation little-endian.</p> <p>En maths, la convention d'\u00e9criture des polyn\u00f4mes est le big-endian (ou mot de poids fort en t\u00eate) comme dans \\(X^3 + X^2 + 1\\).</p>"},{"location":"Nombres/1-Entiers/#gulliver","title":"Gulliver","text":"<p>Les termes big-endian et little-endian ont \u00e9t\u00e9 popularis\u00e9s dans le domaine informatique par Dany Cohen, en r\u00e9f\u00e9rence aux \"Voyages de Gulliver\" , roman satirique de Jonathan Swift.</p> <p>En \\(1721\\), Swift d\u00e9crit comment de nombreux habitants de Lilliput refusent d'ob\u00e9ir \u00e0 un d\u00e9cret obligeant \u00e0 manger les oeufs \u00e0 la coque par le petit bout.</p> <p>La r\u00e9pression pousse les rebelles, dont la cause est appel\u00e9e big-endian, \u00e0 se r\u00e9fugier dans l'empire rival de Blefuscu ce qui entretient une guerre longue et meurtri\u00e8re entre les deux empires.</p> <p></p> <p>Figure \u2013 un oeuf</p>"},{"location":"Nombres/1-Entiers/#big-endian-gros-boutisme","title":"Big-endian (gros-boutisme)","text":"<p>Soit un entier sur \\(32\\) bits \u00e0 \u00e9crire en en m\u00e9moire, par exemple \\(\\texttt{0xA0B70708}\\) en notation hexad\u00e9cimal. Pour une structure de m\u00e9moire fond\u00e9e sur une unit\u00e9 atomique de \\(1\\) octet et un incr\u00e9ment d'adresse de \\(1\\) octet, la convention big-endian consiste \u00e0 enregistrer \\(\\texttt{A0}\\) \u00e0 l'adresse m\u00e9moire la plus petite et \\(\\texttt{08}\\) \u00e0 la plus grande.</p> ... \\(\\texttt{A0}\\) \\(\\texttt{B7}\\) \\(\\texttt{07}\\) \\(\\texttt{08}\\) ... <p>Tous les protocoles TCP/IP communiquent en big-endian. Il en va de m\u00eame pour le protocole PCI Express. Les processeurs Motorola 68000, les SPARC (Sun Microsystems), les System/370 (IBM) sont des architectures qui respectent cette r\u00e8gle</p>"},{"location":"Nombres/1-Entiers/#little-endian-petit-boutisme","title":"Little-endian (petit-boutisme)","text":"<p>En little-endian (\"mot de poids faible en t\u00eate\" ), le nombre \\(\\texttt{0xA0B70708}\\) est enregistr\u00e9, pour une structure de m\u00e9moire fond\u00e9e sur une unit\u00e9 atomique de \\(1\\) octet et un incr\u00e9ment d'adresse de \\(1\\) octet, avec \\(\\texttt{08}\\) \u00e0 l'adresse m\u00e9moire la plus petite, \\(\\texttt{A0}\\) \u00e0 la plus grande.</p> ... \\(\\texttt{08}\\) \\(\\texttt{07}\\) \\(\\texttt{B7}\\) \\(\\texttt{A0}\\) ... <p>Par exemple, les processeurs \\(x86\\) ont une architecture petit-boutiste.</p> <p>L'inconv\u00e9nient du little-endian est la moindre lisibilit\u00e9 du code machine par le programmeur. Son int\u00e9r\u00eat r\u00e9side dans la plus grande rapidit\u00e9 des op\u00e9rations arithm\u00e9tiques.</p> <p>Dans ce cours, nous repr\u00e9sentons les nombres de fa \u0327con plus lisible pour le programmeur, c'est \u00e0 dire selon la convention big-endian (bit de poids fort en t\u00eate)</p>"},{"location":"Nombres/1-Entiers/#base-de-representations","title":"Base de repr\u00e9sentations","text":""},{"location":"Nombres/1-Entiers/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":""},{"location":"Nombres/1-Entiers/#base-2","title":"Base \\(2\\)","text":"<p>Un nombre en base \\(2\\) peut-\u00eatre vu comme un \u00e9tat de case m\u00e9moire. La base \\(2\\) est de plus tr\u00e8s pratique pour les calculs arithm\u00e9tiques.</p> <p>Nombres entiers : Couramment stock\u00e9s sur \\(32\\) ou \\(64\\) bits. Dans les exemples ci-dessous : souvent sur \\(8\\) bits (pour des raisons de place).</p> <p>Sur \\(8\\) bits, entiers entre \\(0\\) et \\(2^8 \u22121 = 255\\). Sur \\(N\\) bits, on repr\u00e9sente tous les entiers de \\(0\\) \u00e0 \\(2N \u22121\\).</p> <p>Un octet \\(= 8\\) bits. Avec un octet on repr\u00e9sente \\(256\\) nombres : le plus souvent sur \\([\\![0,255]\\!]\\)ou \\([\\![-128,127]\\!]\\).</p> <p>En base \\(2\\) sur \\(32\\) bits, on repr\u00e9sente les entiers de \\(0\\) \u00e0 \\(2^{32} \u22121 = 4294967295\\) (\\(4\\) milliards environ).</p>"},{"location":"Nombres/1-Entiers/#conventions","title":"Conventions","text":"<p>Pour distinguer cent un en base \\(10\\), du nombre cinq \u00e9crit en base \\(2\\), on indice l'\u00e9criture binaire. \\(101\\) (en base \\(10\\)) ou \\(101_2\\) (en base \\(2\\)).</p> <p>Pour les autres bases, on indique le nombre de symboles, par exemple \\(432_5\\) repr\u00e9sente un nombre en base \\(5\\).</p>"},{"location":"Nombres/1-Entiers/#passage-de-la-base-10-a-la-base-k","title":"Passage de la base 10 \u00e0 la base k","text":"<p>fonction changement_base(n, k)     entree : n (le nb)     entree : k (la base)     sortie : a, suite des coefs de n en base k     a := suite vide     tant que n !=0 :         debut         ajouter \u00e0 a le reste de la division de n par k         n := quotient de la division de n par k         fin         Inverser la suite a /\u2217 pour Big\u2212Endian \u2217/ renvoyer la suite des restes</p> <p>Exercice</p> <p>\u00e9crire \\(123\\) en binaire.    </p> <p><p></p></p> <p>Figure \u2013 M\u00e9thode \\(1\\)</p> <p>\\(123 = 111 \\text{ }1001_2\\)</p> <p>pour la base deux \u00e0 dix</p> <p>\\(1111011_2\\) repr\u00e9sente \\(123\\) :</p> <p>\\(1 \u00d72^6 + 1 \u00d72^5 + 1 \u00d72^4 + 1 \u00d72^3 + 0 \u00d72^2 + 1 \u00d72^1 + 1 \u00d72^0 = 123\\).</p>"},{"location":"Nombres/1-Entiers/#operations-en-base-2","title":"Op\u00e9rations en base \\(2\\)","text":""},{"location":"Nombres/1-Entiers/#addition-en-binaire","title":"Addition en binaire","text":"<p>Principe :</p> \\(0 + 0\\) \\(=\\) \\(0\\) \\(0 + 1\\) \\(=\\) \\(1\\) \\(1 + 0\\) \\(=\\) \\(1\\) \\(1 + 1\\) \\(=\\) \\(0\\) (avec retenue) <pre><code>    \u2217 \u2217       \u2217 \u2217        (\u2217 : retenue)\n  1 0 1 1 1 1 0 1 1\n+     1 1 0 0 0 0 1\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\n= 1 1 1 0 1 1 1 0 0\n</code></pre> <p>Ceci est cabl\u00e9 dans le processeur dans la partie r\u00e9serv\u00e9e aux calculs arithm\u00e9tiques et logiques (UAL).</p>"},{"location":"Nombres/1-Entiers/#soustraction-en-binaire","title":"Soustraction en binaire","text":"<p>Principe :</p> \\(0 - 0\\) \\(=\\) \\(0\\). Retenue : non \\(0 - 1\\) \\(=\\) \\(1\\). Retenue : oui \\(0 - (1+{\\color{red}1})\\) \\(=\\) \\(0\\). O\u00f9 le \\({\\color{red}1}\\) est la retenue. Retenue : oui \\(1 - (1+{\\color{red}1})\\) \\(=\\) \\(1\\). O\u00f9 le \\({\\color{red}1}\\) est la retenue. Retenue : oui \\(1 - 0\\) \\(=\\) \\(1\\). Retenue : non \\(1 - 1\\) \\(=\\) \\(0\\). Retenue : non <pre><code>    \u2217   \u2217 \u2217 \u2217        (\u2217 : retenue)\n  1 1 0 1 1 1 0 \n-     1 0 1 1 1\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212-\n= 1 0 1 0 1 1 1\n</code></pre> <p>La retenue est \u00e0 ajouter aux chiffres sur la ligne du bas.</p> <p>Exemple</p> <p>\\(100 - 011 = 001\\)</p>"},{"location":"Nombres/1-Entiers/#3-entiers-non-signes","title":"3 Entiers non sign\u00e9s","text":""},{"location":"Nombres/1-Entiers/#cas-du-c","title":"Cas du C","text":""},{"location":"Nombres/1-Entiers/#presentation","title":"Pr\u00e9sentation","text":"<p>Un entier non sign\u00e9 ( unsingned int ) est un entier positif, qui est stock\u00e9 en m\u00e9moire avec sa repr\u00e9sentation en base \\(2\\) sans interpr\u00e9tation particuli\u00e8re de son bit de poids fort.</p> <p>Si les entiers sont cod\u00e9s sur \\(4\\) octets, alors le plus grand entier non sign\u00e9 est \\(2^{32} \u22121\\) soit \\(4294967295\\).</p> <p>Le comportement de ces nombres est cyclique.</p> <p>Conseil : on ne doit les utiliser que si ce comportement cyclique est attendu. Et il faut surtout \u00e9viter de m\u00e9langer les types sign\u00e9s et non sign\u00e9s dans un m\u00eame calcul \u00e0 moins d'avoir bien lu (l'indigeste) norme !</p> <p>Ces nombres ne peuvent \u00eatre n\u00e9gatifs, un nombre n\u00e9gatif est donc automatiquement converti en son \u00e9quivalent modulo \\(2^{32}\\)</p> <p>Le code suivant :</p> <pre><code>unsigned x = 42;\nprintf(\"%u\\n \", x); // %u pour unsigned int\nx = \u22121; printf(\"%u\\n\", x); // affiche le + grand\nnombre\nx=4294967295; printf(\"%u\\n\", x+1);\n</code></pre> <p>produit :</p> <pre><code>42\n4294967295\n0\n</code></pre>"},{"location":"Nombres/1-Entiers/#conversion-automatique-de-types","title":"Conversion automatique de types","text":"<p>La somme d'un entier non sign\u00e9 et d'un entier sign\u00e9 est convertie en un entier sign\u00e9.</p> <p>Que donne l'affichage de ce programme ?</p> <pre><code>unsigned a = 0;\nint b = \u22121;\nif (a + b &gt; 0)\n    printf(\"Hello\\n\"); // Mais combien  vaut a+b ?\nelse\n    printf(\"Coucou\\n\");\n</code></pre> <p>Perdu : c'est \\(\\texttt{\"Hello\"}\\) !</p> <p>Lorsqu'on compare un entier sign\u00e9 et non sign\u00e9, le sign\u00e9 est converti en non sign\u00e9 : Que donne l'affichage de ce programme ?</p> <pre><code>unsigned a = 0;\nint b = \u22121;\nif (a &gt; b)\n    printf(\"Hello\\n\"); \nelse\n    printf(\"Coucou\\n\");\n</code></pre> <p>Perdu : c'est \\(\\texttt{\"Coucou\"}\\) ! En effet, \\(\u22121\\) est converti en \\(2^{32} \u22121...\\)</p>"},{"location":"Nombres/1-Entiers/#cas-du-ocaml","title":"Cas du Ocaml","text":"<p>En travaux</p>"},{"location":"Nombres/1-Entiers/#entiers-signes","title":"Entiers sign\u00e9s","text":""},{"location":"Nombres/1-Entiers/#principe","title":"Principe","text":""},{"location":"Nombres/1-Entiers/#mettre-le-signe-en-bit-de-poids-fort","title":"Mettre le signe en bit de poids fort","text":"<p>Sur \\(8\\) bits on repr\u00e9sente les entiers non sign\u00e9s de \\(0\\) \u00e0 \\(255\\).</p> <p>Sur \\(8\\) bits on voudrait maintenant repr\u00e9senter les nombres de \\(-128\\) \u00e0 \\(127\\).</p> <p>Notation utilis\u00e9e sur des \u00e9critures de nombres de longueur donn\u00e9e (\\(8\\), \\(16\\), \\(32\\) bits). Bit de poids fort du nombre pour le signe.</p> <p>Premi\u00e8re id\u00e9e \\(00000010_2 = +2\\) en d\u00e9cimal et \\(10000010_2 = \u22122\\) en d\u00e9cimal. PB :</p> <ul> <li>Le nombre \\(0\\) poss\u00e8de deux repr\u00e9sentations \\(10000000_2\\) et \\(00000000_2\\) (\\(0\\) et \\(\u22120\\)).</li> <li>Il faudrait modifier l'algorithme d'addition. Si un des nombres est n\u00e9gatif : erreur. Ainsi \\(3 + (\u22124) = \u22121\\) Mais \\(00000011_2 + 10000100_2 = 10000111_2 \u2192 \u22127\\).</li> </ul>"},{"location":"Nombres/1-Entiers/#representation-des-entiers-signes-en-complement-a-2-sur-8-bits","title":"Repr\u00e9sentation des entiers sign\u00e9s en compl\u00e9ment \u00e0 \\(2\\) sur \\(8\\) bits","text":"<p>Prenons l'exemple des mots de \\(8\\) bits : on peut repr\u00e9senter les entiers relatifs compris entre \\(\u22122^{8\u22121} = \u2212128\\) et \\(2^{8\u22121} \u22121 = 127\\)</p> <p>entier relatif \\(x\\) positif ou nul : pas de changement.</p> <p>entier relatif \\(x\\) strictement n\u00e9gatif : repr\u00e9sent\u00e9 par l'entier naturel \\(x + 2^8 = x + 256\\), qui est compris entre \\(128\\) et \\(255\\).</p> <p>Ainsi les entiers naturels de \\(0\\) \u00e0 \\(127\\) servent \u00e0 repr\u00e9senter les entiers relatifs positifs ou nul</p> <p>Et les entiers naturels de \\(128\\) \u00e0 \\(255\\) servent \u00e0 repr\u00e9senter les entiers relatifs strictement n\u00e9gatifs</p>"},{"location":"Nombres/1-Entiers/#complement-a-2-sur-8-bits","title":"Compl\u00e9ment \u00e0 2 sur 8 bits","text":""},{"location":"Nombres/1-Entiers/#representation-des-entiers-signes-en-complement-a-2-sur-n-bits-ca2_n","title":"Repr\u00e9sentation des entiers sign\u00e9s en compl\u00e9ment \u00e0 \\(2\\) sur \\(N\\) bits (\\(CA2\\_N\\))","text":""},{"location":"Nombres/1-Entiers/#methode-1","title":"M\u00e9thode 1","text":"<p>On veut repr\u00e9senter un nombre \\(\u22122^{N \u22121} \u2264X &lt;2^{N \u22121}\\) en \\(CA2\\_N\\) (donc \\(|X|\\) tient sur \\(N \u22121\\) bits) :</p> <ul> <li>Si \\(X\\) est n\u00e9gatif, on calcule la repr\u00e9sentation binaire de \\(2^N + X\\) . Le premier bit sera automatiquement \\(1\\).</li> <li>Si \\(X\\) est positif, le premier bit sera \u00e0 \\(0\\) et les \\(N \u22121\\) autres bits seront la repr\u00e9sentation de \\(X\\) en base \\(2\\) sur (\\(N \u22121\\)) bits.</li> </ul> <p>\\(-67\\) en compl\u00e9ment \u00e0 \\(2\\) sur \\(8\\) bits. :</p> <ul> <li>\\(2^8 \u221267 = 189\\)</li> <li>\\(189 \u2192\\overline{10111101}^8\\).</li> </ul>"},{"location":"Nombres/1-Entiers/#ca2_n-compatibilite-avec-laddition","title":"\\(CA2\\_n\\) compatibilit\u00e9 avec l'addition","text":"<p>On reprend l'exemple de \\(3 + (\u22124)\\).</p> <p>En \\(CA2\\_8\\), 3 s'\u00e9crit comme \\(\\overline{00000011}^8\\) En \\(CA2\\_8\\), pour \\(\u22124\\) :</p> <ul> <li>\\(\u22124 + 256 = 252 7\u2192\\overline{11111100}^8\\)</li> </ul> <p>Addition en binaire :</p> <pre><code>  0 0 0 0 0 0 1 1\n+ 1 1 1 1 1 1 0 0\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\n= 1 1 1 1 1 1 1 1\n</code></pre> <p>Que des \\(1\\) : il s'agit de \\(\u22121\\) en \\(CA2\\_8\\). Plus besoin de modifier l'algorithme d'addition !</p>"},{"location":"Nombres/1-Entiers/#methode-2","title":"M\u00e9thode 2","text":"<p>Compl\u00e9ment \u00e0 \\(2\\) (sur \\(n\\) bits). Ici \\(n = 8\\).</p> <ul> <li>Si le nombre est positif, donner son expression en binaire sur \\(n\\) bits.</li> <li>Si c'est \\(\u22122^{N \u22121}\\) son compl\u00e9ment \u00e0 \\(2\\) est \\(1\\) suivi de \\(N\u22121\\) z\u00e9ros.</li> <li>Si le nombre est n\u00e9gatif mais \\(&gt;\u22122^{N \u22121}\\). Inverser tous les bits du binaire de sa valeur absolue (ie. transformer \\(1\\) en \\(0\\) et lyc\u00e9e de Versailles).</li> <li>Ajouter \\(1\\) au bit de poids faible (attention aux retenues) !</li> </ul> <p>\\(-67\\) en compl\u00e9ment \u00e0 \\(2\\) sur \\(8\\) bits. :</p> <ul> <li>\\(67\\) : \\(01000011_2\\)</li> <li>inversion : \\(10111100_2\\)</li> <li>ajout de \\(1\\) au bit de poids faible : \\(10111101_2\\). Finalement \\(\\overline{1011\\text{ }1101}^8\\).</li> </ul>"},{"location":"Nombres/1-Entiers/#calcul-de-tete","title":"Calcul de t\u00eate","text":"<p>Si l'on doit transformer un nombre n\u00e9gatif non nul en son compl\u00e9ment \u00e0 deux \"de t\u00eate\", un bon moyen est de garder tous les chiffres depuis la droite jusqu'au premier 1 (compris) puis d'inverser tous les suivants.</p> <ul> <li>Prenons par exemple le nombre \\(-20\\)</li> <li>Codage binaire de sa valeur absolue \\(20\\) : \\(00010100\\)</li> <li>On garde la partie \u00e0 droite telle quelle : \\(00010\\)\\(100\\) On inverse la partie de gauche apr\u00e8s le premier un : \\(11101\\)\\(100\\) Et voici \\(-20 : \\overline{11101100}^8\\).</li> </ul>"},{"location":"Nombres/1-Entiers/#soustraction-binaire-grace-au-complement-a-2","title":"Soustraction binaire gr\u00e2ce au compl\u00e9ment \u00e0 \\(2\\)","text":"<p>On veut effectuer \\(15 \u221214\\)</p> <p>En binaire \\(15 \u21921111_2\\) et \\(14 \u21921110_2\\)</p> <p>\\(15\\) et \\(\u221214\\) peuvent s'\u00e9crire en \\(CA2\\_5\\). \\(15 \u2192\\overline{01111}^5\\) et \\(\u221214\u2192\\overline{10010}^5\\)</p> <p>On effectue ensuite une simple addition en \\(CA2\\_5\\).</p> <pre><code>    \u2217 \u2217 \u2217\n    0 1 1 1 1\n    1 0 0 1 0\n+\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\n(1) 0 0 0 0 1\n</code></pre> <p>Le bit le plus \u00e0 gauche (\\(1\\)) est un artefact (Alt\u00e9ration du r\u00e9sultat d'un examen due au proc\u00e9d\u00e9 technique utilis\u00e9) qui n'est pas pris en compte.</p> <p>On sait que le r\u00e9sultat de \\(15 \u221214\\) tient en \\(CA2_5\\) puisque ce sont deux nombres de signes oppos\u00e9s qui tiennent en \\(CA2_5\\).</p> <p>On trouve donc que \\(15 \u221214\\) vaut \\(\\overline{00001}^5\\), ce qui correspond \u00e0 \\(1\\) en \\(CA2_5\\).</p>"},{"location":"Nombres/1-Entiers/#du-complement-a-2-a-la-notation-decimale","title":"Du compl\u00e9ment \u00e0 \\(2\\) \u00e0 la notation d\u00e9cimale","text":"<ul> <li>Soit \\(X\\) de compl\u00e9ment \u00e0 \\(2\\) sur \\(8\\) bits \\(\\overline{1010\\text{ }1101}^8\\).</li> <li>Nombre n\u00e9gatif non nul (\\(1\\) en bit de poids fort).</li> <li>On peut coder \\(X\\) en compl\u00e9ment \u00e0 \\(2\\) sur \\(8\\) bits, donc \\(\u22122^{8\u22121} = \u2212128 \u2264X \u2264 \u22121\\).</li> <li>On calcule le codage d\u00e9cimal de \\(\\text{1010 1101}\\), puis on soustrait \\(256\\) (i.e. \\(\u22122^8\\)).</li> </ul> <p>\\(\u2212(1 \u00d72^8) + 1 \u00d72^7 + 0 \u00d72^6 + 1 \u00d72^5 + 0 \u00d72^4 + 1 \u00d72^3 + 1 \u00d72^2 + 0 \u00d72^1 + 1 \u00d72^0 = \u221283 = X\\)</p>"},{"location":"Nombres/1-Entiers/#parite-et-signe-en-complement-a-2","title":"Parit\u00e9 et signe en compl\u00e9ment \u00e0 \\(2\\)","text":"<p>Pour reconna\u00eetre un nombre positif en compl\u00e9ment \u00e0 \\(2\\) sur \\(n\\) bits, il suffit que son bit de poids fort soit \u00e0 \\(0\\),</p> <p>N\u00e9gatif : son bit de poids fort \u00e0 \\(1\\).</p> <p>\\(-1\\) est toujours l'entier qui, en compl\u00e9ment \u00e0 \\(2\\) sur \\(n\\) bits, a une repr\u00e9sentation ne comportant que des \\(1\\).</p>"},{"location":"Nombres/1-Entiers/#representation-des-entiers-signes-en-complement-a-2","title":"Repr\u00e9sentation des entiers sign\u00e9s en compl\u00e9ment \u00e0 \\(2\\)","text":"\\(\\color{red}\\texttt{0}\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) \\(=\\) \\(127\\) \\(\\color{red}\\texttt{0}\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(1\\) \\(0\\) \\(=\\) \\(2\\) \\(\\color{red}\\texttt{0}\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(1\\) \\(=\\) \\(1\\) \\(\\color{red}\\texttt{0}\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(=\\) \\(0\\) \\(\\color{red}\\texttt{1}\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) \\(=\\) \\(-1\\) \\(\\color{red}\\texttt{1}\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) \\(1\\) \\(0\\) \\(=\\) \\(-2\\) \\(\\color{red}\\texttt{1}\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(1\\) \\(=\\) \\(-127\\) \\(\\color{red}\\texttt{1}\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(=\\) \\(-128\\) <p>Figure \u2013 Quelques entiers sign\u00e9s en compl\u00e9ment \u00e0 \\(2\\)</p> <p>Le premier bit est le bit de signe.</p> <p>En compl\u00e9ment \u00e0 \\(2\\) sur \\(N\\) bits on repr\u00e9sente tous les entiers de \\(\u22122^{N \u22121}\\) \u00e0 \\(2^{N \u22121} \u22121\\). Sur \\(32\\) bits : de \\(\u22122^{31} = \u22122147483648\\) \u00e0 \\(2^{31} \u22121 = 2147483647\\) (plus ou moins \\(2\\) milliards).</p>"},{"location":"Nombres/1-Entiers/#extension-de-format","title":"Extension de format","text":"<p>Extension de signe</p> <p>Si l'on veut passer un enteir sign\u00e9 \\(x\\) d'un format \\(n\\) bits vers un format \\(n+k\\) bits en gardant la m\u00eame valeur, il suffit de faire une extension de signe: le bit de signe est r\u00e9p\u00e9t\u00e9 sur les nouveaux \\(k\\) bits de poids fort</p> <p><p></p></p> <p>Figure \u2013 Duplication du bit de poids fort</p> <p>Soit \\(\\overline{10001000}^8\\) un entier sign\u00e9 repr\u00e9sent\u00e9 en compl\u00e9ment \u00e0 \\(2\\) sur \\(8\\) bits. En compl\u00e9ment \u00e0 \\(2\\) sur \\(12\\) bits, on obtient : \\(\\overline{111110001000}^{12}\\)</p>"},{"location":"Nombres/1-Entiers/#justification","title":"Justification","text":"<p>Soit \\(T\\) la repr\u00e9sentation en \\(CA2N\\) de \\(X\\) (pour \\(N &gt;2\\)).</p> <p>Si \\(X \u22650\\), son codage en \\(CA2N\\) est son codage en binaire (il tient forc\u00e9ment sur moins de \\(N \u22121\\) bits) auquel on ajoute des z\u00e9ros \u00e0 gauche pour remplir \\(N\\) bits. Pour remplir \\(N + 1\\) bits, on ajoute juste un z\u00e9ro de plus \u00e0 gauche. Et donc, une extension de format de \\(CA2N\\) \u00e0 \\(CA2(N +1)\\) consiste juste \u00e0 dupliquer le bit de poids fort.</p> <p>Si \\(X &lt;0\\), \\(2^{N \u22121} \u2264X \u2264\u22121\\) donc \\(\u22122^{N \u22121} \u2264X + 2^N \u22642^N -1\\). Ainsi \\(X + 2^N\\) est de la forme \\(2^{N \u22121} + \\sum^{N \u22122}_{i =0} {x_{N \u22122\u2212i} 2^{N \u22122\u2212i}}\\)</p> <p>(\\(\\overline{1xN \u22122 ...x0}^N\\) est le codage de \\(X\\) ). </p> <p>Codons \\(X\\) en \\(CA2(N +1)\\) :</p> <ul> <li>\\(X + 2^{N +1} = 2^N + (X + 2^N ) = 2^N + 2^{N \u22121} + \\sum^{N \u22122}_{i =0} {x_{N \u22122\u2212i}2^{N \u22122\u2212i}} .\\)</li> <li>Ainsi le codage en \\(CA2(N +1)\\) de \\(X\\) est \\(\\overline{11x_{N\u22122} ...x_0}^{N+1}\\)</li> </ul>"},{"location":"Nombres/1-Entiers/#overflow","title":"Overflow","text":"<p>Overflow</p> <p>Il y a overflow (d\u00e9passement de capacit\u00e9) lorsque le nombre \u00e0 repr\u00e9senter ne tient pas dans le format choisi.</p> <p>Pour reconna\u00eetre un overflow dans une addition en compl\u00e9ment \u00e0 \\(2\\) :</p> <ul> <li>Si les deux op\u00e9randes sont du m\u00eame signe : d\u00e9passement si le r\u00e9sultat est de signe oppos\u00e9,</li> <li>Si les deux op\u00e9randes sont de signes oppos\u00e9s, il n'y a jamais d\u00e9passement.</li> </ul> <p>On additionne \\(\\overline{01111000}^8\\) (\\(120\\)) et \\(\\overline{01110011}^8\\) (\\(115\\)) en \\(CA2\\_8\\).</p> <pre><code>  \u2217 \u2217 \u2217 \u2217\n  0 1 1 1 0 0 1 1\n+ 0 1 1 1 1 0 0 0\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\n  1 1 1 0 1 0 1 1 (changement de signe donc overflow)\n</code></pre> <p>On constate un overflow. On passe au \\(CA2\\_9\\). \\(120\\) : \\(\\overline{001111000}^9\\) et \\(115\\) : \\(\\overline{001110011}^9\\)</p> <pre><code>    \u2217 \u2217 \u2217 \u2217\n  0 0 1 1 1 0 0 1 1\n+ 0 0 1 1 1 1 0 0 0\n\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\u2212\n  0 1 1 1 0 1 0 1 1 \n</code></pre> <p>Le r\u00e9sultat, \\(\\overline{011101011}^9\\) repr\u00e9sente \\(235\\) en \\(CA2_9\\).</p>"},{"location":"Nombres/1-Entiers/#entiers-signes-en-c","title":"Entiers sign\u00e9s en C","text":""},{"location":"Nombres/1-Entiers/#valeurs-maximales","title":"Valeurs maximales","text":"<p>Le fichier \\(\\texttt{limits.h}\\) (voir ici) contient toutes les r\u00e9ponses \u00e0 nos questions.</p> <p>Compilons :</p> <pre><code># include &lt;stdio.h&gt;\n# include &lt;limits.h&gt;\n\nint main (void){\n    printf(\"%d\\n\", INT_MAX);\n    int x = INT_MAX + 1; // produit un Warning !!\n    printf(\"%d\\n\", x );\n    return 0;\n}\n</code></pre> <p>Sur ma machine, on obtient</p> <pre><code>2147483647\n-2147483648\n</code></pre> <p>Les entiers sont donc impl\u00e9ment\u00e9s en \\(CA2\\_32\\).</p>"},{"location":"Nombres/1-Entiers/#contraindre-la-taille-des-entiers","title":"Contraindre la taille des entiers","text":"<p>Les entiers <code>int</code> sont souvent sur \\(4\\) octets mais pas toujours : cela d\u00e9pend des impl\u00e9mentations.</p> <p>Lorsque la taille des entiers est \u00e9l\u00e9ment important pour le programmeur, le fichier d'en-t\u00eate <code>&lt;stdint.h&gt;</code> est une aide pr\u00e9cieuse. Il d\u00e9crit des types de tailles pr\u00e9cises <code>intN_t</code> (entiers sign\u00e9s de \\(N\\) bits) et <code>uintN_t</code> (non sign\u00e9s sur \\(N\\) bits).</p> <p><code>uint16_t</code> repr\u00e9sente les entiers non sign\u00e9s sur \\(16\\) bits (\\(2\\) octets).</p> <pre><code>#include &lt;stdint.h&gt;\nint main (){\ni n t 8 t x = 127 ; // max valeur sign\u00e9e sur 8 bits\nprintf(\"%4d\\n\", x);\nx = x + 1;\nprintf(\"%4d\\n\", x); // d\u00e9passement\n}\n</code></pre> <p>On obtient :</p> <pre><code>127\n-128\n</code></pre>"},{"location":"Nombres/1-Entiers/#les-entiers-en-textpython","title":"Les entiers en \\(\\text{Python}\\)","text":"<p>Cette section hors programme est laiss\u00e9e au lecteur curieux.</p>"},{"location":"Nombres/1-Entiers/#decoupage-des-entiers-en-textpython","title":"D\u00e9coupage des entiers en \\(\\text{Python}\\)","text":"<p>D'apr\u00e8s Nicolas P\u00e9cheux.</p> <ul> <li> <p>Les entiers en \\(\\text{Python}\\) ont une pr\u00e9cision non limit\u00e9e. Ils ne fonctionnent donc pas en compl\u00e9ment \u00e0 \\(2\\).</p> </li> <li> <p>Sur une machine \\(32\\) bits, la repr\u00e9sentation binaire d'un entier \\(\\text{Python}\\) \\(x\\) est d\u00e9coup\u00e9e en paquets de \\(15\\) bits, stock\u00e9s dans un tableau dont les \u00e9l\u00e9ments sont des entiers de \\(16\\) bits (pour que la taille soit un multiple de \\(8\\)).</p> </li> </ul> <p>Les cases du tableau sont donc les coefficients de \\(x\\) dans sa repr\u00e9sentation en base \\(2^{15}\\).</p> <p>\u00c0 ce tableau est associ\u00e9e un (petit) entier indiquant le nombre de chiffres de \\(x\\) dans la base \\(2^{15}\\).</p> <p>D'apr\u00e8s Nicolas P\u00e9cheux.</p> <p>Soit le nombre \\(x = 1234567891011\\). Il s'\u00e9crit en binaire</p> <p>\\(\\underbrace{000010001111101}_{1149_{10}}\\text{ }|\\text{ }\\underbrace{110001111110110}_{25590_{10}}\\text{ }|\\text{ }\\underbrace{000100001000011}_{2115_{10}}\\)</p> <p>Dans la base \\(2^{15}\\), il faut \\(32768\\) symboles pour les digits. On peut garder l'\u00e9criture en base \\(10\\) comme symbole. Ainsi \\(x\\) s'\u00e9crit</p> <p>\\(1149_{10}25590_{10}2115_{10_{\\color{red}2^{15}}}\\) en base \\(2^{15}\\)</p> <p>Alors \\(x\\) est repr\u00e9sent\u00e9 en \\(\\text{Python}\\) par le tableau \\([1149, 25590, 2115]\\) et l'entier \\(3\\). Et \\(\u2212x\\) est repr\u00e9sent\u00e9 par \\([1149,25590, 2115]\\) et \\(\u22123\\).</p>"},{"location":"Nombres/1-Entiers/#operations-arithmetiques","title":"Op\u00e9rations arithm\u00e9tiques","text":"<p>La base choisie (\\(2^{15}\\) pour une machine \\(32\\) bits, \\(2^{30}\\) pour une \\(64\\) bits) ne doit pas \u00eatre trop grande pour que le processeur puisse faire les op\u00e9rations arithm\u00e9tiques entre les digits.</p> <p>En cas d'addition par exemple, les coefficients de m\u00eames exposants sont additionn\u00e9s par le processeur. Un petit logiciel est ensuite charg\u00e9 d'harmoniser les r\u00e9sultats (en cas de propagation de retenue par exemple).</p> <p>Ce traitement logiciel ralenti les op\u00e9rations arithm\u00e9tiques sur les entiers \\(\\text{Python}\\).</p> <p>Pour conna\u00eetre la base (en exposant de \\(2\\)) et la taille d'occupation (en octets) de chaque digit dans cette base, il suffit d'entrer</p> <pre><code>import sys\nsys.int_info\n</code></pre> <p>On obtient</p> <pre><code>sys.int_info(bits_per_digit =30,\n      sizeof_digit =4)\n</code></pre>"},{"location":"Nombres/2-Flottants/","title":"Nombres flottants","text":"<p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Informatique pour tous en classes pr\u00e9paratoires aux grandes \u00e9coles (Eyrolles)</li> <li>Nombres flottants : Wikipedia</li> <li>cpprefrence (en C)</li> </ul>"},{"location":"Nombres/2-Flottants/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"Nombres/2-Flottants/#introduction","title":"Introduction","text":"<p>Objectif : repr\u00e9senter une partie des nombres rationnels : des nombres avec une quantit\u00e9 born\u00e9e de chiffres apr\u00e8s la virgule</p> <p>Id\u00e9e\u00a0: On se donne tous les chiffres composants le nombre de la position de la virgule\u00a0: \\((1234,2)\\) repr\u00e9sente \\(12,34\\) c'est \u00e0 dire \\(1,234 \\times 10^1\\)</p> <p>Comment\u00a0: On peut \u00e9crire tous les nombres r\u00e9els non nuls sous la forme \\((\u22121)^s(1+m)2^e\\) avec</p> <ul> <li>\\(s\u2208{0,1}\\) est le signe du nombre</li> <li>\\(m\u2208[0, 1[\\) est la mantisse</li> <li>\\(e\u2208\u2124\\) est son exposant</li> </ul> <p>L'exposant du nombre repr\u00e9sente la position de la virgule dans son expression en base \\(2\\)</p> <p>\\(1+m\\) est un nombre entre \\(1\\) et \\(2\\) (exclu). Il s'\u00e9crit sous la forme \\(1.c_1...c_i...\\) avec les \\(c_i\u2208{0,1}\\). Comme les ordinateurs ne g\u00e8re que des quantit\u00e9s finies, le nombre de chiffres binaires \\(c_i\\) est born\u00e9 (il est souvent \u00e9gal \u00e0 \\(23\\) ou \\(52\\))</p>"},{"location":"Nombres/2-Flottants/#pourquoi-les-nombres-a-virgule-flottante","title":"Pourquoi les nombres \u00e0 virgule flottante ?","text":"<p>L'avantage de la repr\u00e9sentation en virgule flottante par rapport \u00e0 la virgule fixe est que la virgule flottabte est capable, \u00e0 nombre de chiffres \u00e9gal, de g\u00e9rer un intervalle de nombres r\u00e9els plus importants.</p> <p>Consid\u00e9rons une repr\u00e9sentation en virgule fiwe qui a \\(5\\) chiffres dont un apr\u00e8s la virgule. Elle peut exprimer \\(10^5\\) nombres d\u00e9cimaux dans \\([0,9999.9]\\). Avec \\(5\\) fois les chiffre 1, on ne repr\u00e9sente que \\(1111.1\\)</p> <p>Avec une repr\u00e9sentation en virgule flottante et \\(5\\) chiffres \\(1\\) : on peut repr\u00e9senter \\(11111\\), \\(1111.1\\), \\(111.11\\), \\(11.111\\), \\(1.1111\\), \\(.11111\\), donc 6 fois plus d'expressions en virgule flottante qu'en virgule fixe. De plus l'intervalle de repr\u00e9sentation est plus grand : \\([0, 99999]\\).</p> <p>Cependant, il faut alors oder la position de la virgule. Cela demande donc plus de place.</p>"},{"location":"Nombres/2-Flottants/#la-norme-textieee-754","title":"La norme \\(\\text{IEEE 754}\\)","text":""},{"location":"Nombres/2-Flottants/#textieee-754-presentation","title":"\\(\\text{IEEE 754}\\), pr\u00e9sentation","text":"<p>\\(\\text{IEEE}\\) Standard for Binary Floating-Point Arithmetic (\\(\\text{ANSI/IEEE}\\) Std \\(\\text{754-1985}\\)) (standard \\(\\text{IEEE}\\) pour l'arithm\u00e9tique binaire en virgule flottante) : \\(\\text{IEEE 754}\\).</p> <p>Standard le plus employ\u00e9 actuellement pour le calcul des nombres \u00e0 virgule flottante dans le domaine informatique, avec les CPU et les FPU.</p> <p>Le standard d\u00e9finit les formats de repr\u00e9sentation des nombres \u00e0 virgule flottante (signe mantisse, exposant, nombres d\u00e9-normalis\u00e9s) et valeurs sp\u00e9ciales (\\(\\text{infinis}\\) et \\(\\text{NaN}\\)) en m\u00eame temps qu'un ensemble d'op\u00e9rations sur les nombres flottants.</p> <p>Il d\u00e9crit aussi quatre modes d'arrondi et cinq exceptions (comprenant les conditions dans lesquelles une exception se produit, et ce qui se passe dans ce cas)</p> <ul> <li> <p>Les quatre modes d'arrondi\u00a0:</p> <ul> <li>Vers moins l'infini\u00a0: \\(\u230a\u22123.\u22124\u230b=\u22124\\)</li> <li>Vers plus l'infini\u00a0: \\(\u2308\u22123.\u22124\u2309=\u22123\\)</li> <li>Vers z\u00e9ro\u00a0: \\(\u230a\u22123.\u22124\u230b=\u22123\\) et \\(\u230a3.4\u230b=3\\)</li> <li>Au plus proche (avec le cas particulier de l'\u00e9quidistance : le nombre \\(1.5\\) doit-il \u00eatre arrondi \u00e0 l'unit\u00e9 vers \\(1\\) ou \\(2\\)?)</li> </ul> </li> <li> <p>La version \\(1985\\) de la nomre \\(\\text{IEEE 754}\\) d\u00e9finit 4 formats pour repr\u00e9senter les nombres \u00e0 virgule flottante\u00a0:</p> <ul> <li>Simple pr\u00e9cision (\\(32\\) bits\u00a0: \\(1\\) bit signe, \\(8\\) bits d'exposant, \\(23\\) bits de mantisse avec \\(1\\) bit implicite)</li> <li>Simple pr\u00e9cision \u00e9tendue (\\(\u2265 43\\) bits, obsol\u00e8te)</li> <li>Double pr\u00e9cision (\\(64\\) bits\u00a0: \\(1\\) bit de signe, \\(11\\) bits d'expo, \\(52\\) bits de mantisse avec \\(1\\) implicite)</li> <li>Double pr\u00e9cision \u00e9tendue (\\(&gt;79\\) bits)</li> </ul> </li> </ul>"},{"location":"Nombres/2-Flottants/#bit-1-bit-implicite","title":"Bit \\(1\\), bit implicite","text":"<p>Bit implicite</p> <p>La mantisse repr\u00e9sente un nombre d\u00e9cimal entre \\(1\\) et \\(2\\) (exclu), par exemple \\(1.\\) \\(1101100011\\). Rendre le bit \\(1\\) implicite consiste \u00e0 \u00e9crire \\(1101100011\\), la partie \\(1.\\) \u00e9tant sous entendue puisque toujours la m\u00eame.</p>"},{"location":"Nombres/2-Flottants/#representation-binaire-des-nombres-flottants-a-precision-simple","title":"Repr\u00e9sentation binaire des nombres flottants \u00e0 pr\u00e9cision simple","text":"<p>Figure - \\(\\text{IEEE-754 simple pr\u00e9cision}\\)</p> <p>PLus g\u00e9n\u00e9ralement, les nombres sont \u00e9crits au format \\((1, E, M)\\) donc sur \\(1 + E + M\\) bits\u00a0:</p> <p></p> <p>Ce format \\((1, 8, 23)\\) obsol\u00e8te est privil\u00e9gi\u00e9 ici parce qu'on peut faire tenir \\(32\\) bits sur un transparent.</p> <ul> <li>Bit de poids fort \u00e0 \\(1\\)\u00a0: N\u00e9gatif, \u00e0 \\(0\\)\u00a0: Positif</li> <li>Exposant\u00a0: Pas de repr\u00e9sentation en compl\u00e9ment \u00e0 \\(2\\) (car comparer des nombres serait difficile). L'exposant est d\u00e9cal\u00e9, afin de le stocker sous forme d'un nombre non sign\u00e9. En notant \\(E\\) le nombre de chiffres (toujours le m\u00eame nombre) de l'exposant, on ajoute un d\u00e9calage de \\(d=2^{E\u22121}\u22121\\)</li> <li>Avec \\(E = 8\\), \\(d = 127\\). L'exposant est dans l'intervalle \\([-127\u00a0; 128]\\), donc l'exposant d\u00e9cal\u00e9 est dans \\([0, 255]\\)\u00a0; \\(0\\) et \\(255\\) ayant une signification sp\u00e9ciale.</li> </ul> <p>Ils sont longs de \\(4\\) octets (\\(32\\) bits)\u00a0: \\((1, 8, 23)\\)</p> <p>La mantisse compl\u00e8te, le significande, doit \u00eatre consid\u00e9r\u00e9e comme une valeur sur \\(24\\) bits. Si la mantisse avec bit \\(1\\) implicite est \\(101000\u2026\\) alors le significande en base \\(2\\) est \\(1.\\) \\(101000\u2026\\)</p> <p>La quantit\u00e9 de nombres repr\u00e9sentables au format \\((1, E, M)\\) est grande mais pas infinie (mince). L'ordinateur travaille donc avec des valeurs en g\u00e9n\u00e9ral approch\u00e9es\u00a0:</p> <p>Avec \\(\\texttt{float x = 0.1}\\), l'ordinateur travaille en interne avec \\(\\text{0 01111011 10011001100110011001101}_2\\) c'est \u00e0 dire \\(0.100000001490116_{10}\\) qui est \u00e9gal \u00e0 \\(\\frac{13421773}{134217728}\\)</p>"},{"location":"Nombres/2-Flottants/#affichage","title":"Affichage","text":"<p>Quand on entre un nombre au clavier, l'orinateur en calcule une repr\u00e9sentation en virgule flottante. Du fait des arrondis, une infinit\u00e9 de nombres peuvent avoir la m\u00eame repr\u00e9sentation comme flottant.</p> <p>La relation \"a la m\u00eame repr\u00e9sentation que\" est une relation d'\u00e9quivalence.</p> <p>Pour le confort de lecture, l'ordinateur affiche l'unique repr\u00e9sentant de cette classe d'\u00e9quivalence qui n\u00e9cessite le moins de chiffres d\u00e9cimaux.</p> <p>C'est la raison pour laquelle l'ordinanteur affiche \\(\\texttt{0.1}\\) et nont le nombre rationnel avec lequel il travaille effectivenment.</p> <p>Un nombre qui est \u00e9galt \u00e0 sa repr\u00e9sentation en flottant est dit rep\u00e9sentable exactement en machine. \\(\\texttt{0.1}\\)  n'est pas repr\u00e9sentable exactement en machine ; \\(\\texttt{1.0}\\) et \\(\\texttt{3.75}\\) oui.  </p>"},{"location":"Nombres/2-Flottants/#a-propos-de-lexposant","title":"\u00c0 propos de l'exposant","text":""},{"location":"Nombres/2-Flottants/#format-1-e-m","title":"Format \\((1, E, M)\\)","text":"<ul> <li>En fonction de la valeur \\(e_d\\) du champ exposant d\u00e9cal\u00e9 (\\(0\\), \\(255\\), ou autre), certains nombres peuvent avoir une signification sp\u00e9ciale Ils peuvent \u00eatre :<ul> <li>Des nombres d\u00e9-normalis\u00e9s (\\(e_d=0\\));</li> <li>Z\u00e9ro (\\(e_d=0\\));</li> <li>Infini (\\(e_d = 2^{N-1}-1\\));  </li> <li>NaN (Not a Nunber (\\(e_d = 2^{N-1}-1\\)) \"pas un nombre\", comme \\(0/0\\) ou \\(\\sqrt{-1}\\));</li> </ul> </li> <li>L'exposant est d\u00e9cal\u00e9 dans \\([\\![0,2^E\u22121]\\!]\\) donc le d\u00e9calage est de \\(2^{E\u22121}\u22121\\).LEs nombres \"normalis\u00e9s\" ont un exposant d\u00e9cal\u00e9 dans \\([\\![1,2^E\u22122]\\!]\\) .</li> <li>Le bit implicite de la mantisse est d\u00e9termin\u00e9 par la valeur de l'exposant d\u00e9cal\u00e9. Il vaut \\(0\\) si l'exposant d\u00e9cal\u00e9 est \u00e9gal \u00e0 \\(0\\) et \\(1\\) sinon.</li> </ul>"},{"location":"Nombres/2-Flottants/#nombres-normalises-et-de-normalises","title":"Nombres normalis\u00e9s et d\u00e9-normalis\u00e9s","text":"<p>Soit le Format \\((1, E, M)\\)</p> <ul> <li>Si l'exposant d\u00e9cal\u00e9 est diff\u00e9rent de \\(0\\) et de \\(2^E\u22121\\), le bit implicite est \\(1\\), et le nombre est dit normalis\u00e9.</li> <li>Si l'exposant d\u00e9cal\u00e9 est nul, par convention, le bit implicite vaut \\(0\\). Le nombre est dit d\u00e9-normalis\u00e9. La repr\u00e9sentation au format d\u00e9-normalis\u00e9 est destin\u00e9e aux tr\u00e8s petites quantit\u00e9s en valeur absolue.</li> <li>La quantit\u00e9 de nombre \u00e0 virgules flottante sur une machine et grande mais finie. Chaque nombre positif (sauf le plus grand et plus petit) \u00e0 un successeur et un pr\u00e9d\u00e9cesseur (s'il n'est pas nul) positif</li> <li>Le successeur du nombre d\u00e9-normalis\u00e9 positif le plus grand est le plus petit nombre normalis\u00e9 positif.</li> <li>Z\u00e9ro n'est ni normalis\u00e9 ni d\u00e9-normalis\u00e9. Il a deux \u00e9critures \\(+0\\) et \\(-0\\)</li> </ul>"},{"location":"Nombres/2-Flottants/#nombres-de-normalises","title":"Nombres d\u00e9-normalis\u00e9s","text":"<p>Pour un format \\(1, E, M\\) :</p> <ul> <li>Mantisse non nulle, champ exposant d\u00e9cal\u00e9\u00a0: \\(E\\) bits \u00e0 \\(0\\).</li> <li>Tous les nombres d\u00e9-normalis\u00e9s ont le m\u00eame exposant.</li> <li>Si la r\u00e8gle \u00e9tait la m\u00eame que pour les nombres normalis\u00e9s, l'exposant serait donc de \\(0-\\text{decalage}\\) soit \\(-2^{E-1}+1\\), donc \\(-1023\\) pour les flottants double pr\u00e9cision.</li> <li>Mais par convention, l'exposant pour les nombres d\u00e9-normalis\u00e9s est en fait \u00e9gal au plus petit exposant de nombre normalis\u00e9 soit \\(\u22122^{E\u22121}+1+1\\). Ce qui change c'est le bit implicite \\(0\\) (d\u00e9-normalis\u00e9) ou \\(1\\) (normalis\u00e9)<ul> <li>Plus petit normalis\u00e9 positif \\((1 + m)2^{-2^{E-1}+1+1}\\) avec \\(m=0\\)</li> <li>Plus petit d\u00e9-normalis\u00e9 positif \\((0 + m)2^{-2^{E-1}+1+1}\\) avec \\(m\\) non nul minimum. Ainsi, \\(m\\) s'\u00e9crit avec \\(M-1\\) bits \u00e0 \\(0\\) suivis de \\(1\\) donc \\(m = 2^{-M}\\). Conclusion \\(2^{-M}2^{-2^{E-1}+1+1}\\)</li> </ul> </li> </ul>"},{"location":"Nombres/2-Flottants/#exposant-pour-un-format-1-e-m","title":"Exposant pour un format \\((1, E, M)\\)","text":"<p>Tableau r\u00e9capitulatif :</p> Type Exposant d\u00e9cal\u00e9 Mantisse Z\u00e9ros\u00a0: \\(\\pm 0\\) \\(0\\) \\(0\\) Nombres d\u00e9-normalis\u00e9s \\(0\\) \\(\\neq0\\), <code>0.</code> implicite Nombres normalis\u00e9s 1 \u00e0 \\(2^E\u20132\\) quelconque, <code>1.</code> implicite Infinis \\(\\pm\\infty\\) \\(2^E\u20131\\) \\(0\\) NaN (Not a Number) \\(2^E\u20131\\) diff\u00e9rente de \\(0\\) <p>Exposant \\(e\\) d'un nombre normalis\u00e9</p> <p>Si \\(E=128\\), alors \\(e\u2208[\u2212126,127]\\). L'exposant \\(-127\\) (qui est d\u00e9cal\u00e9 vers la valeur \\(0\\)) est r\u00e9serv\u00e9 pour z\u00e9ro et les nombres d\u00e9-normalis\u00e9s, tandis que l'exposant \\(128\\) (d\u00e9cal\u00e9 vers \\(255\\)) est r\u00e9serv\u00e9 pour coder les infinis et les \\(\\texttt{NaN}\\).</p>"},{"location":"Nombres/2-Flottants/#real-2-float","title":"Real 2 float","text":""},{"location":"Nombres/2-Flottants/#calcul-du-triple-sem","title":"Calcul du triple \\((s,e,m)\\)","text":"<p>Cas des nombres normalis\u00e9s. On calcule \\((s, e, m)\\) en base \\(10\\)</p> <ul> <li>\u00c9criture de \\(0\\)\u00a0: \\(32\\) bits \u00e0 \\(0\\) ou \\(1\\) suivi de \\(31\\) bits nuls</li> <li>\u00c9criture sous forme scientifique au standard d\u00e9cimal\u00a0: Si \\(X\u22600\\), \\(X=(\u22121)^s\u00d72^e\u00d7(1+m)\\) avec<ul> <li>\\(s\\in\\{0,1\\}\\)</li> <li>\\(e\u2208\u2124\\)</li> <li>\\(m\u2208[0, 1[\\)</li> </ul> </li> </ul> <p>Il faudra exprimer ces nombres au format binaire au moyen d'un triple (s\u2082, e\u2082, m\u2082)</p> <ul> <li>Recherche de \\(s\\) : \\(0\\) si \\(X\\) est positif ou nul, \\(1\\) sinon.</li> <li>Recherche de \\(e\\) :<ul> <li>si \\(|X|\\geq 2\\), diviser par \\(2\\) la valeur absolue de \\(X\\) autant de fois que n\u00e9cessaire jusqu'\u00e0 obtenir un eniter de l'intervalle \\([1;2[\\). \\(e\\) est le nombre de divisions effectu\u00e9es.</li> <li>Si \\(|X| &lt; 1\\), multiplier par \\(2\\) la valeur absolue de \\(X\\) autant de fois que n\u00e9cessaire jusqu'\u00e0 obtenir un entier de l'intervalle \\([1, 2[\\). \\(e\\) est donc l'oppos\u00e9 du nombre de multiplication.</li> <li>Si \\(2&gt;|X|\\geq1\\) alors \\(e = 0\\)</li> </ul> </li> <li>Recherche de \\(m\\): Si on conna\u00eet \\(X\\), \\(s\\) et \\(e\\) alors il est facile de trouver \\(m\\)\u00a0:</li> </ul> <p>\\(m=\\frac{(\u22121)^s}{2^e}X\u22121\\)</p>"},{"location":"Nombres/2-Flottants/#triplet-s_2-e_2-m_2-en-base-2","title":"Triplet \\((s_2, e_2, m_2)\\) en base 2","text":"<p>Exemple</p> <p>\\(X=-9.6\\) ; \\(s_{10} = 1\\) ; \\(9.6\\times 2^{-3} = 1.2\\in[1;2[\\) donc \\(e_{10} = 3\\) ; \\(m_{10} =1.2 -1\\)</p> <p>Connaissant \\(s,e,m\\) de la notation scientifique d\u00e9cimale, on veut \\(s_2, e_2, m_2\\) tels que :</p> <ul> <li>bits de signe \\(s_2 = s_{10}\\)</li> <li>bits d'exposant \\(e_2 = bin (e+127)\\) (conversion de l'exposant d\u00e9cal\u00e9 en base \\(2\\)),</li> <li>Pour la mantisse sur \\(23\\) bits<ul> <li>\\(\\texttt{I}\\). Multiplier \\(m_{10}\\) par \\(2\\),</li> <li>\\(\\texttt{II}\\). Calculer partie enit\u00e8re (\\(0\\) ou \\(1\\)); partie d\u00e9cimale.</li> <li>\\(\\texttt{III}\\). partie enti\u00e8re : un nouveau bit de la repr\u00e9sentation.</li> </ul> </li> </ul> <p>Recommencer \u00e0 \\(\\texttt{I}\\) avec la partie d\u00e9cimale du r\u00e9sultat jusqu'\u00e0 avoir \\(23\\) bits de mantisse (et m\u00eame un peu plus pour arrondir)</p> <p>Exemple</p> <ul> <li>\\(X=-9.6\\) ; \\(s_{10} = 1\\) ; \\(e_{10} = 3\\) ; \\(m_{10} =0.2\\)</li> <li>\\(e_{10} + 127_{10} = 130_{10}\\), en base \\(2\\) : \\(e_2 = 10000010_2\\)</li> <li>Pour la mantisse :<ul> <li>\\(0.2 \\times 2 = 0.4 = 0 + 0.4\\)</li> <li>\\(0.4 \\times 2 = 0.8 = 0 + 0.8\\)</li> <li>\\(0.8 \\times 2 = 1.6 = 1 + 0.6\\)</li> <li>\\(0.6 \\times 2 = 1.2 = 1 + 0.2\\) On est revenu \u00e0 \\(0.2\\) : s\u00e9quence infinie. Mantisse \\(\\texttt{0011 0011 0011 0011 0011 0011 0011...}\\)</li> </ul> </li> </ul> \\(2^{-1}\\) \\(2^{-2}\\) \\(2^{-3}\\) \\(2^{-4}\\) \\(2^{-5}\\) \\(2^{-6}\\) \\(2^{-7}\\) \\(2^{-8}\\) \\(2^{-9}\\) \\(2^{-10}\\) \\(0\\) \\(0\\) \\(1\\) \\(1\\) \\(0\\) \\(0\\) \\(1\\) \\(1\\) \\(0\\) \\(0\\) \\(2^{-11}\\) \\(2^{-12}\\) \\(2^{-13}\\) \\(2^{-14}\\) \\(2^{-15}\\) \\(2^{-16}\\) \\(2^{-17}\\) \\(2^{-18}\\) \\(2^{-19}\\) \\(2^{-20}\\) \\(1\\) \\(1\\) \\(0\\) \\(0\\) \\(1\\) \\(1\\) \\(0\\) \\(0\\) \\(0\\) \\(0\\) \\(2^{-21}\\) \\(2^{-22}\\) \\(2^{-23}\\) \\(2^{-24}\\) \\(2^{-25}\\) \\(2^{-26}\\) \\(2^{-27}\\) \\(...\\) \\(0\\) \\(0\\) \\(1\\) \\(1\\) \\(0\\) \\(0\\) \\(1\\) \\(...\\) <p>On a donc la mantisse comme une somme infinie de coefficients \\(\\sum^{+\\infty}_{i=1}{\\frac{a_i}{2^i}}\\) mais on veut une somme finie.</p> <p>Question : \\(\\frac{1}{2^{24}} + 0\\times\\frac{1}{2^{25}} 0\\times\\frac{1}{2^{26}} 1\\times\\frac{1}{2^{27}}\\) est il plus proche de \\(\\frac{1}{2^{23}}\\) ou de \\(0\\) ? Donc \\(m\\) est-il plus proche de \\(\\sum^{23}_{i=1}{\\frac{a_i}{2^i}}\\) ou de \\(\\left(\\sum^{23}_{i=1}{\\frac{a_i}{2^i}}+\\frac{1}{2^{24}}+\\frac{1}{2^{27}}\\right)\\)?</p> <p>\\(\\frac{1}{2^{24}} + 0\\times\\frac{1}{2^{25}} 0\\times\\frac{1}{2^{26}} 1\\times\\frac{1}{2^{27}}\\) est plus proche de \\(\\frac{1}{2^{23}}\\) : on ajoute donc \\(1\\) au bit de poids faible (le \\(23\\)\u00e8me) et on tient compte des retenues.</p> <p>Attention : Dans le pire cas (mais pas ici), \\(m = \\sum_{i=1}^{23}{\\frac{1}{2^i}}\\) et on ajoute \\(\\frac{1}{2^{23}}\\). Alors \\(m + \\frac{1}{2^{23}} = \\frac{\\frac{1}{2} - \\frac{1}{2^{24}}}{1-1^{\\frac{1}{2}}} +\\frac{1}{2^{23}} = 1\\) donc \\(1 + m = 2\\) et il faut changer l'exposant !!</p> <p>Arrondi au plus proche sur \\(23\\) bits :</p> <p>\\(M = \\text{0011 0011 0011 0011 0011 010}\\)</p> <p>Finalement : \\(-9.6_{10}\\) est repr\u00e9sent\u00e9 par</p> <p>\\(1_2 \\text{ } 10000010_2 \\text{ 0011 0011 0011 0011 0011 010}_2\\)</p>"},{"location":"Nombres/2-Flottants/#arrondi-si-m-23","title":"Arrondi si \\(M = 23\\)","text":"<p>Dans l'exemple \u00e9tudi\u00e9 \\(X=-9.6\\), on pousse le calcul des d\u00e9cimales jusqu'au \\(27\\)\u00e8me bit et on peut  d\u00e9terminer sans erreur quel est l'arrondi au plus proche de la matrice.</p> <p>Les bits \\(24\\), $25, \\(26\\) s'\u00e9crivent en effet \\(100\\) et leur connaissance seule ne permet pas de trancher la question : faut-il arrondir par d\u00e9faut ou par exc\u00e8s (exactement comme arrondir en base \\(10\\) le nombre \\(9.5\\) \u00e0 l'unit\u00e9 au plus proche a \\(2\\) r\u00e9ponses).</p> <p>Dans nos exemples, on ne pousse pas les calculs trop loin apr\u00e8s le dernier bit maintenu (le \\(23\\)\u00e8me ici) et on pr\u00e9f\u00e8re calculer seulement \\(3\\) bits suppl\u00e9mentaires. Le cas o\u00f9 ces \\(3\\) bits s'\u00e9crivent \\(100\\) est g\u00e9r\u00e9 par la r\u00e8gle dite de l'arrondi au plus proche pair (cf. plus loin).</p> <p>Cas d\u00e9g\u00e9n\u00e9r\u00e9 : On peut aussi arrondir sans utiliser les bits au del\u00e0 du \\(23\\)\u00e8me : (cf. arrondi au plus proche pair)</p>"},{"location":"Nombres/2-Flottants/#float-2-real","title":"Float 2 real","text":"<p>Consid\u00e9rons le flottant \\(\\text{0100 0000 1011 1000 0000 0000 0000 0000}\\) A quel r\u00e9el correspond ce flottant ?</p> <ul> <li> Signe Exposant d\u00e9cal\u00e9 Bit cach\u00e9 + mantisse \\(0\\) \\(1000\\) \\(0001\\) \\(\\text{(1) 011 1000 0000 0000 0000 0000}\\) </li> <li>Le signe est \\(0\\), le nombre est donc positif. Le champ exposant d\u00e9cal\u00e9 est \\(e_2=10000001_2\\), autrement dit \\(e_{10} = 129\\). La valeur r\u00e9elle de l'exposant est donc \\(e_{10} -d = 129 -127 = 2\\). La significande (donc avec le bit implicite) est \\(1.0111000000000000000000_2\\).</li> <li>Conversion : \\((-1)^0\\times2^2\\times\\left(\\underset{\\text{implicite}}{1}\\times 2^0+0\\times2^{-1}+1\\times 2^{-2}+1 \\times 2^{-3} + 1\\times 2^{-4}\\right)= 5.75\\)</li> </ul> <p>Plus g\u00e9n\u00e9ralement, partant d'un flottant simple pr\u00e9cision normalis\u00e9 :</p> <ul> <li>L'\u00e9crire en binaire et retrouver chaque champs.</li> <li>Signe \\(s\\) : but de poids fort</li> <li>Convertir le binaire du champs exposant en un entier \\(e\\), lui retrancher le d\u00e9calage \\(d=127\\times(2^{8-1}-1)\\).</li> <li>Parite d\u00e9cimale \\(m\\) (indiqu\u00e9e par la mantisse \\(b_1b_2...b_{22}b_{23}\\)).</li> </ul> <p>\\(m = \\sum^{22}_{i=0}{b_i2^{-i}} = b_1 2^{-1} + b_2 2^{-2}+ ... + b_{22}2^{-22}+b_{23}2^{-23}\\).</p> <p>Le nombre r\u00e9el correspondant est \\((-1)^s(\\underset{\\text{implicite}}{1}+m)2^{e-127}\\).</p>"},{"location":"Nombres/2-Flottants/#portee","title":"Port\u00e9e","text":"<p>Figure - Quelques nombres positifs (Wikipedia)</p>"},{"location":"Nombres/2-Flottants/#exemples-et-regles-darrondis","title":"Exemples et r\u00e8gles d'arrondis","text":""},{"location":"Nombres/2-Flottants/#choix-du-nombre-le-plus-proche","title":"Choix du nombre le plus proche","text":"<p>Arrondi au plus proche</p> <ul> <li>Soit un nombre de mantisse \\(1101100000000...\\)</li> <li>Le significande complet avec bit cach\u00e9 est \\(1.1101100...\\)</li> <li> <p>On veut l'arrondir \u00e0 \\(3\\) chiffres apr\u00e8s la virgule. On a le choix entre \\(1.110\\) ou \\(1.110 + 0.001 = 1.111\\)</p> <ul> <li>\\(2^0 + \\frac{1}{2} + \\frac{1}{2^2}+0+\\underbrace{\\frac{1}{2^4}+\\frac{1}{2^5}}_{\\text{partie \u00e0 arrondir}} \u223c 111011\\)</li> <li>Arrondi par d\u00e9faut : \\(2^0 + \\frac{1}{2^1} + \\frac{1}{2^2}+0 \u223c 1.110\\)</li> <li>Arrondi par exc\u00e8s : \\(2^0 + \\frac{1}{2^1} + \\frac{1}{2^2}+ \\frac{1}{2^3} \u223c 1.111\\)</li> </ul> </li> <li> <p>\\(r=\\frac{1}{2^4} + \\frac{1}{2^5}\\) est-il plus proche de \\(0\\) ou de \\(\\frac{1}{2^3}\\) ?</p> </li> <li>Plus proche de \\(\\frac{1}{2^3}\\).</li> <li>R\u00e9ponse : \\(1.111\\).</li> </ul>"},{"location":"Nombres/2-Flottants/#cas-de-lexamen-de-3-bits-apres-le-dernier-maintenu","title":"Cas de l'examen de \\(3\\) bits apr\u00e8s le dernier maintenu","text":"<p>L'exemple pr\u00e9c\u00e9dent \u00e9tait facile car il ya avait une seule r\u00e9ponse possible.</p> <p>Mais que se passe-t-il quand on a le choix ? Par exemple, en base \\(10\\), comment arrondir \u00e0 l'unit\u00e9 \\(1.500\\) qui est aussi proche de \\(1\\) que de \\(2\\) ? Arrondir au plus proche pair signifie choisir \\(2\\) plut\u00f4t que \\(1\\).</p> <p>En base deux, le probl\u00e8me se pose lorsque le nombre apr\u00e8s le dernierbit maintenu est \\(100\\) (si \\(3\\) bits au del\u00e0 du dernier maintenu).</p> <p>En base deux, on prend en g\u00e9n\u00e9ral l'arrondi au plus proche pair. Il faut que le dernier chiffre de l'\u00e9criture binaire soit pair.</p> <p>Arrondir au plus proche pair revient, lorsqu'on a le choix, \u00e0 privil\u00e9gier les \u00e9critures qui se terminent par \\(0\\)</p>"},{"location":"Nombres/2-Flottants/#exemples-darrondis-au-plus-proche-pair","title":"Exemples d'arrondis au plus proche pair","text":"<ul> <li>Arrondir \\(1.100100\\) \u00e0 \\(3\\) chiffres apr\u00e8s la virgule : plus proche pair \\(1.100\\) (\\(0\\) est pair).</li> <li>Arrondir \\(1.101100\\) \u00e0 \\(3\\) chiffres apr\u00e8s la virgule : \\(1\\) est impair. Plus proche pair : \\(1.101 + 0.001 = 1.110\\)</li> <li>Arrondir \\(1.111100\\) \u00e0 \\(3\\) chiffres apr\u00e8s la virgule : \\(1\\) est impair. Plus proche pair : \\(1.111 + 0.001 = 10.000\\). Il faut changer l'exposant (ajouter \\(1\\) \u00e0 l'exposant)!!</li> <li>Lorsqu'on est dans le cas de figure o\u00f9 il faut changer l'exposant, et que l'exposant est lui m\u00eame maximum (\\(254 = 127+127\\) oiur les nombres sur \\(32\\) bits), on se retrouve avec un nombre consid\u00e9r\u00e9 comme infini !</li> </ul>"},{"location":"Nombres/2-Flottants/#regle-darrondi-au-plus-proche-pair","title":"R\u00e8gle d'arrondi au plus proche pair","text":"<p>Arrondi au troisi\u00e8me chiffre apr\u00e8s la virgule : </p> <p>\\(1.01110011 = \\underbrace{1.011}_{\\text{bits maintenus}} \\overbrace{10011}^{\\text{bits tronqu\u00e9s}}\\)</p> <p>On consid\u00e8re les trois chiffres apr\u00e8s le dernier bit maintenu :</p> <ul> <li>\\(0xy\\) : juste tronquer l'expression (\\(x,y\\) sont quelconques).</li> <li>\\(100\\) :  Arrondir au plus proche pair :<ul> <li>Si le dernier bit maintenu vaut \\(0\\) : ne rien faire.</li> <li>Sinon, ajouter \\(1\\) au dernier bit maintenu en tenant compte des retenus.</li> </ul> </li> <li>\\(1xy\\), avec \\(x+y &gt; 0\\): ajouter \\(1\\) au dernier bit maintenu.</li> </ul> <p>Dans l'exemple, les trois chiffres apr\u00e8s le dernier bit maintenu forment \\(100\\) (\u00e9quidistance). L'arrondi au plus proche pair est \\(1.011 + 0.001 =1.100\\).</p>"},{"location":"Nombres/2-Flottants/#problemes-induits-par-la-norme","title":"Probl\u00e8mes induits par la norme","text":""},{"location":"Nombres/2-Flottants/#expressions-infinies","title":"Expressions infinies","text":"<p>Les nombre flottants rep\u00e9sentent des rationnels ayant une expression finie. Quid des expression illimit\u00e9es ?</p> <p>\\(\\frac{1}{5} = 0.2\\) admet une expression finie en base \\(\\textit{10}\\), \\((EF10)\\) mais pas \\(\\frac{1}{3}\\).</p> <p>En base \\(2\\), \\(\\frac{1}{a}\\) admet une \\(EF2\\) si et seulement si \\(a=2^n\\) (\\(n&gt;0\\)).</p> <p>\\(\\frac{1}{10} = 0.1\\) en base \\(10\\). Donc \\(\\frac{1}{10}\\) a une \\(EF10\\) mais pas une \\(EF2\\) car \\(10 = 2 \\times 5\\) et que \\(5\\) est premier avec \\(2\\).</p> <p>Il faut donc arrondir. Le standard \\(IEEE-754\\) p\u00e9voit \\(5\\) m\u00e9thodes.</p> <p>R\u00e8gle de l'Arrondi correct</p> <p>Une fois un modde d'arrondi choisi, le r\u00e9sultat d'une op\u00e9ration est d\u00e9terminsite : un seul r\u00e9sultat est possible.</p> <p>Un dixi\u00e8me</p> <p>\\(0.1\\) en base \\(10\\) correspond \u00e0 la s\u00e9quence suivante : </p> <p>\\(s=0=S, e=-4+127\\) donc \\(E=01111011\\), \\(M\\) est une s\u00e9quence infinie \\(\\text{1.1001 1001 1001 1001 1001 100 110 0 ...}\\) Alors \\(1+ m = 1.1001100110011001101_2\\)</p> <p>Du fait des arrondis, le nombre que repr\u00e9sente \\(0.A\\) sur un ordinateur avec flottants sur \\(32\\) bits est en fait le nombre \\(\\frac{13421773}{134217728}\\) soit \\(0.100000001490116\\)</p>"},{"location":"Nombres/2-Flottants/#regle-de-larrondi-correct","title":"R\u00e8gle de l'arrondi correct","text":"<p>La norme \\(\\text{IEEE 754}\\) impose l'arrondi correct pour les \\(5\\) op\u00e9rations de base et la racine carr\u00e9e : Un programme les utilisant donne le m\u00eame r\u00e9sultat sur toute configuration (machine, syst\u00e8me, processeur). Sous r\u00e9serve :</p> <ul> <li>qu'il n'y ait pas de pr\u00e9cision interm\u00e9diaire \u00e9tendue (ou alors d\u00e9sactiv\u00e9e). \u00c7a veut dire que les r\u00e9sultats interm\u00e9diaires du calcul d'une expression ne doivent pas \u00eatre calcul\u00e9s avec une pr\u00e9cision plus grande que celle attendue pour le r\u00e9sultat.</li> <li>le compilateur ne doit pas changer l'ordre des op\u00e9rations si cela peut conduire \u00e0 un r\u00e9sultat diff\u00e9rent.</li> </ul>"},{"location":"Nombres/2-Flottants/#probleme-darrondi-celebre","title":"Probl\u00e8me d'arrondi c\u00e9l\u00e8bre","text":"<p>Patriot</p> <p>En \\(1991\\), un anti-missile Patriot rate l'interception d'un missile irakien Skud, lequel blesse \\(100\\) personnes, et en tuer \\(28\\).</p> <p>Un micro-processeur interne calcule l'heure en multiples de dixi\u00e8mes de secondes.</p> <p>Le nombre de dixi\u00e8mes de secondes depuis le d\u00e9marrage est stock\u00e9 dans un registre entier puis multiplit\u00e9 par une approximation de \\(\\frac{1}{10}\\) sur \\(24\\) bits pour obtenir le temps en seconde.</p> <p>Approximation : \\(209715\\times2^{-21}\\), erreur \\(10^{-7}\\).</p> <p>Processeur d\u00e9marr\u00e9 \\(100\\) heures auparavant. Erreur de \\(0.34\\) secondes pendant lequel le Skud parcourt \\(500\\)m.</p> <p>Le Patriot rate sa cible, pas le Skud.</p>"},{"location":"Nombres/2-Flottants/#double-arrondi","title":"Double arrondi","text":""},{"location":"Nombres/2-Flottants/#cas-dexamen-de-3-bits-apres-le-dernier-maintenu","title":"Cas d'examen de \\(3\\) bits apr\u00e8s le dernier maintenu","text":"<p>Soit \\(x\\) r\u00e9el, \\(y\\) l'arrondi en pr\u00e9cison \\(p\\) de \\(x\\).</p> <p>Soit \\(x'\\) arrondi en pr\u00e9cision \\(q &lt; p\\) de \\(y\\).</p> <p>\\(x'\\) n'est pas toujours l'arrondi en pr\u00e9cision \\(q\\) de \\(x\\) !</p> <ul> <li>\\(x=1.011010{\\color{red}0}101\\). Arrondir \u00e0 \\(7\\) chiffres apr\u00e8s la virgule.</li> <li>Apr\u00e8s la d\u00e9cimale \\(7\\) de \\(x\\) on a : \\(101\\) L'arrondi \\(y\\) \u00e0 \\(7\\) chiffres arp\u00e8s la virgule de \\(x\\) est \\(1.011{\\color{red}0}101\\)</li> <li>Apr\u00e8s la d\u00e9cimale \\(4\\) de \\(y\\) : \\(101\\). L'arrondi \\(x'\\) \u00e0 \\(4\\) d\u00e9cimales de \\(y\\) est \\(1.0111\\)</li> <li>MAIS, apr\u00e8s la d\u00e9cimale \\(4\\) de \\(x\\) on a \\(100\\). Suivant la r\u00e8gle de l'arrondi pair, l'arrondi \\(z\\) \u00e0 4 d\u00e9ciamles de \\(x\\) est \\(1.0110\\)</li> <li>Et on a \\(z \\neq x'\\)!</li> </ul> <p>On peut montrer que le probl\u00e8me du double arrondi n'intervient que si on choisit l'arrondi au plus proche pair. Pas de chance : c'est le mode d'arrondi le plus r\u00e9pandu !</p>"},{"location":"Nombres/2-Flottants/#pourquoi-privilegier-larrondi-au-plus-proche-pair","title":"Pourquoi privil\u00e9gier l'arrondi au plus proche pair ?","text":"<p>La m\u00e9thode de \"l'arrondi bancaire\" (autre nom pour l'arrondi au plus proche pair) est employ\u00e9e pour \u00e9liminer le biais qui surviendrait en arrondissant \u00e0 chaque fois par exc\u00e8s les nombres dont les trois derniers chiffres seraient \\(100\\).</p> <p>Transposons en base \\(10\\) : Imaginons une multinationale qui re\u00e7oit un milliards de virements exprim\u00e9s en centimes d'euros (sur une certaine p\u00e9riode) arrondis au dixi\u00e8me de centime sur un de ses comptes en banque.</p> <p>Supposons que pour un milli\u00e8me de ces virements, la partie fractionnaire soit de la forme \\(.x500\\) o\u00f9 $x\\in [![ 0,9 ]!] $.</p> <p>Si la banque arrondi le montant de ces virements au dixi\u00e8mes de centime sup\u00e9rieur (\\(.x +0.1\\), puis r\u00e9percussion de la retenue), la multinationale gagne \\(0.05\\) centime de plus par virement que ce qu'elle aurait d\u00fb toucher. Au total cela fait \\(10^6 \\times 5 \\times 10^{-2} = 5 \\times 10 ^4 = 50 000 \\text{ euros}\\) que la multinationale a gagn\u00e9s au d\u00e9triment de la banque ! \\(\\color{red}\\text{Au centime inf\u00e9rieur, ce serait la banque qui gagnerait de l'argent.}\\)</p> <p>D'o\u00f9 la n\u00e9cessit\u00e9 d'arrondir certains montants au centime sup\u00e9rieur et d'autres au centime inf\u00e9rieur pour \u00e9quilibrer, comme avec l'arrondi au plus proche pair.</p>"},{"location":"Nombres/2-Flottants/#cas-des-exceptions","title":"Cas des exceptions","text":"<p>En cas de probl\u00e8me, la norme impose de signaler des Exceptions :</p> <ul> <li>Diviser un nombre diff\u00e9rent de \\(0\\) par \\(0\\) donne \\(\u00b1\\infty\\)</li> <li>Diviser z\u00e9ro par z\u00e9ro, ou calculer le logarithme d'un nombre n\u00e9gatif conduisent \u00e0 g\u00e9n\u00e9rer des \\(\\texttt{NaN}\\) qu'on peut d\u00e9cider de consid\u00e9rer comme des exceptions.</li> <li>Nombre entier positif plus grand que le plus grand entier repr\u00e9sentable (overflow). Ou plus petit que le plus petit entier repr\u00e9sentable (underflow).</li> </ul>"},{"location":"Nombres/2-Flottants/#arithmetique-psychedelique","title":"Arithm\u00e9tique psych\u00e9d\u00e9lique","text":"<p>Attention aux tests d'\u00e9galit\u00e9</p> <pre><code>1.2 *. 3. ;;\n- : float = 3.59999999999999964\n0.1 +. 0.2;;\n- : float = 0.300000000000000044\n</code></pre> <p>Il est risqu\u00e9 d'\u00e9crire un programme avec des tests d'\u00e9galit\u00e9 entre flottants. \u00c9viter <code>if x = y then ...</code></p> <p>Il faut mieux utiliser <code>if abs_float(x-y) &lt; eps</code>. Au format double pr\u00e9cision, prendre \\(\u03b5 = 10^{-12}\\) pour comparer des flottants d'ordre de grandeur \\(1\\) est tout \u00e0 fait raisonnable.</p>"},{"location":"Nombres/2-Flottants/#arrondi-dun-calcul-commutativite-associativite","title":"Arrondi d'un calcul, commutativit\u00e9, associativit\u00e9","text":"<p>L'arrondi de la somme n'est pas la somme des arrondis. Comparer \\(0.1+0.2\\) et \\(0.3\\)</p> <p>La multipliaction et l'addition restent commutatives</p> <p>L'associativit\u00e9 se perd</p> <pre><code>let a = 9e307 and b = 9e307 and c = -2e306 in (a +. b) +. c;;\n- : float = infinity\na = 9e307 and b = 9e307 and c = -2e306 in a +. (b +. c);;\n- : float = 1.78000000000000023e+308\n</code></pre>"},{"location":"Nombres/2-Flottants/#distributivite","title":"Distributivit\u00e9","text":"<p>La distributivit\u00e9 se perd</p> <pre><code>let a = 1e-10 and b = 9e307 and c = 9e307\n    in a *. (b +. c);;\n- : float = infinity\nlet a = 1e-10 and b = 9e307 and c = 9e307 in\n    a *. b +. a *. c;;\n- : float = 1.80000000000000021e+298\n</code></pre>"},{"location":"Nombres/2-Flottants/#relation-dordre","title":"Relation d'ordre","text":"<p>Dans \\(\u211d\\), l'addition est compatible avec la relation d'ordre : si \\(a \\leq b\\) alors \\(a + c \\leq b + c\\).</p> <p>Nous avons vu que la repr\u00e9sentation en machine de \\(0.1\\) est strictement sup\u00e9rieur \u00e0 \\(0.1\\). En toute logique additionner \\(10\\) fois \\(0.1\\) devrait donner un r\u00e9sultat plus grand que \\(1\\) :</p> <pre><code>let rec add n x = \n    if n = 1 then x\n    else add (n-1) (x+. 0.1)\n        in add 10 0.1\n- : float = 0.999999999999999889\n</code></pre>"},{"location":"Nombres/2-Flottants/#convergence-et-divergence","title":"Convergence et divergence","text":"<p>Dans le cours de maths, la s\u00e9rie harmonique \\(\\sum_{k\\geq1}{\\frac{1}{k}}\\) diverge quel que soit l'ordre des op\u00e9rations. De plus, du fait de la commutativit\u00e9, les sommes partielles \\(\\sum^{n}_{k=1}{\\frac{1}{k}}\\) et \\(\\sum^{n}_{k=1}{\\frac{1}{n-k+1}}\\) sont \u00e9gales.</p> <p>Avec l'ordre d\u00e9croissant :</p> <pre><code>let rec harmonique_dec n x = if n = 0 then x\nelse harmonique_dec (n-1) (1./. float_of_int n +.x)\n    ;;\nval harmonique_dec : int -&gt; float -&gt; float = &lt;fun&gt;\nharmonique_dec (int_of_float 1e5) 0.;;\n- : float = 12.0901461298634079\n</code></pre> <p>Derni\u00e8res d\u00e9cimales \\(4079\\)</p> <p>Et l'ordre croissant :</p> <pre><code>let rec harmonique_cr n m x = if n = m+1 then x\nelse harmonique_cr (n+1) m (1. /. float_of_int n +.x);;\nval harmonique_cr : int -&gt; int -&gt; float -&gt; float =\n&lt;fun&gt;\nharmonique_cr 1 (int_of_float 1e5) 0.;;\n- : float = 12.090146129863335\n</code></pre> <p>Les derni\u00e8res d\u00e9cimales des deux r\u00e9sultats ne sont pas \u00e9gales alors m\u00eame que l'addition est commutative...</p> <p>De plus cette s\u00e9rie converge pour les nombres flottants. Apr\u00e8s un certain rang, \\(\\frac{1}{n}\\) devient plus petit que le plus petit nombre d\u00e9normalis\u00e9 et est compt\u00e9 comme \\(0\\).</p>"},{"location":"Nombres/2-Flottants/#infinis-et-textttnan","title":"Infinis et \\(\\texttt{NaN}\\)","text":"<pre><code>5./.0. , -5./.0.;;\n- : float * float = (infinity , neg_infinity)\nsqrt (-1.);;\n- : float = nan\nmax_float ;;\n- : float = 1.79769313486231571e+308\nmax_float +. 10.;;\n- : float = 1.79769313486231571e+308\nmax_float +. max_float ;;\n- : float = infinity\n</code></pre>"},{"location":"Nombres/2-Flottants/#ecart-avec-le-successeur","title":"\u00c9cart avec le successeur","text":"<p>L'\u00e9cart entre \\(x\\) et son successeur est croissant avec \\(x\\)</p> <pre><code>1. +. 1e-16, 1. +. 1e -15;;\n- : float * float = (1., 1.00000000000000111)\n1e16 +. 1., 1e16 +. 10.;;\n- : float * float = (1e+16, 10000000000000010.)\nmin_float ;;\n- : float = 2.22507385850720138e-308\n</code></pre> <p>Ainsi, si on veut de la pr\u00e9cision dans les calculs faisant intervenir de grands nombres, on a int\u00e9r\u00eat \u00e0 travailler avec inverses.</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/","title":"OCaml","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> Sommaire <ul> <li> <p>G\u00e9n\u00e9ralit\u00e9s</p> <ul> <li>Compilation</li> <li>Boucle interractive</li> </ul> </li> <li> <p>Variable</p> </li> <li>Les types de base</li> <li>Expressions conditionnelles</li> <li>Fonction </li> <li>Filtrage sur les listes</li> </ul> <p>Cr\u00e9dits</p> <ul> <li>Ce cours de Olivier Pons </li> <li>Cette page de la documentation officielle et les remarques \u00e0 propos des parenth\u00e8ses. (Le vieux lien n'exsite plus donc \u00e7a vous renvoie sur la page principale d'OCaml)</li> <li>Cette introduction de Jean-Christophe Filliatre</li> <li>Quelques mots sur la compilation</li> </ul> <p>Bonus pour approfondir le cours</p> <p>Cette page et les \\(3\\) suivantes (cliquer sur page suivante) sont aussi tr\u00e8s instructives.</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":""},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#compilation","title":"Compilation","text":""},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#2-compilateurs-mp2i","title":"2 Compilateurs (MP2I)","text":"<p>Il y a deux compilateurs en OCaml:</p> <ul> <li><code>ocamlc</code> qui produit un bytecode ; un code compr\u00e9hensible par un interpr\u00e9teur appel\u00e9 <code>ocamlrun</code>. Avantages : simplicit\u00e9, portabilit\u00e9 et rapidit\u00e9 de compilation.</li> <li><code>ocamlopt</code> qui compile directement en langage machine (l'ex\u00e9cution sera alors plus rapide qu'avec l'intrepr\u00e9teur). Il accepte des fichiers de type <code>.ml</code> (fichiers de code) et <code>.mli</code> (fichiers d'interfaces). Il produit :</li> <li>Un fichier objet <code>.o</code> en langage machine ;</li> <li>Un fichier <code>.cmx</code> contenant des informations pour l'\u00e9dition de lien et l'optimisation des relations entre les divers modules.</li> <li>Un fichier d'interface <code>.cmi</code> qui contient les signatures des types export\u00e9s vers d'autres unit\u00e9s de compilation.</li> </ul>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#hello-world-mp2i","title":"Hello world (MP2I)","text":"<p>Dans un fichier <code>hello.ml</code> \u00e9crivons</p> <pre><code>print_string \"hello world\\n\"\n</code></pre> <p>Pas besoin de fonction <code>main()</code>. Pas besoin de parenth\u00e8se !</p> <p>Compilons et ex\u00e9cutons (dans un terminal)</p> <pre><code>ocamlopt  asup.ml \u2212o hello\n</code></pre> <p>Sans surprise, la commande <code>./toto</code> affiche</p> <pre><code>hello world\n</code></pre> <p>Listons les fichiers de pr\u00e9fixe <code>hello</code></p> <pre><code>$ls hello\u2217\nhello hello.cmi hello.cmx hello.ml hello.o\n</code></pre>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#commentaires","title":"Commentaires","text":"<p>Les commentaires en OCaml commencent par <code>(*</code> et finissent par <code>*)</code> .</p> <pre><code>(*on d\u00e9clare x et on teste si il est pair ou impair *)\nlet x = 3 in x mod 2;;\n(*On peut\nfaire des commentaires\nsur plusieurs lignes *)\n</code></pre>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#application-dune-fonction-a-ses-arguments","title":"Application d'une fonction \u00e0 ses arguments","text":"<p>En OCaml, l'application d'une fonction s'\u00e9crit par simple juxtaposition de la fonction et de son argument. \u00c0 la diff\u00e9rence de la plupart des langages o\u00f9 l'application de <code>f</code> \u00e0 <code>x</code> doit s'\u00e9crire <code>f(x)</code> , on se contente ici d'\u00e9crire <code>f x</code>.</p> <p>Remarque</p> <p>Rien n'interdit d'\u00e9crire <pre><code>print_string(\"hello world!\\n\")\n</code></pre></p> <p>Mais les parenth\u00e8ses autour de la cha\u00eene de caract\u00e8res sont tout simplement inutiles. Et c'est consid\u00e9r\u00e9 comme in\u00e9l\u00e9gant.</p> <p>En dehors des appels de fonctions, les parenth\u00e8ses peuvent et doivent \u00eatre utilis\u00e9es lorsque les priorit\u00e9s des op\u00e9rateurs l'exigent, comme dans l'expression <code>2*(1+3)</code> .</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#affichage-avec-printf","title":"Affichage avec <code>printf</code>","text":"<p>L'affichage en OCaml est un peu contraignant :</p> <ul> <li><code>print_string</code> pour les cha\u00eenes de caract\u00e8res,</li> <li><code>print_int</code> pour les entiers,</li> <li><code>print_float</code> pour les flottants...</li> </ul> <p>Heureusement, OCaml emprunte au C quelques habitudes comme la fonction <code>printf</code> du module <code>Printf</code>.</p> <pre><code># Printf.printf \"une cha\u00eene : %s, un entier : %d, un flottant %f\\n\" \"toto\" 45 32.3;;\n une cha\u00eene : toto , un entier : 45, un flottant 32.300000\n- : unit = ()\n</code></pre>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#boucle-interractive","title":"Boucle interractive","text":""},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#presentation","title":"Pr\u00e9sentation","text":"<p>Le plus souvent, nous ne compilerons pas les codes <code>.ml.</code></p> <p>Nous nous contenterons d'utiliser une boucle interractive. Il en existe plusieurs. Faisons un rapide tour d'horizon.</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#dans-un-terminal","title":"Dans un terminal","text":"<p>OCaml est un langage compil\u00e9. Cependant</p> <pre><code>print_string \"hello\\n\";;(*un commentaire*)\nhello\n- : unit = ()\n1+2;; (* ne pas oublier les deux points-virgules*)\n- : int = 3\n</code></pre> <p>Observons que le type des expressions est calcul\u00e9 (on dit inf\u00e9r\u00e9) et affich\u00e9. Ici, le type <code>unit</code> correspond au type <code>void</code> en C.</p> <p>On quitte la boucle interactive avec la commande <code>exit(0);;</code></p> <p>Le double point-virgule s\u00e9pare les diff\u00e9rentes d\u00e9calarations et expressions \u00e0 \u00e9valuer.</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#interpreteurs-en-ligne","title":"Interpr\u00e9teurs en ligne","text":"<p>Si on n'a pas encore install\u00e9 OCaml sur sa machine, on peut utiliser un interpr\u00e9teur en ligne :</p> <ul> <li>TryOCaml;</li> </ul> <p></p> <ul> <li>Better OCaml;</li> </ul> <p></p> <p>Raccourcis :</p> <ul> <li><code>Ctrl+Enter</code> Ex\u00e9cute le code s\u00e9lectionn\u00e9</li> <li><code>Ctrl+Shif+Enter</code> Ex\u00e9cute le code entier.</li> <li><code>Ctrl+Space</code> montre le menu d'autocompl\u00e9tion</li> </ul>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#tuareg","title":"Tuareg","text":"<p>Pour ma part, j'utilise le greffon Tuareg d'emacs pour rendre plus agr\u00e9able l'utilisation de l'interpr\u00e9teur OCaml.</p> <p></p> <p>Consulter par exemple cette page.</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#variables","title":"Variables","text":"<p>Syntaxe <code>let &lt;id&gt; = &lt;expr&gt;</code>. Le plus souvent <code>&lt;id&gt;</code> est un identificateur (il commence par une lettre minuscule ou un underscore). La partie \u00e0 droite  de l'\u00e9galit\u00e9 est une expression (elle peut \u00eatre le r\u00e9sultat d'un calcul).</p> <p>Une d\u00e9claration affecte le r\u00e9sultat de l'\u00e9valuation d'une expression \u00e0 une varialble, et est introduite par le mot cl\u00e9 <code>let</code>. Par exemple \u00e9crivons ceci :</p> <pre><code>let x = 1 + 2;;\nprint_int x;;\nlet y = x * x;;\nprint_int y;;\n</code></pre> <p>Le programme calcule le r\u00e9sultat de <code>1+2</code>, l'affecte \u00e0 la variable <code>x</code>, affiche la valeur de <code>x</code>, puis calcule le carr\u00e9 de <code>x</code>, l'affecte \u00e0 la variable <code>y</code> et enfin affiche la valeur de <code>y</code>.</p> <p><code>x,y</code> sont des variables globales utilisables ailleurs dans le programme.</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#a-propos-des-variables","title":"\u00c0 propos des variables","text":"<p>Une variable est n\u00e9cessairement initialis\u00e9e.</p> <p>Le type de la variable n'a pas besoin d'\u00eatre d\u00e9clar\u00e9, il est inf\u00e9r\u00e9 par le compilateur.</p> <p>Le contenu de la variable n'est pas modifiable. Dans le code pr\u00e9c\u00e9dent, \\(x\\) contient \\(3\\) pour toute la dur\u00e9e du programme. La variable est immuable ou persistante (on est en paradigme fonctionnel).</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#variable-persistante-vraiment","title":"Variable persistante, vraiment ?","text":"<pre><code>let x =3;;\n val x : int = 3\nlet x = 4;; (*c'est une AUTRE variable x*)\n val x : int = 4\n</code></pre>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#variable-locale","title":"Variable locale","text":"<p>En C, les variables locales sont d\u00e9finies dans un bloc d\u00e9limit\u00e9 par des accolades et elles n'ont pas d'existence hors de ce bloc.</p> <pre><code>    {\n      int x = 10 ;\n      ...\n    }\n</code></pre> <p>En OCaml, il n'y a pas de notion de bloc. Les variables locales d'une expression sont introduites par la construction <code>let in</code> .</p> <pre><code>let x=10 in 2*x;;\n- : int = 20\n</code></pre> <p>Les variables locales sont immuables et obligatoirement initialis\u00e9es.</p> <p>Port\u00e9e de la variable <code>x</code> :</p> <pre><code>let x=10 in 2*x;;\n- : int = 20\nx;;\n Error: Unbound value x\n</code></pre> <p>Une d\u00e9claration locale est visible seulement dans l'expression qui suit le <code>in</code>.</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#les-types-de-base","title":"Les types de base","text":""},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#types-de-base","title":"Types de base","text":"<ul> <li>entiers (<code>int</code>), op\u00e9rateurs : <code>+ - * / mod</code></li> <li>flottants (<code>float</code>), op\u00e9rateurs : <code>+. -. *. /.</code></li> <li>caract\u00e8res (<code>char</code>), <code>'a','b','1' ...</code> avec une seule quote.</li> <li>cha\u00eenes, (<code>string</code>), <code>\"abc\", \"b\"</code> (double quotes), concat\u00e9nation :</li> </ul> <pre><code>\"toto\" ^ \" et gogo\";;\n- : string = \"toto et gogo\"\n</code></pre> <ul> <li>bool\u00e9ans, (<code>bool</code>), <code>true, false</code> ; op\u00e9rateurs : <code>&amp;&amp;, || , not</code></li> <li>Op\u00e9rateur de comparaison de valeurs pour tous les types <code>=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;</code>. Polymorphes, mais les deux arguments doivent avoir le MEME type.</li> <li>Op\u00e9rateur de comparaison physique pour tous les types <code>==, !=</code></li> </ul> <p>Quelques op\u00e9rations</p> <pre><code>1+2;;\n- : int = 3\n1.5+.3.5;;\n- : float = 5.\n2&gt;7;;\n- : bool = false\n\"bonjour\" &gt; \"bon\";;\n- : bool = true\n\"durand\" &lt; \"martin\";;\n- : bool = true\n\"ab\" = \"ba\";;\n- : bool = false\n6 mod 2;;\n- : int = 0\n</code></pre>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#type-unit","title":"Type unit","text":"<p>Pour d\u00e9finir une fonction sans r\u00e9sultat, OCaml introduit le type <code>unit</code> qui ne contient qu'une seule valeur, not\u00e9e <code>()</code>.</p> <p>C'est par exemple le type de retour de la fonction <code>print_string</code>.</p> <p>Il sert aussi \u00e0 d\u00e9finir des fonctions sans argument.</p> <p>Il joue un r\u00f4le comparable au type <code>void</code> de C.</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#types-construits-predefinis","title":"Types construits pred\u00e9finis","text":"<p>Les tuples (<code>t1 * t2 * .. * tn</code>) o\u00f9 <code>ti</code> est le type de la composante \\(i\\) du n-uplet.</p> <pre><code>let x = false , 5, \"hello\";;\n val x : bool * int * string = (false , 5, \"hello\")\nlet a,b,c= x;; (* unpacking *);;\n val a : bool = false\n val b : int = 5\n val c : string = \"hello\"\n</code></pre> <p>Les listes <code>t_list</code> , o\u00f9 <code>t</code> est le type des \u00e9l\u00e9ments.</p> <pre><code>[1;2;3];; (* une liste d'entiers *)\n- : int list = [1; 2; 3]\n[\"a\";\"bc\"] @ [\"bonjour\"];; (*@: operateur de concatenation *)\n- : string list = [\"a\"; \"bc\"; \"bonjour\"]\n[1]@[];; (* []: liste vide *)\n- : int list = [1]\n</code></pre>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#plus-sur-les-listes","title":"Plus sur les listes","text":"<p>La liste vide est polymorphe. <pre><code>[];;(*la liste vide est polymorphe *)\n- : 'a list = []\n</code></pre></p> <p>Le module <code>List</code> contient des fonctions de manipulation de listes:</p> <pre><code>List.length [1;2;3];; (* En O(n) !!! *)\n- : int = 3\nList.hd [1;2;3];; (*t\u00eate (head) de la liste; O(1)*)\n- : int = 1\nList.tl [1;2;3];; (* queue (tail) de la liste; O(1)*)\n- : int list = [2; 3]\n3::[2;1];; (* ajouter un \u00e9l\u00e9ment en t\u00eate de liste *)\n- : int list = [3; 2; 1]\nlet a::b = [1;2;3];; (*s\u00e9parer la t\u00eate de la queue *)\n  ! Warning 8: this pattern -matching is not exhaustive !\n val a : int = 1\n val b : int list = [2; 3]\n</code></pre>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#plus-sur-les-tuples","title":"Plus sur les tuples","text":"<p>Cas d'un tuple de taille \\(2\\) :</p> <pre><code>let y = 1 ,6.2;;\n val y : int * float = (1, 6.2)\nfst y;; (*pour first y*)\n- : int = 1\nsnd y;; (*pour second y*)\n- : float = 6.2\n</code></pre> <p>Tuples contenant des tuples</p> <pre><code>let z= (y,(2. +. 1.,4));;\n val z : (int * float) * (float * int) = ((1, 6.2), (3., 4))\nlet a,b = z;;\n val a : int * float = (1, 6.2)\n val b : float * int = (3., 4)\nlet ((e,f),(g,h)) = z;;\n val e : int = 1\n val f : float = 6.2\n val g : float = 3.\n val h : int = 4 \n</code></pre> <p>D\u00e9construire un tuple en ne prenant que certains items.</p> <pre><code>let (_,(_,i)) = z;;\n val i : int = 4\n</code></pre> <p>Le symbole <code>_</code> indique la pr\u00e9sence d'une composante sans la nommer.</p> <p>Isomorphisme de types :</p> <ul> <li>Un \u00e9l\u00e9ment de type <code>int * int * int</code> est un triplet d'entier.</li> <li>Un \u00e9l\u00e9ment de type <code>int * (int * int)</code> est un couple dont le premier \u00e9l\u00e9ment est un entier et le second un couple d'entiers.</li> <li>Un \u00e9l\u00e9ment de type <code>(int * int) * int</code> est un couple dont le premier \u00e9l\u00e9ment est un couple d'entiers et le second un entier</li> <li>Les \\(3\\) ensembles des \u00e9l\u00e9ments appartenant \u00e0 chacun de ces \\(3\\) types sont en bijection canonique. C'est un exemple d'isomorphisme de types. Malheureusement, pour OCaml, ces types sont bien distincts !</li> </ul>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#expressions-conditionnelles","title":"Expressions conditionnelles","text":""},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#les-mots-cles-if-then-else","title":"Les mots cl\u00e9s <code>if</code> then <code>else</code>","text":"<p>En OCaml, il n'y a pas de distinction expression/instruction : il n'y a que des expressions.</p> <p>Les expressions conditionnelles sont d\u00e9finies \u00e0 l'aide de l'op\u00e9rateur ternaire <code>if e1 then e2 else e3</code>.</p> <p>L'expression <code>e1</code> doit renvoyer une valeur boul\u00e9enne.</p> <p>En g\u00e9n\u00e9ral (sauf cas particulier o\u00f9 <code>e2</code> est de type <code>unit</code>) la branche n\u00e9gative est obligatoire.</p> <p>Une expression conditionnelle est polymorphe : i.e. <code>e2</code> peut \u00eatre de n'importe quel type, mais <code>e3</code> est obligatoirement du m\u00eame type que <code>e2</code>.</p> <p><pre><code>let x = 42;;\n val x : int = 42\nlet v = 10 + (if x &gt; 0 then -1 else 4);;\n val v : int = 9\n</code></pre> Branche n\u00e9gative non obligatoire si type <code>unit</code> : <pre><code>if (3 mod 2 = 1) then print_string \"okayyyyy\";;\n okayyyyy - : unit = ()\n</code></pre></p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#fonction","title":"Fonction","text":""},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#fonctions-anonymes","title":"Fonctions anonymes","text":"<p>Les fonctions en OCaml sont des valeurs comme les autres. Syntaxe : <code>fun &lt;id&gt; -&gt; &lt;expr&gt;</code>.</p> <ul> <li><code>&lt;id&gt;</code> d\u00e9signe le param\u00e8tre de la fonction. Il a une port\u00e9e localis\u00e9e au corps de la fonction.</li> <li><code>-&gt;</code> d\u00e9signe le d\u00e9but du corps de la fonction.</li> <li><code>&lt;expr&gt;</code> est une expression quelconque qui peut utiliser <code>&lt;id&gt;</code>.</li> </ul> <p>Fonction produit \\(x \u2192x \u00d7x\\) : <pre><code>fun x -&gt; x*x;;(* fonction anonyme *)\n- : int -&gt; int = &lt;fun&gt;\n(fun x -&gt; x*x) 5;;(* appliquer une fonction anonyme *)\n- : int = 25\n</code></pre></p> <p>Observer le type de la fonction. Il est not\u00e9 sous la forme \\(\u03c4_1 \u2192\u03c4_2\\).</p> <p>Inf\u00e9rence de type : comme on utilise l'op\u00e9rateur <code>*</code> , OCaml en d\u00e9duit que le type de la fonction est <code>int -&gt; int</code> .</p> <p>Pour nommer une fonction : <pre><code>let f = fun x y -&gt; x +. y;; (*d\u00e9clarer f*)\n val f : float -&gt; float -&gt; float = &lt;fun&gt;\nf 1. 2.;; (* utiliser f*)\n - : float = 3.\n</code></pre></p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#sucre-syntaxique-forcer-le-type-du-parametre","title":"Sucre syntaxique ; Forcer le type du param\u00e8tre","text":"<p>OCaml permet de d\u00e9clarer une fonction de fa\u00e7on plus concise que <code>let f = fun ...</code> .</p> <pre><code>let f x y = x +. y;;\n(*\u00e9quivalent \u00e0 let f = fun x y -&gt; x+.y*)\nf 1. 2.;;\n</code></pre> <p>On peut indiquer le type du param\u00e8tre et celui de retour :</p> <pre><code>let f (x:int) : int = x+x;;\n</code></pre> <p>C'est ici surtout utile pour le lecteur.</p> <p>Attention aux priorit\u00e9s (penser aux parenth\u00e8ses) :</p> <pre><code>f 3 + 5, (f 3) + 5, f (3+5);;\n- : int * int * int = (11, 11, 16)\n</code></pre> <p>En OCaml, l'application d'une fonction est syntaxiquement plus prioritaire que les autres op\u00e9rations.</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#application-de-fonction","title":"Application de fonction","text":"<p>En programmation fonctionnelle, l'application de fonction est la seule op\u00e9ration qui permette d'effectuer un calcul. M\u00eame <code>2 + 3</code> est en fait du sucre syntaxique pour exprimer l'application de <code>(+)</code> \u00e0 <code>2</code> et <code>3</code> : c.a.d <code>(+) 2 3</code></p> <p>Pour effectuer <code>&lt;expr1&gt; &lt;expr2&gt;</code> :</p> <ul> <li>On \u00e9value <code>&lt;expr1&gt;</code> . C'est n\u00e9cessairement une fonction de la forme <code>fun x -&gt; e</code> de type \\(\u03c4\u2192\u03c4\u2032\\).</li> <li>On \u00e9value <code>&lt;expr 2&gt;</code> . L'expression r\u00e9sultante <code>v</code> doit \u00eatre de type \\(\u03c4\\).</li> <li>On \u00e9value l'expression <code>e</code> dans un environnement o\u00f9 <code>x</code> est associ\u00e9 \u00e0 la valeur <code>v</code> . La valeur renvoy\u00e9e est de type \\(\u03c4\u2032\\).</li> </ul>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#fonction-sans-argument","title":"Fonction sans argument","text":"<p>Une fonction sans argument prend en fait un unique argument de type <code>unit</code> (qu'on note <code>()</code>).</p> <p><pre><code>let f () = print_string \"coucou\";;\nval f : unit -&gt; unit = &lt;fun&gt;\n</code></pre> Bien s\u00fbr, la fonction <code>f</code> ci-dessus peut \u00eatre vue comme un alias pour l'expression <code>print_string \"coucou\"</code>.</p> <p>Les fonctions dont le type de retour est <code>unit</code> sont souvent utilis\u00e9es pour r\u00e9aliser des affichages ou bien des mises \u00e0 jour de variables mutables (tableaux, r\u00e9f\u00e9rences...).</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#fonction-sans-resultat","title":"Fonction sans r\u00e9sultat","text":"<p>Les fonctions sans r\u00e9sultat sont utilis\u00e9es \u00e0 des fins d'affichage et/ou pour r\u00e9aliser des effets de bord. Pour le moment toutes nos variables sont persistantes mais on d\u00e9couvrira bient\u00f4t comment cr\u00e9er des variables mutables.</p> <pre><code>let print_square x =\nPrintf.printf \"%f^0.5=%f\" x (sqrt x);;\n val print_square : float -&gt; unit = &lt;fun&gt;\nprint_square 2.;; (* Observer : '2.' pas '2'*)\n 5 2.000000^0.5=1.414214 - : unit = ()\n</code></pre>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#ordre-superieur","title":"Ordre sup\u00e9rieur","text":"<p><pre><code>let f x = x*x;;\n val f : int -&gt; int = &lt;fun&gt;\nlet affiche f x = print_int (f x);;\n val affiche : ('a -&gt; int) -&gt; 'a -&gt; unit = &lt;fun&gt;\naffiche f 2;;\n- : unit = ()\n</code></pre> Ci-dessus <code>affiche</code> prend deux arguments : une fonction d'un certain type (not\u00e9 <code>'a</code> ) vers les entiers, un \u00e9l\u00e9ment de type <code>'a</code> . Le type de retour est unit . Le type de la fonction est donc <code>('a -&gt; int) -&gt; 'a -&gt; unit = &lt;fun&gt;</code></p> <p>On a vu qu'on peut passer une fonction en argument. On peut aussi renvoyer une fonction.</p> <p>renvoie de l'homoth\u00e9tie de rapport \\(x\\) : <pre><code>let homothetie x = fun a -&gt; a * x;;\n val homothetie : int -&gt; int -&gt; int = &lt;fun&gt;\n(homothetie 3) 5;;\n- : int = 15\nlet g = homothetie 3 in g 5;;\n- : int = 15\n</code></pre></p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#application-partielle","title":"Application partielle","text":"<p>D\u00e9finissons une fonction \u00e0 deux arguments :</p> <pre><code>let milieu x y = (x+.y)/.2.;;\n val milieu : float -&gt; float -&gt; float = &lt;fun&gt;\nmilieu 2. 3.;;\n- : float = 2.5\n</code></pre> <p>Lorsqu'une fonction a plusieurs arguments, on n'est pas oblig\u00e9 de les lui fournir tous lors de l'application. Si on ne le fait pas le r\u00e9sultat de cette application partielle est lui m\u00eame une fonction qui peut \u00e9ventuellement \u00eatre li\u00e9 a un identificateur et \u00eatre appliqu\u00e9 par la suite.</p> <pre><code>let g = milieu 2.;;\nval g : float -&gt; float = &lt;fun&gt;\ng 3.;;\n- : float = 2.5\n</code></pre>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#fonctions-recursives","title":"Fonctions r\u00e9cursives","text":"<p>Ecrivons la fonction <code>puissance</code></p> <pre><code>let puissance b n =\n    if n =0 then 1\n    else b * puissance b (n-1);;\n\nCharacters 69 -78:\n    else b * puissance b (n-1);;\n                       ^^^^^^^^^\nError: Unbound value puissance\n</code></pre> <p>Il faut pr\u00e9venir le compilateur que la fonction est r\u00e9cursive en faisant suivre le mot clef <code>let</code> du mot clef <code>rec</code>. <pre><code>let rec puissance b n =\n    if n =0 then 1\n    else b * puissance b (n-1);;\n val puissance : int -&gt; int -&gt; int = &lt;fun&gt;\n</code></pre></p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#fonctions-mutuellement-recursives","title":"Fonctions mutuellement r\u00e9cursives","text":"<p>On utilise une construction de la forme <code>let rec g = ... and f = ...</code> Calcul de parit\u00e9</p> <pre><code>let rec pair n = (n=0) || impair (n-1)\nand impair n = (n &lt;&gt; 0) &amp;&amp; pair (n-1);;\n val pair : int -&gt; bool = &lt;fun&gt;\n val impair : int -&gt; bool = &lt;fun&gt;\npair 5;;\n- : bool = false\nimpair 5;;\n- : bool = true\n</code></pre>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#filtrage-sur-motif-de-largument","title":"Filtrage sur motif de l'argument","text":"<p>Quand on conna\u00eet la forme du motif de l'argument, on peut anticiper :</p> <pre><code>let f ((x,(y,z)),t) = x*t-z*y;;\n val f : (int * (int * int)) * int -&gt; int = &lt;fun&gt;\nf ((1,(2,3)) ,4);;\n- : int = -2\nf (1,2,3,4);; (* erreur de type*)\nCharacters 2-11:\n f (1,2,3,4);;\n   ^^^^^^^^^\nError: This expression has type 'a * 'b * 'c * 'd\n       but an expression was expected of type\n       (int * (int * int)) * int\n</code></pre>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#emuler-des-boucles","title":"Emuler des boucles","text":"<p>Pour le moment on ne pr\u00e9sente pas les traits imp\u00e9ratifs de OCaml. Comment \u00e9muler une boucle comme celle-ci : <pre><code>int x = ...;\nwhile (x &lt; 45){\nx = x+3\n}\n</code></pre></p> <p>On peut le faire facilement avec une fonction comme celle-ci :</p> <pre><code>let rec loop x =\n    if x &lt; 45 then loop (x+3) else x;;\n</code></pre>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#filtrage-sur-les-listes","title":"Filtrage sur les listes","text":"<p>Warning</p> <p>Les pr\u00e9sents transparents ne sont qu'une introduction \u00e0 OCaml. On ne pr\u00e9sente ci-dessous que le cas particulier du filtrage sur les listes.</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#listes","title":"Listes","text":"<p>Les listes d'objets de type \\(\u03c4\\) sont d\u00e9finies inductivement par</p> <ul> <li>la liste vide <code>[]</code> est une liste d'objets de n'importe quel type donc en particulier de type \\(\u03c4\\);</li> <li>Si \\(e\\) est de type \\(\u03c4\\) et si <code>t</code> est une liste de type \\(\u03c4\\), alors <code>e::t</code> est une liste d'objets de type \\(\u03c4\\).</li> </ul> <p>On peut donc explorer une liste en la d\u00e9construisant : on s\u00e9pare son \u00e9l\u00e9ment de t\u00eate du reste de la liste ; on traite l'\u00e9l\u00e9ment de t\u00eate et on applique le m\u00eame traitement au reste de la liste.</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#consequence-de-la-definition-inductive","title":"Cons\u00e9quence de la d\u00e9finition inductive","text":"<p>On a vu comment sont construites inductivement les listes. Il devient possible de les explorer.</p> <pre><code>let rec longueur t = if t = [] then 0\nelse let l = List.tl t in 1 + longueur l;;\n val longueur : \u2019a list -&gt; int = &lt;fun &gt;\nlongueur [3;6;8];;\n- : int = 3\n</code></pre> <p>Rappel : <code>List.tl t</code> donne la queue de liste (tout sauf le premier \u00e9l\u00e9ment)</p> <p>On pourrait aussi \u00e9crire, de fa\u00e7on plus proche de la d\u00e9finition inductive :</p> <pre><code>let rec longueur t = if t = [] then 0\n    else let _::l = t in 1 + longueur l;;\n</code></pre> <p>Mais on recevrait un Warning pour risque de filtrage non exhaustif dans <code>let _::l = t</code></p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#instruction-de-filtrage-match-with","title":"Instruction de filtrage match with","text":"<p>L'exemple simpliste du calcul de la longueur pourrait faire penser qu'on peut r\u00e9soudre \u00e9l\u00e9gamment tous les probl\u00e8mes sur les listes avec les op\u00e9rateurs <code>if then else</code>.</p> <p>Mais on risque vite d'avoir une cascade inesth\u00e9tique de <code>if then else</code>.</p> <p>Pour \u00e9viter cela, l'instruction match with r\u00e9alise un filtrage de motif. Elle permet soit de g\u00e9rer diff\u00e9rents cas en fonction des valeurs d'une expression, soit d'acc\u00e9der aux \u00e9l\u00e9ments d'un type construit (ou les deux \u00e0 la fois).</p> <p>Plus lisible que <code>if then else</code> en cascades <code>match with</code> effectue en outre une analyse d'exhaustivit\u00e9. Il v\u00e9rifie que tous les cas possibles ont bien \u00e9t\u00e9 couverts ce qui est tr\u00e8s utile pour le d\u00e9bugage.</p> <p>Calcul de longueur avec filtrage</p> <pre><code>let rec longueur l = match l with\n| [] -&gt; 0\n| _::t -&gt; 1+ longueur t;;\n  val longueur : 'a list -&gt; int = &lt;fun&gt;\nlongueur [3;6;8];;\n- : int = 3\n</code></pre> <p>Observer le <code>_::t</code> qui permet de ne pas tenir compte de la valeur de l'\u00e9l\u00e9ment de t\u00eate, seulement de son existence.</p>"},{"location":"Ocaml/1-Prise%20en%20main%20en%20OCaml/#filtrage-sur-des-tuples","title":"Filtrage sur des tuples","text":"<p>Le filtrage de motif permet soit de g\u00e9rer diff\u00e9rents cas en fonction des valeurs d'une expression, soit d'acc\u00e9der aux \u00e9l\u00e9ments d'un type construit (ou les deux \u00e0 la fois). La fonction suivante filtre ses arguments (une paire) pour faire leur addition en tenant compte du cas o\u00f9 l'un d'entre eux est z\u00e9ro : <pre><code>let rec somme a b =\n    match a,b with\n    | 0,n -&gt; n\n    | n,0 -&gt; n\n    | _,_ (* autres cas*) -&gt; 1 +\n                                if a &gt; b\n                                then somme a (b-1)\n                                else somme (a-1) b;;\n val somme : int -&gt; int -&gt; int = &lt;fun&gt;\nsomme 2 3;; (*exo : faire tourner \u00e0 la main*)\n- : int = 5\n</code></pre></p>"},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/","title":"R\u00e9cursion terminale et gestion de la m\u00e9moire en OCaml","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <p>Developpez.com</p>"},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/#gestion-de-la-memoire-en-ocaml","title":"Gestion de la m\u00e9moire en OCaml","text":""},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/#un-exemple","title":"Un exemple","text":"<p>Exemple</p> <p>Consid\u00e9rons le programme suivant. Il calcule la somme des entiers de \\(0\\) \u00e0 \\(1 000 000\\) : <pre><code>let rec somme n =\n    if n=0 then 0 else n + somme (n-1)\nlet v = somme 1_000_000\n</code></pre> Compilation, ex\u00e9cution : <pre><code>$ocamlopt somme.ml -o somme\n$./ somme\nFatal error: exception Stack_overflow\n</code></pre> Il y a d\u00e9bordement de pile : le nombre de stack frame est trop grand.</p>"},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/#analyse","title":"Analyse","text":"<p>On empile puis d\u00e9pile les stack frame</p> <p>Chaque stack frame contient une sauvegarde des registres du processeur; un espace pour stocker la valeur de retour; le param\u00e8tre; l'adresse de retour.</p> <p>Entrons la commande suivante</p> <pre><code>$ulimit -s\n8192\n</code></pre> <p>On obtient donc que la taille de la pile d'appel est de \\(8\\) octets.</p> <p>Avec <code>somme 1 000 000</code> on empile donc \\(1 000 000 + 1\\) stack frame d'au moins \\(4\\) bytes. On comprend que la taille allou\u00e9e \u00e0 la pile soit d\u00e9pass\u00e9e.</p>"},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/#organisation-de-la-memoire-en-ocaml","title":"Organisation de la m\u00e9moire en OCaml","text":"<p>La zone de donn\u00e9es statiques contient les constantes pr\u00e9sentes dans le code source du programme comme les cha\u00eenes de caract\u00e8res.</p> <p>Toutes les valeurs en OCaml sont des pointeurs sur des donn\u00e9es dans le tas. Les var. locales de la pile ne peuvent \u00eatre que d'une des \\(4\\) cat\u00e9gories suivantes :</p> <ul> <li>les entiers <code>int</code> , les caract\u00e8res <code>char</code></li> <li>le type <code>unit</code></li> <li>les constructeurs sans arguments dans les types sommes (ils sont repr\u00e9sent\u00e9s en interne par des entiers)</li> </ul> <p></p> <p>R\u00e9partition de la m\u00e9moire lors de l'ex\u00e9cution d'un programme</p>"},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/#ramasse-miette","title":"Ramasse miette","text":"<p>En OCaml, la lib\u00e9ration des zones m\u00e9moires est faite automatiquement par un algorithme appel\u00e9 ramasse miette (en anglais Garbage Collector GC).</p> <p>Le GC agit pendant l'ex\u00e9cution du programme. Il d\u00e9termine quelles zones m\u00e9moires dans le tas sont devenues inutiles. Il les lib\u00e8re automatiquement.</p>"},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/#gestion-de-la-memoire-par-los","title":"Gestion de la m\u00e9moire par l'OS","text":"<p>L'OS g\u00e8re l'espace occup\u00e9 par les segments durant l'ex\u00e9cution du programme. C'est lui qui assure l'int\u00e9grit\u00e9 de ces diff\u00e9rents segments et qui emp\u00eache par exemple que la pile \u00e9crive dans le tas.</p> <p>S'il est besoin d'allouer plus de m\u00e9moire pour le tas que ce qui \u00e9tait pr\u00e9vu, c'est le m\u00e9canisme de m\u00e9moire virtuelle du syst\u00e8me qui s'en charge.</p> <p>Il faut donner au programmeur l'impression que la RAM est infinie. Si la RAM vient \u00e0 manquer, l'OS est capable d'utiliser automatiquement d'autres zones de stockage comme le disque dur ou une cl\u00e9 USB (\u00e9videmment, les performances se d\u00e9gradent alors).</p>"},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/#remediation-en-force-brute","title":"Rem\u00e9diation en force brute","text":"<p>On d\u00e9cide d'augmenter la taille de la pile :</p> <pre><code>$ulimit -s unlimited\n$ulimit -s\nunlimited\n</code></pre> <p>Cela permer d'augmenter la taille de la pile \u00e0 la taille maximale du syst\u00e8me d'exploitation. Sous \\(Linux\\), cette taille est illimit\u00e9 (mais l'administrateur peut imposer une limite). Sous \\(MacOs\\), la limite est de \\(65\\) Mo.</p> <p>Il est maintenant possible d'ex\u00e9cuter le programme <code>./somme</code>. Mais l'ex\u00e9cution est lente du fait des empilements/d\u00e9pilements successifs de stack frame.</p>"},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/#recursion-terminale","title":"R\u00e9cursion terminale","text":""},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/#appel-terminal","title":"Appel terminal","text":"<p>La r\u00e9cursivit\u00e9 terminale est une forme particuli\u00e8re de r\u00e9cursivit\u00e9 pouvant \u00eatre optimis\u00e9e afin de ne pas consommer de m\u00e9moire dans la pile.</p> <p>Dans le corps d'une fonction, un appel est terminale s'il est la derni\u00e8re op\u00e9ration effectu\u00e9e par la fonction.</p> <p>Les fonctions suivantes font un appel terminal \u00e0 <code>g</code></p> <pre><code>1 let f1 x = g x\n2 let f2 x = if ... then g x else ...\n3 let f3 x = let y = ... in g y\n4 let f4 x = match x with\n5 | ... -&gt; ...\n6 | ... -&gt; g x\n7 | _ -&gt; ...\n</code></pre> <p>Appels \u00e0 g non terminaux :</p> <pre><code>1 let f5 x = x + g x\n2 let f6 x = let y = g x in y+1\n</code></pre>"},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/#definition","title":"D\u00e9finition","text":"<p>D\u00e9finition Une fonction est dite r\u00e9cursive terminale si tous les appels r\u00e9cursifs dans sa d\u00e9finition sont en position terminale.</p> <p>Int\u00e9r\u00eat Il n'est plus n\u00e9cessaire d'empiler les stack frame lors des appels r\u00e9cursifs. La stack frame de d\u00e9part suffit.</p>"},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/#exemple","title":"Exemple","text":"<p><code>let rec f x = if x = 0 then 10 else f (x-1)</code> Gestion de la pile d'appel :</p> <ul> <li>Pour <code>f 2</code> La case r\u00e9serv\u00e9e pour la valeur retour est vide, l'argument <code>x</code> contient \\(2\\).</li> <li>L'appel <code>f 1</code> peut utiliser la m\u00eame stack frame que <code>f 2</code> car la valeur 2 contenue dans la case <code>x</code> , n'est plus utilis\u00e9e par la suite. On met donc 1 dans <code>x</code> .</li> <li>L'appel <code>f 0</code> utilise encore la m\u00eame stack frame en mettant 0 dans la case <code>x</code>. <p>La valeur de retour (10) est mise dans <code>ret</code></p> car c'est la valeur qui est finalement renvoy\u00e9e par le 1er appel (<code>f 2</code>)</li> </ul> <p></p> <p>Pile de m\u00e9moire lors de l'appel de <code>f 2</code></p>"},{"location":"Ocaml/2-R%C3%A9cursion%20terminal/#fonction-somme-version-en-recursion-terminale","title":"Fonction somme : version en r\u00e9cursion terminale","text":"<p>On utilise une fonction auxiliaire <code>sum</code> \u00e0 deux param\u00e8tres : l'entier ourant <code>x</code> et un accumulateur <code>acc</code>.</p> <p>L'accumulateur grossit au fil des appels r\u00e9cursifs internes et il contient la valeur voulue lorsque <code>x</code> devient nul. On renvoie donc <code>acc</code>.</p> <p>Code : <pre><code>let somme x =\n    let rec sum x acc = (* fonction auxiliaire *)\n        if x = 0 then acc else sum (x-1) acc + x\n    in sum x 0\n\nlet _ = let v = somme 1_000_000 in Printf.printf \"%d\" v\n</code></pre></p> <p>D'une fa\u00e7on g\u00e9n\u00e9rale, une fonction auxiliaire est utile lorsqu'on a besoin de plus de param\u00e8tres que ceux initialement pr\u00e9vus.</p>"},{"location":"Ocaml/3-Entr%C3%A9es-Sorties/","title":"Entr\u00e9es-sorties en OCAML","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Ocaml/3-Entr%C3%A9es-Sorties/#definition","title":"D\u00e9finition","text":"<p>D\u00e9finition</p> <p>Les fonctions d\u2019entr\u00e9es sorties calculent une valeur (parfois de type <code>unit</code>) et modifient l\u2019\u00e9tat des p\u00e9riph\u00e9riques d\u2019entr\u00e9es-sorties : - modification du buffer du clavier, - affichage \u00e0 l\u2019\u00e9cran, - \u00e9criture dans un fichier - ou modification du pointeur de lecture.</p> <p>Deux types pr\u00e9d\u00e9finis <code>in_channel</code> et <code>out_channel</code> d\u00e9crivent les canaux de communication d\u2019entr\u00e9e et de sortie.</p>"},{"location":"Ocaml/3-Entr%C3%A9es-Sorties/#ouverture-en-lecture","title":"Ouverture en lecture","text":"<p>Dans un fichier essai.txt du r\u00e9pertoire courant, \u00e9crivons trois lignes :</p> <pre><code>    un\n    deux\n    trois et quatre\n</code></pre> <p>sans retour chariot apr\u00e8s <code>quatre</code> .</p> <p>La fonction <code>open_in</code> de type <code>string -&gt; in channel</code> permet d\u2019ouvrir un fichier en lecture \u00e0 partir de son chemin d\u2019acc\u00e8s (ou son nom si le fichier \u00e0 ouvrir est dans le r\u00e9pertoire courant).</p> <p>Elle ouvre un canal de communication (un flot) avec le fichier s\u2019il existe et d\u00e9clenche une exception <code>Sys_error</code> sinon (notamment si le fichier n\u2019existe pas).</p> <p>Notre fichier est ouvert avec l\u2019instruction</p> <pre><code>let ic = open_in \"essai.txt\" ;; \n(* cr\u00e9ation d'un canal de com. vers essais.txt *)\n</code></pre> <p>On acc\u00e8de aux lignes du fichier gr\u00e2ce \u00e0 la fonction</p> <pre><code>input_line ;;\n- : in_channel -&gt; string = &lt;fun&gt;\n</code></pre> <p>Ci-dessous, nous lisons et affichons la premi\u00e8re ligne du fichier :</p> <pre><code>let s = input_line ic in Printf.printf \"%s\\n\" s ;;\nun\n- : unit = ()\n</code></pre> <p>Lisons donc les deux autres lignes :</p> <pre><code># let s = input_line ic in Printf . printf \" %s\\n\" s ;;\ndeux\n- : unit = ()\n# let s = input_line ic in Printf . printf \" %s\\n\" s ;;\ntrois et quatre\n- : unit = ()\n</code></pre> <p>Si on essaye de lire une nouvelle ligne, on se doute bien qu\u2019on va au devant d\u2019un probl\u00e8me : une exception <code>End_of_file</code> sera soulev\u00e9e. Ne tentons pas le diable et fermons le canal de communication <code>ic</code>:</p> <pre><code># close_in ic ;;\n- : unit = ()\n</code></pre> <p>Le canal <code>ic</code> est ferm\u00e9. Toute tentative de lire une ligne de essai.txt se solde par une exception <code>Sys_error \"Bad file descriptor\"</code>.</p> <p>En r\u00e9sum\u00e9, pour lire et afficher toutes les lignes d\u2019un fichier et le fermer proprement, il suffit de rentrer dans une boucle infinie qui affiche les lignes une \u00e0 une et de r\u00e9cup\u00e9rer l\u2019exception <code>End of file</code> qui finira par arriver. On ferme alors le canal.</p> <pre><code>let ic = open_in \" test1.txt\" in\nlet rec lire () =\nlet s = input_line ic in Printf . printf \"%s\\n\" s ;\n    lire () ;\nin\ntry\n    lire () ;\nwith End_of_file -&gt; close_in ic ;;\n</code></pre> <p>Apr\u00e8s compilation et ex\u00e9cution, le contenu du fichier test1.txt s\u2019affiche (s\u2019il existe).</p>"},{"location":"Ocaml/3-Entr%C3%A9es-Sorties/#ouverture-en-ecriture","title":"Ouverture en \u00e9criture","text":"<p>Quand on ouvre un canal de communication en \u00e9criture, le fichier correspondant est ouvert s\u2019il existe ou cr\u00e9\u00e9 s\u2019il n\u2019existe pas.</p> <p>La fonction <code>open_out</code> permet d\u2019ouvrir le fichier en mode \u00e9criture \"avec \u00e9crasement\". La fonction <code>close_out</code> referme le canal.</p> <pre><code>let oc = open_out \"sortie.txt\" in close_out oc ;;\n</code></pre> <p>Nous avons juste ouvert puis referm\u00e9 le fichier mais il a bien \u00e9t\u00e9 cr\u00e9\u00e9.</p> <p>L'ex\u00e9cution de <code>ls sort*</code> renvoie dans le terminal:</p> <pre><code>sortie.txt\n</code></pre> <p>La fonction <code>output_string</code> permet d\u2019\u00e9crire une cha\u0131\u0302ne de caract\u00e8re dans le fichier :</p> <pre><code># let oc = open_out \"sortie.txt\" in\noutput_string oc \"un\" ;\noutput_string oc \"deux\" ;\noutput_string oc \"trois\" ;\nclose_out oc ;;\n- : unit = ()\n</code></pre> <p>Attention, aucun saut de ligne n\u2019a \u00e9t\u00e9 ins\u00e9r\u00e9, il ne faut donc pas oublier les <code>\\n</code> si on veut passer \u00e0 la ligne :</p> <p>L'ex\u00e9cution de <code>cat sortie.txt</code> renvoie dans le terminal :</p> <pre><code>undeuxtrois\n</code></pre> <p>Plus proche de ce que nous connaissons est la fonction <code>Printf.fprintf</code> qui reconna\u0131\u0302t les sp\u00e9cifieurs de format :</p> <pre><code>let oc = open_out \"sortie.txt\" in\nPrintf.fprintf oc \"%f\\n\" 3.45;\nPrintf.fprintf oc \"%d\\n\" 26;\nPrintf.fprintf oc \"%s\\n\" \"fini\" ;\nclose_out oc ;;\n</code></pre> <p>L'ex\u00e9cution de <code>cat sortie.txt</code> renvoie alors dans le terminal :</p> <pre><code>3.450000\n26\nfini\n3\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/","title":"Imp\u00e9ratif et types","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> Sommaire <ul> <li>Tableaux, r\u00e9f\u00e9rences, boucles</li> <li>Exceptions</li> <li> <p>Types personnalis\u00e9s</p> <ul> <li>Type enregistrement</li> <li>Type somme</li> </ul> </li> <li> <p>Astuce : le type option </p> </li> </ul> <p>Cr\u00e9dits</p> <p>Develooppez.com \u03bb OCaml Programming FAQ Caml  </p>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#tableaux-references-boucles","title":"Tableaux, r\u00e9f\u00e9rences, boucles","text":""},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#tableaux","title":"Tableaux","text":"<p>D\u00e9claration d\u2019un tableau :  </p> <pre><code>let tab = [|3;6;8|];; (* \u00e0 la main *)\n\nlet tab = Array.make 5 0;; (* un tableau de 5 z\u00e9ros *)\n\n(* Cr\u00e9er une matrice \u00e0 la main *)\nlet mat = let p = Array.make 3 [||] in\n    p.(0)&lt;-[|1;2|]; p.(1) &lt;-[|0;9|]; p.(2)&lt;-[|-1;1|]; p;;\n\n(* utiliser une fonction de biblioth\u00e8que *)\nArray.make_matrix 3 2 0;;\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#acces-aux-elements","title":"Acc\u00e8s aux \u00e9l\u00e9ments","text":"<pre><code># let tab = [|3;6;8|] in\ntab.(0)&lt;-10;\nPrintf.printf \"tab.(%d)=%d\\n\" 0 tab.(0);;\n    tab.(0) =10\n- : unit = ()\n# let mat = Array.make_matrix 3 2 0 in\nmat.(2).(1)&lt;- -4; mat ;;\n- : int array array = [|[|0; 0|]; [|0; 0|]; [|0; -4|]|]\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#parcours-dun-tableau-longueur-boucle-for","title":"Parcours d\u2019un tableau, longueur, boucle for","text":"<pre><code># let tab = [|3;6;8|];;\nval tab : int array = [|3; 6; 8|]\n# let n = Array.length tab in\n  for i = 0 to (n-1) do\n    Printf.printf \" tab.(%d)=%d; \" i tab.(i) ;\n  done ;;\n    tab.(0)=3; tab.(1)=6; tab.(2)=8; - : unit = ()\n\n# let n = Array.length tab in\n  for i = n -1 downto 0 do\n    Printf.printf \"tab.(%d)=%d; \" i tab.(i) ;\n  done ;;\n  tab.(2)=8; tab.(1)=6; tab.(0)=3; - : unit = ()\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#references","title":"R\u00e9f\u00e9rences","text":"<p>Une r\u00e9f\u00e9rence est un pointeur vers un objet. Cela permet de rendre des  variables mutables.</p> <pre><code># let n = ref 0;;\nval n : int ref = {contents = 0}\n# n := !n+3;;\n- : unit = ()\n# Printf.printf \"!n = %d\\n\" !n ;;\n!n = 3\n- : unit = ()\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#egalites","title":"Egalit\u00e9s","text":"<p><code>==</code> : \u00e9galit\u00e9 physique. <pre><code># [1] == [1];;\n- : bool = false \n</code></pre></p> <p>Les deux listes ne sont pas au m\u00eame endroit de la m\u00e9moire.</p> <p><code>=</code> : \u00e9galit\u00e9 syntaxique. <pre><code># [1] = [1];;\n- : bool = true \n</code></pre></p> <p>Les deux listes \"s'\u00e9rivent pareillement\".</p> <p><code>!=</code> : diff\u00e9rence physique. <pre><code># [1] != [1];;\n- : bool = true \n</code></pre></p> <p><code>&lt;&gt;</code> : diff\u00e9rence syntaxique. <pre><code># [1] &lt;&gt; [1];;\n- : bool = false \n</code></pre></p>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#boucle-while","title":"Boucle while","text":"<pre><code># let i = ref 0 and s = ref 0 in\nwhile !i&lt;10 do\n    s := ! s + ! i ;\n    incr i ;\ndone ;\nPrintf.printf \"!s = %d\\n\" !s ;;\n!s = 45\n- : unit = ()\n</code></pre> <p>Noter le <code>incr i</code> qui incr\u00e9mente de 1 la valeur point\u00e9e par i .  Il existe aussi un <code>decr i</code>.</p>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#exceptions","title":"Exceptions","text":""},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#presentation","title":"Pr\u00e9sentation","text":"<ul> <li>En programmation fonctionnelle, les fonctions sont totales,  c\u2019est-\u00e0-dire qu\u2019elles sont applicables \u00e0 tout argument qui appartient \u00e0  leur type de d\u00e9part.  </li> <li>Il faut donc \u00eatre capable de traiter les cas, appel\u00e9s exceptions, o\u00f9 cet argument n\u2019est pas acceptable. Par exemple : une division par z\u00e9ro ou  bien la recherche de la t\u00eate d\u2019une liste vide.  </li> <li>Ceci peut \u00eatre fait par des tests pr\u00e9ventifs plac\u00e9s dans le corps des  fonctions, mais ce m\u00e9canisme est tr\u00e8s lourd, car il implique un travail  important pour le programmeur et il alt\u00e8re la lisibilit\u00e9 d\u2019un  programme en masquant son fonctionnement normal.  </li> <li>C\u2019est pourquoi les langages de programmation modernes comportent  un m\u00e9canisme sp\u00e9cifique pour le traitement des exceptions.  </li> </ul>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#exceptions-predefinies","title":"Exceptions pr\u00e9d\u00e9finies","text":"<p>Les exceptions ont le type <code>exn</code>. On les soul\u00e8ve avec la commande <code>raise</code>.</p> <ul> <li>Une exception qui porte bien son nom :  </li> </ul> <pre><code># Exit ;;\n- : exn = Pervasives.Exit\n# raise Exit ;;\nException : Pervasives.Exit.\n</code></pre> <ul> <li>Une qu\u2019on conna\u00eet bien</li> </ul> <pre><code># failwith \" big pb ! \" ;;\nException : Failure \" big pb ! \".\n</code></pre> <p>Observons que l\u2019invocation de <code>failwith</code> d\u00e9clenche le <code>raise</code>.</p> <ul> <li>Une exception au sens compr\u00e9hensible  </li> </ul> <pre><code># 1/0;;\nException : Division_by_zero.\n</code></pre> <p>C\u2019est l\u2019\u00e9valuateur de OCaml qui d\u00e9clenche cette exception.  </p> <ul> <li>Une autre qui rappelle le C ou encore Python.</li> </ul> <pre><code># let l = [3] in assert (List.mem 2 l);;\nException : Assert_failure(\"//toplevel//\", 1, 15).\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#declarer-une-exception","title":"D\u00e9clarer une exception","text":"<pre><code># exception MyException ;;\nexception MyException\n# MyException ;;\n- : exn = MyException\n# raise MyException ;;\nException : MyException.\n# exception MyException2 of string ;;\nexception MyException2 of string\n# raise (MyException2 \"big pb\") ;;\nException : MyException2 \"big pb\".\n# exception MyException2 of string ;;\nexception MyException2 of string\n# let f = function x -&gt;\n    if x &lt;&gt; 0 then\n        365 / x\n    else\n        raise (MyException2 \" Division par z\u00e9ro \") ;;\n            val f : int -&gt; int = &lt;fun&gt;\n# f 3;;\n- : int = 121\n# f 0;;\nException : MyException2 \" Division par z\u00e9ro \".\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#recuperation-dune-exception","title":"R\u00e9cup\u00e9ration d\u2019une exception","text":"<p>La r\u00e9cup\u00e9ration d\u2019une exception d\u00e9clench\u00e9e lors de l\u2019\u00e9valuation d\u2019une  expression <code>e</code> peut \u00eatre r\u00e9alis\u00e9e en encapsulant cette expression dans une  expression <code>try..with</code>.Voici la syntaxe \u00e0 utiliser :</p> <pre><code>try expr with\n| p1 -&gt; e1 (* si le type d'exception est p1 , renvoyer e1 *)\n|...\n| pn -&gt; en (* si le type d\u2019exception est pn , renvoyer en *)\n</code></pre> <p>Dans l\u2019exemple suivant, on met la t\u00eate de la liste <code>l2</code> dans <code>l1</code> et, si une  exception de type <code>Failure</code> est soulev\u00e9e, on renvoie la liste vide :  </p> <pre><code># let ajouter l1 l2 =\n    try List.hd l2::l1 with Failure _ -&gt; [];;\n    val ajouter : \u2019a list -&gt; \u2019a list -&gt; \u2019a list = &lt;fun&gt;\n# ajouter [2] [3;4];;\n- : int list = [3; 2]\n# ajouter [2] [];;\n- : int list = []\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#types-personnalises","title":"Types personnalis\u00e9s","text":""},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#type-enregistrement","title":"Type enregistrement","text":""},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#presentation_1","title":"Pr\u00e9sentation","text":"<p>L\u2019id\u00e9e est celle des <code>struct</code> de C. On acc\u00e8de aux champs avec la notation  point\u00e9e; on les modifie avec la notation \ufb02\u00e9ch\u00e9e des tableaux.</p> <pre><code># type complex = {x : float ; y : float};;\ntype complex = {x : float ; y : float ;}\n# let i = {x=1.; y=1.};;\nval i : complex = {x = 1.; y = 1.}\n# i.x , i.y ;;\n- : float * float = (1., 1.)\n# i.x=4.;;\n- : bool = false\n# i.x&lt;-4.;;\nCharacters 0-7:\ni.x&lt;-4.;;\n^^^^^^^\nError : The record field x is not mutable\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#champs-mutables","title":"Champs mutables","text":"<p>Il peut \u00eate souhaitable de modifier certains champs. Il faut les d\u00e9clarer comme mutable. Par d\u00e9faut, un champ est persistant.  </p> <pre><code># type complex = {mutable x : float ; y : float};;\ntype complex = {mutable x : float ; y : float ;}\n# let i = {x =1.; y =1.};;\nval i : complex = {x = 1.; y = 1.}\n# i.x , i.y ;;\n- : float * float = (1. , 1.)\n# i.x=4.;;\n- : bool = false\n# i.x&lt;-4.;;\n- : unit = ()\n# i.y&lt;-1.;;\nCharacters 0-7:\n    i.y&lt;-1.;;\n    ^^^^^^^\nError : The record field y is not mutable\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#polymorphisme","title":"Polymorphisme","text":"<p>Dnas l'exemple ci-dessous, on d\u00e9clare une structure \u00e0 deux champs <code>x,y</code> dont les types ne sont pas connus au d\u00e9part. Le premier est dun certain type <code>'a</code> qui sera connu \u00e0 l'initialisation, de m\u00eame le second est d'un type <code>'b</code>.</p> <pre><code># type (\u2019a , \u2019b) fourre_tout = {x : \u2019a ; y : \u2019b};;\ntype (\u2019a , \u2019b) fourre_tout = { x : \u2019a ; y : \u2019b }\n# let z = {x=2; y = \"toto\"};;\nval z : (int, string) fourre_tout = {x = 2; y = \"toto\"}\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#type-somme","title":"Type somme","text":""},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#presentation_2","title":"Pr\u00e9sentation","text":"<ul> <li>Un type somme est form\u00e9 d\u2019une liste de cas possibles pour une valeur  de ce type, chaque cas comporte un nom de cas, le \"constructeur\",  et une (\u00e9ventuelle) valeur associ\u00e9 (l\u2019argument du constructeur).</li> <li>Un cas d\u00e9g\u00e9n\u00e9r\u00e9 consiste \u00e0 d\u00e9finir un type dont les constructeurs  n\u2019ont pas d\u2019argument (constructeurs constants). On parle alors de type \u00e9num\u00e9r\u00e9 (le symbole <code>|</code> se lit \"ou\")  </li> </ul> <pre><code># type couleur = Bleu | Blanc | Rouge ;;\ntype couleur = Bleu | Blanc | Rouge\n# Bleu ;;\n- : couleur = Bleu\n# let fleur c = match c with\n    | Bleu -&gt; \" bleuet \"\n    | Blanc -&gt; \" marguerite \"\n    | Rouge -&gt; \" coquelicot \"\nin fleur Rouge ;;\n- : string = \" coquelicot \"\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#type-somme_1","title":"Type somme","text":"<p>On peut passer des param\u00e8tres aux constructeurs.  </p> <ul> <li>Ci-dessous on d\u00e9finit un type pour les piles d\u2019entiers. Une pile non  vide poss\u00e9de deux \u00e9l\u00e9ments : une \u00e9tiquette enti\u00e8re et une pile (vide  \u00e9ventuellement). On \u00e9crit une fonction qui fait la somme du contenu  de la liste :  </li> </ul> <pre><code># type stack_of_int = Vide | P of int * stack_of_int;;\ntype stack_of_int = Vide | P of int * stack_of_int\n# let rec somme p = match p with\n    | Vide -&gt; 0\n    | P (x , q) -&gt; x + somme q ;;\n        val somme : stack_of_int -&gt; int = &lt;fun&gt;\n</code></pre> <ul> <li>On cr\u00e9e ensuite une pile dont le sommet est \\(3\\), l\u2019\u00e9l\u00e9ment interm\u00e9diaire \\(2\\) et la base \\(1\\). On lui applique la fonction <code>somme</code> :  </li> </ul> <pre><code># let p = P (3 , P (2 , P (1 , Vide))) ;;\nval p : stack_of_int = P (3 , P (2 , P (1 , Vide)))\n# somme p ;;\n- : int = 6\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#type-somme-polymorphe","title":"Type somme polymorphe","text":"<p>Ci-dessous on d\u00e9finit un type pour les piles polymorphes. On \u00e9crit une  fonction qui prend en param\u00e8tre une pile, une addition adapt\u00e9e et une valeur de d\u00e9part.  </p> <pre><code># type \u2019a stack = Vide | P of \u2019a * \u2019a stack;;\ntype \u2019a stack = Vide | P of \u2019a * \u2019a stack\n# let rec somme_polymorphe p add start = match p with\n    | Vide -&gt; start\n    | P (x , q) -&gt; add x (somme_polymorphe q add start) ;;\n        val somme_polymorphe : \u2019a stack -&gt; (\u2019a -&gt; \u2019b -&gt; \u2019b)\n            -&gt; \u2019b -&gt; \u2019b = &lt;fun&gt;\n</code></pre> <p>On cr\u00e9e ensuite une pile de \ufb02ottant. On lui applique la fonction  <code>somme_polymorphe</code> \u00e0 laquelle on passe l\u2019addition des \ufb02ottants <code>(+.)</code> et le point de d\u00e9part <code>0.</code> :  </p> <pre><code># let p = P (0.3 , P (0.2 , P (0.1 , Vide))) ;;\nval p : float stack = P (0.3 , P (0.2 , P (0.1 , Vide)))\n# somme_polymorphe p (+.) 0.;;\n- : float = 0.600000000000000089\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#astuce-le-type-option","title":"Astuce : le type option","text":""},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#utilite-du-type-option","title":"Utilit\u00e9 du type option","text":"<p>Nous voulons \u00e9crire une fonction qui retourne en g\u00e9n\u00e9ral une valeur  mais, parfois, ne retourne rien.  </p> <p>Par exemple, la fonction <code>list_max</code> renvoie le maximum d\u2019une liste si  elle n\u2019est pas vide. Mais on ne sait trop quoi faire avec la liste vide :</p> <pre><code>let rec list_max = function\n    | [] -&gt; ???\n    | h :: t -&gt; max h (list_max t)\n</code></pre> <p>Pour la liste vide, on peut :</p> <ul> <li>renvoyer une <code>min_int</code> ? mais le code ne fonctionnerait qu\u2019avec une  liste d\u2019entiers</li> <li>Soulever une exception ? mais il faudra que l\u2019utilisateur se souvienne  d\u2019encapsuler ses appels dans un <code>try..with</code> </li> <li>Renvoyer <code>NULL</code> ? mais cette notion existe en C pas en OCaml </li> </ul> <p>La meilleure solution est d\u2019employer le type <code>option</code>.</p>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#le-type-option","title":"Le type option","text":"<p>Le type <code>\u2019a option</code> poss\u00e8de deux constructeurs <code>Some</code> et <code>None</code>.</p> <p>Un \u00e9l\u00e9ment du type <code>option</code> peut \u00eatre vu comme une bo\u00eete qui est soit vide, soit contenant un objet d\u2019un certain type.  </p> <pre><code># None ;;\n- : \u2019a option = None\n# Some 45;;\n- : int option = Some 45\n# Some \" toto \" ;;\n- : string option = Some \" toto \"\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#type-option-acces-au-contenu","title":"Type option : Acc\u00e8s au contenu","text":"<p>On acc\u00e8de au contenu de la bo\u00eete par filtrage. Ci-dessous on \u00e9crit une fonction qui extrait un entier d\u2019une option (s\u2019il y en a un dedans) et le convertit en <code>string</code> :  </p> <pre><code># let extract o =\n    match o with\n    | Some i -&gt; string_of_int i\n    | None -&gt; \"\";;\n        val extract : int option -&gt; string = &lt;fun&gt;\n# extract (Some 42) ;;\n- : string = \"42\"\n# extract None ;;\n- : string = \"\"\n</code></pre>"},{"location":"Ocaml/4-Imp%C3%A9ratif%20et%20types/#maximum-dune-liste","title":"Maximum d\u2019une liste","text":"<p>On revient au programme de recherche du maximum. On ne renvoie rien (donc <code>None</code>) dans le cas o\u00f9 la liste est vide.</p> <pre><code># let rec list_max = function\n    | [] -&gt; None\n    | h :: t -&gt; begin\n        match list_max t with\n            | None -&gt; Some h\n            | Some m -&gt; Some (max h m)\n        end ;;\n                val list_max : \u2019a list -&gt; \u2019a option = &lt;fun&gt;\n# list_max [5;1;9;2];;\n- : int option = Some 9\n# list_max [];;\n- : \u2019a option = None\n</code></pre>"},{"location":"Ocaml/5-Arguments%20en%20ligne%20de%20commande/","title":"Arguments en ligne de commande","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"Ocaml/5-Arguments%20en%20ligne%20de%20commande/#les-arguments-en-ligne-de-commande","title":"Les arguments en ligne de commande","text":"<p>Comme en C ou en Python les arguments qui sont pass\u00e9s en ligne de commande d\u2019un programme OCaml sont stock\u00e9s dans un tableau. Il est traditionnel de nommer ce tableau argv.</p> <p>On le trouve dans le module Sys de la biblioth\u00e8que standard. Son nom complet est donc <code>Sys.argv</code>. Le nombre d\u2019arguments (parmi lesquels le nom du programme en position \\(0\\)) est la longueur du tableau.</p> <p>On verra plus tard comment travailler avec les tableaux en OCaml. Retenons simplement qu\u2019on acc\u00e8de \u00e0 la case \\(i\\) du tableau <code>tab</code> par <code>tab[i]</code>.</p> <p>Dans un fichier arg.ml, entrer :</p> <pre><code>let boucle tab =\n    let n = Array.length tab in \n    let rec aux i = match i with\n        | x when x=n -&gt; ()\n        | _ -&gt; Printf.printf \"[%d] %s\\n\" i tab.(i);\n            aux (i+1)\n    in aux 0\n\nboucle Sys.argv\n</code></pre> <p>Ce programme affiche la liste des arguments et leurs positions dans <code>Sys.argv</code>. Compiler, le programme</p> <pre><code>$ ocamlopt \u2212o args args.ml\n</code></pre> <p>Dans un terminal, la commande <code>./args arg1 arg2 arg3</code> produit l\u2019affichage :</p> <pre><code>[0] ./args\n[1] arg1\n[2] arg2\n[3] arg3\n</code></pre>"},{"location":"SQL/1-BDD_intro/","title":"Mod\u00e8le relationnel, bases de donn\u00e9es","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p>"},{"location":"SQL/1-BDD_intro/#introduction","title":"Introduction","text":""},{"location":"SQL/1-BDD_intro/#e-f-codd-wikipedie","title":"E. F. Codd (Wikipedi\u00e9)","text":""},{"location":"SQL/1-BDD_intro/#resume","title":"R\u00e9sum\u00e9","text":"<ul> <li>Le Mod\u00e8le relationnel pour la gestion des Bases De Donn\u00e9es (BDD)  est un mod\u00e8le de BDD bas\u00e9 sur la logique du premier ordre propos\u00e9  et formul\u00e9 pour la \\(1^{\u00e8re}\\) fois par Edgar F. Codd \\((1969)\\).  </li> <li>Dans une BDD relationnelle l'information est organis\u00e9e dans des  tableaux \u00e0 deux dimensions appel\u00e9es relations ou tables.  </li> <li>Une BDD est donc un ensemble de tables. Les lignes sont appel\u00e9es  tuples, nuplets ou encore enregistrements.  </li> <li>Le mod\u00e8le relationnel fournit une m\u00e9thode d\u00e9clarative pour sp\u00e9cifier  donn\u00e9es (l'ensemble \u00e9tudi\u00e9) et requ\u00eates (questions permises sur cet  ensemble).  </li> <li>L'utilisateur d\u00e9crit les informations que contient la BDD et quelles  informations il souhaite conna\u00eetre et laisse le syst\u00e8me de gestion de  BDD (SGBD) g\u00e9rer la description machine de la base et son stokage  ainsi que la mani\u00e8re dont il retrouve l'information.  </li> </ul>"},{"location":"SQL/1-BDD_intro/#le-modele-relationnel","title":"Le mod\u00e8le relationnel","text":""},{"location":"SQL/1-BDD_intro/#quelques-considerations-generales","title":"Quelques consid\u00e9rations g\u00e9n\u00e9rales","text":"<ul> <li>Toutes les donn\u00e9es sont repr\u00e9sent\u00e9es comme des relations \\(\\textit{n\u2212aires}\\),  des sous-ensembles de produits cart\u00e9siens de n ensembles.  </li> <li>Calculs sur les donn\u00e9es : calcul relationnel ou alg\u00e8bre relationnelle.  </li> <li>Le concepteur de BDD relationnelle cr\u00e9e un mod\u00e8le logique coh\u00e9rent  (sans contradiction).  </li> </ul>"},{"location":"SQL/1-BDD_intro/#attributs","title":"Attributs","text":"<p>D\u00e9finition: Attribut</p> <p>On consid\u00e8re donn\u00e9 un ensemble infini \\({\\displaystyle {\\mathcal {A}}}\\), dont les \u00e9l\u00e9ments sont appel\u00e9s des attributs, un ensemble \\(D\\) (ensemble des domaine), et une application \\(\\text{dom}\\) de \\({\\displaystyle {\\mathcal {A}}}\\) dans \\(D\\).</p> <p>Remarque</p> <p>Si \\(A \\in {\\displaystyle {\\mathcal {A}}}\\), l'\u00e9l\u00e9ment \\(\\text{dom}(A)\\) de \\(D\\) est appel\u00e9 domaine de \\(A\\). La domaine de \\(A\\) est lui-m\u00eame un ensemble, par exemple ensemble des entiers, des flottants, des cha\u0131\u0302nes de caract\u00e8res...</p> <p>Exemple</p> <p>Soit le lyc\u00e9e \\(\\texttt{Pierre Dupont}\\) contenant des CPGE. Les classes sont des couples \\(\\texttt{(fili\u00e8re,num\u00e9ro)}\\) comme \\(\\texttt{(MPSI,1)}\\) ; \\(\\texttt{(MPSI,2)}\\) ou \\(\\texttt{(PCSI,1)}\\).</p> <ul> <li>\\(\\textsf{fili\u00e8re}\\) est un attribut dont le domaine est l'ensemble fini de cha\u00eenes de caract\u00e8res \\(\\textsf{ \\{MPSI,PCSI,PC,PSI,MP,BCPST,HK\\} }\\). </li> <li>\\(\\texttt{num\u00e9ro}\\) est un attribut dont le domaine est l'ensemble \\(\\mathbb{N}^\u2217\\) ou mieux : un intervalle \\([\\![0,m]\\!]\\) o\u00f9 \\(m\\) est le nombre maximum de classes de m\u00eame niveau dans le lyc\u00e9e.</li> </ul>"},{"location":"SQL/1-BDD_intro/#schema-relationnel","title":"Sch\u00e9ma relationnel","text":"<p>D\u00e9finition : Sch\u00e9ma relationnel</p> <p>Soit \\({\\displaystyle {\\mathcal {A}}}\\) un ensemble d'attributs et \\(\\text{dom}\\) une application qui associe un domaine \u00e0 chaque attribut. Un Sch\u00e9ma relationnel est un tuple \\(S = (A_1, A_2, ..., A_n) \\in {\\displaystyle {\\mathcal {A}}}^n\\) o\u00f9 les \\(A_i\\) sont distincts deux \u00e0 deux (mais peuvent avoir les m\u00eames domaines).</p> <p>Remarque</p> <ul> <li>G\u00e9n\u00e9ralement, on \u00e9crit le sch\u00e9ma relationnel sous forme de tuples de couples (\\(\\textsf{attribut, domaine}\\)) comme \\(S = ((A_1, \\text{dom}(A_1)), ...  , (A_n , \\text{dom}(A_n)))\\)</li> <li>Le plus souvent, on ajoute au sch\u00e9ma des symboles indiquant les cl\u00e9s primaires et cl\u00e9s \u00e9trang\u00e8res (voir sections d\u00e9di\u00e9es).</li> </ul> <p>Exemple</p> <p>Sch\u00e9ma des classes du lyc\u00e9e :</p> \\[S = \\left( (\\texttt{filiere, \\{MPSI,PCSI,...\\}}), (\\texttt{num\u00e9ro,} \\mathbb{N}^\u2217 )\\right)\\] <p>Notation</p> <ul> <li>On \u00e9crit \\(B \\in S\\) si \\(B \\in {A_1, ... , A_n}\\).</li> <li>Si \\(X = \\{B_1, ... , B_m\\}\\) est un ensemble d'attributs (distincts), on \u00e9crit  \\(X \\subset S\\) si tous les \\(B_i\\) sont dans \\({A_1, ... , A_n}\\).  </li> <li>On s'autorise aussi des notations de la forme :  </li> </ul> \\[(\\texttt{nom,ville}) \\subset (\\texttt{t\u00e9l\u00e9phone,nom,ville,classe})\\]"},{"location":"SQL/1-BDD_intro/#table","title":"Table","text":"<p>D\u00e9finition: Relation ou table associ\u00e9e \u00e0 un sch\u00e9ma relationnel</p> <p>On appelle relation ou table associ\u00e9e \u00e0 un sch\u00e9ma relationnel \\((A_1, A_2, ... , A_n)\\) tout ensemble fini de tuples de \\(\\text{dom}(A_1) \u00d7 \\text{dom}(A_2) \u00d7 . . . \\text{dom}(A_n)\\).</p> <p>Notation</p> <ul> <li>Les relations sont souvent not\u00e9es sous la forme \\(R(S)\\) (pour indiquer que \\(R\\) est associ\u00e9 au sch\u00e9ma \\(S\\)).</li> <li>Explication : dans la colonne \\(i\\) d'une table de sch\u00e9ma \\(S\\), les valeurs sont obligatoirement dans le domaine \\(\\text{dom}(A_i)\\). C'est ce qu'on appelle une contrainte d'int\u00e9grit\u00e9 (ici, on parle d'int\u00e9grit\u00e9 de domaine).</li> </ul> <p>Example</p> <ul> <li>Si la table \\(\\text{classe}\\) est finie on peut la repr\u00e9senter par un tableau : \\(\\text{classe}\\left(\\texttt{fili\u00e8re}, \\texttt{ num\u00e9ro}\\right) =\\)</li> </ul> \\(\\texttt{Fili\u00e8re}\\) \\(\\texttt{Num\u00e9ro}\\) \\(\\text{MPSI}\\) \\(1\\) \\(\\text{PC}\\) \\(3\\) \\(\\text{PCSI}\\) \\(2\\) \\(\\text{PCSI}\\) \\(1\\) <ul> <li>L'ordre des attributs et des tuples n'a pas d'importance. On a aussi : \\(\\text{classe}\\left(\\texttt{fili\u00e8re}, \\texttt{ num\u00e9ro}\\right) =\\)</li> </ul> \\(\\texttt{Num\u00e9ro}\\) \\(\\texttt{Fili\u00e8re}\\) \\(1\\) \\(\\text{MPSI}\\) \\(3\\) \\(\\text{PC}\\) \\(2\\) \\(\\text{PCSI}\\) \\(1\\) \\(\\text{PCSI}\\)"},{"location":"SQL/1-BDD_intro/#representation-des-schemas-relationnels","title":"Repr\u00e9sentation des sch\u00e9mas relationnels","text":"<p>D\u00e9finition</p> \\(\\text{Nom du sch\u00e9ma}\\) \\(\\text{Attribut 1}\\) \\(\\texttt{type 1}\\) \\(\\text{Attribut 2}\\) \\(\\texttt{type 2}\\) <p>Remarque</p> <p>Deux relations distinctes peuvent avoir le m\u00eame sch\u00e9ma.</p> <p>Exemple</p> <p>Le sch\u00e9ma :</p> \\(\\text{\u00e9l\u00e8ve}\\) \\(\\text{Nom}\\) \\(\\texttt{string}\\) \\(\\text{Ann\u00e9e de naissance}\\) \\(\\texttt{int}\\) <p>Poss\u00e8de les instances :</p> \\(\\texttt{Nom}\\) \\(\\texttt{Ann\u00e9e de naissance}\\) \\(\\text{Hoareau}\\) \\(1996\\) \\(\\text{Grondin}\\) \\(1995\\) \\(\\texttt{Nom}\\) \\(\\texttt{Ann\u00e9e de naissance}\\) \\(\\text{Nativel}\\) \\(1998\\) \\(\\text{Horeau}\\) \\(1996\\) \\(\\text{Grondin}\\) \\(1997\\)"},{"location":"SQL/1-BDD_intro/#multi-ensemble","title":"Multi-ensemble","text":"<p>Remarque</p> <p>Un multi-ensemble est une sorte d'ensemble dans lequel un m\u00eame \u00e9l\u00e9ment  peut appara\u00eetre plusieurs fois comme dans \\(\\{1, 2, 3, 2\\}\\). - Notion \u00e0 mi-chemin des ensembles et des listes. - On peut voir les multi-ensembles comme des listes quotient\u00e9es par les  permutations, i.e. des listes commutatives. - Le multi-ensemble \\(\\{1, 2, 2\\}\\) est \u00e9gal \u00e0 \\(\\{2, 1, 2\\}\\). - Les relations du mod\u00e8le relationnel sont en fait des multi-ensembles.  </p>"},{"location":"SQL/1-BDD_intro/#cles-uniques","title":"Cl\u00e9s uniques","text":""},{"location":"SQL/1-BDD_intro/#notation-objet","title":"Notation objet","text":"<p>Notation</p> <p>Soit \\(R(S)\\) une relation, \\(e \\in R(S)\\) un enregistrement et \\(A \\in S\\). On note \\(e.A\\) la composante du tuple \\(e\\) associ\u00e9e \u00e0 l'attribut \\(A\\). Si \\(K \\subset S\\), on note \\(e.K\\) le sous-tuple de \\(e\\) constitu\u00e9 des composantes associ\u00e9es aux \u00e9l\u00e9ments de \\(K\\). Il s'agit de la projection de \\(e\\) sur les attributs de \\(K\\).</p> <p>Exemple</p> <p>\\(\\text{classe}\\left(\\texttt{fili\u00e8re}, \\texttt{ num\u00e9ro}, \\texttt{ salle}\\right) =\\)</p> \\(\\texttt{Fili\u00e8re}\\) \\(\\texttt{Num\u00e9ro}\\) \\(\\texttt{Salle}\\) \\(\\texttt{MPSI}\\) \\(1\\) \\(\\text{B.10}\\) \\(\\texttt{MPSI}\\) \\(2\\) \\(\\text{C.34}\\) \\(\\texttt{PCSI}\\) \\(2\\) \\(\\text{B.1}\\) <p>Si \\(e = (\\texttt{PCSI}, 2, \\text{B.1})\\), alors \\(e.\\texttt{num\u00e9ro} = 2\\) et \\(e.\\texttt{(num\u00e9ro, salle)} = (2,\\text{B.1})\\).  On dit que \\(e.{A}\\) est la projection de \\(e\\) sur l'attribut \\(A\\). \\(e.(A_1, ... , A_n)\\) est la projection de \\(e\\) sur \\(A_1 \u00d7 \u00b7\u00b7\u00b7 \u00d7 A_n\\).  </p>"},{"location":"SQL/1-BDD_intro/#cle-unique","title":"Cl\u00e9 unique","text":"<p>D\u00e9finition : cl\u00e9 unique</p> <p>Soit \\(R(S)\\) une relation de sch\u00e9ma \\(S\\). On dit que \\(K \u2282 S\\) est une cl\u00e9 unique pour \\(R\\) si et seulement si</p> \\[\u2200(t_1, t_2) \\in R^2 , t_1.K = t_2.K \u27fa t_1 = t_2\\] <p>Remarque</p> <ul> <li>La connaissance des attributs dans \\(K\\) suffit \u00e0 distinguer deux \u00e9l\u00e9ments.</li> <li>\\(K\\) est une cl\u00e9 unique si et seulement si la projection sur \\(K\\) est injective.</li> <li>Lorsqu'il y a une cl\u00e9 unique, la table ne contient pas de doublon de lignes.</li> <li>Souvent, on impose que \\(K\\) soit de cardinal minimum. C'est de bon sens : nous nous en tenons \u00e0 cette pratique</li> </ul> <p>Exemple</p> <p>\\(\\text{\u00e9l\u00e8ve}\\left(\\texttt{Nom}, \\texttt{ Pr\u00e9nom}, \\texttt{ Ann\u00e9e de naissance}\\right) =\\)</p> \\(\\texttt{Nom}\\) \\(\\texttt{Pr\u00e9nom}\\) \\(\\texttt{Ann\u00e9e de naissance}\\) \\(\\text{Hoareau}\\) \\(\\text{Patrice}\\) \\(1996\\) \\(\\text{Hoareau}\\) \\(\\text{Patrice}\\) \\(1995\\) \\(\\text{Dupont}\\) \\(\\text{Marie}\\) \\(1997\\) \\(\\text{Grondin}\\) \\(\\text{Patrice}\\) \\(1996\\) <p>\\((\\texttt{Nom},\\texttt{Pr\u00e9nom})\\) n'est pas une cl\u00e9 unique, ni \\((\\texttt{Pr\u00e9nom},\\texttt{Ann\u00e9e})\\) mais \\((\\texttt{Nom},\\texttt{Ann\u00e9e})\\) est une cl\u00e9 unique.  </p> <p>Soit \\(R(S)\\) une relation de sch\u00e9ma \\(S\\).  </p> <ul> <li>Souvent, on cherche \u00e0 limiter la cl\u00e9 unique \u00e0 un seul attribut.  </li> <li>Le terme cl\u00e9 unique est trompeur : il peut y en avoir plusieurs ! Exemple : dans la table \\(\\text{Etudiant}(\\texttt{id},\\texttt{ nom},\\texttt{ pr\u00e9nom},\\texttt{ num. de  s\u00e9cu})\\) il y a deux cl\u00e9s uniques possibles :  <ul> <li>\\(\\texttt{id}\\) (le num\u00e9ro d'\u00e9tudiant).  </li> <li>\\(\\texttt{num. de s\u00e9cu}\\) Les cl\u00e9s sont choisies par le d\u00e9veloppeur au moment de la conception.  </li> </ul> </li> <li>Une cl\u00e9 unique peut porter sur plusieurs attributs : il peut tr\u00e8s bien ne pas y avoir de cl\u00e9 \u00e0 un seul \u00e9l\u00e9ment.  </li> <li>Et d'ailleurs, il est possible qu'il n'y ait pas de cl\u00e9 unique (si la table  poss\u00e8de des doublons de lignes). Mais on d\u00e9courage d'utiliser de telles  tables.  </li> </ul>"},{"location":"SQL/1-BDD_intro/#cle-primaire","title":"Cl\u00e9 primaire","text":"<p>MySQL fait la distinction entre les notions de cl\u00e9 unique et cl\u00e9 primaire.  </p> <p>D\u00e9finition: cl\u00e9 primaire</p> <p>Une cl\u00e9 primaire est une cl\u00e9 unique particuli\u00e8re associ\u00e9e \u00e0 un index.</p> <p>Remarque</p> <ul> <li>On peut voir l'index comme une table des mati\u00e8res facilitant un acc\u00e8s  rapide aux enregistrement d'une table ayant une cl\u00e9 primaire.  </li> <li>En particulier, la complexit\u00e9 des jointures est grandement diminu\u00e9e  par l'usage d'une cl\u00e9 primaire ; les valeurs possibles \u00e9tant tri\u00e9es dans  l'index.</li> <li>Il peut y avoir plusieurs cl\u00e9s unique par table mais une seule cl\u00e9  primaire.</li> <li>Une cl\u00e9 unique peut prendre la valeur <code>NULL</code> (case vide, \u00e9quivalent  Python de <code>None</code>) pas la cl\u00e9 primaire.  </li> </ul>"},{"location":"SQL/1-BDD_intro/#cle-unique-vs-cle-primaire","title":"Cl\u00e9 unique VS cl\u00e9 primaire","text":"<p>Conform\u00e9ment au programme nous ferons d\u00e9sormais la confusion :  nous n'emploirons plus que l'expression \"cl\u00e9 primaire\" sans nous  soucier de la pr\u00e9sence d'un index ou non.</p> <p>Une cons\u00e9quence est que nous avons au plus une cl\u00e9 primaire par  table.  </p> <p>Une autre est que les cases des colonnes d\u00e9finissant la cl\u00e9 primaire ne sont jamais vide (pas de valeur <code>NULL</code>).  </p>"},{"location":"SQL/1-BDD_intro/#details-sur-la-cle-primaire","title":"D\u00e9tails sur la cl\u00e9 primaire","text":"<ul> <li>On indique par un symbole dans le sch\u00e9ma qu'une cl\u00e9 est  unique/primaire.  </li> <li>Nous signalons les cl\u00e9s uniques en les soulignant. Sous  PHPMYADMIN, les cl\u00e9s primaires sont repr\u00e9sent\u00e9es par des cl\u00e9s  jaunes, les cl\u00e9s uniques par une cl\u00e9 grise.</li> </ul> \u00e9l\u00e8ve \\(\\text{Nom}\\) \\(\\texttt{string}\\) \\(\\underline{\\text{Num\u00e9ro SS}}\\) \\(\\texttt{int}\\) <ul> <li>Un mot cl\u00e9 \\(\\texttt{PRIMARY}\\) indique, au moment de la cr\u00e9ation de la table  dans la plupart des SGBD, qu'une cl\u00e9 est primaire.  </li> <li>Si un tuple d\u00e9j\u00e0 d\u00e9fini poss\u00e8de une valeur \\(v\\) pour la cl\u00e9 primaire de la table \\(T\\), alors le SGBD devrait emp\u00eacher l'ajout de tout nouveau tuple  \u00e0 \\(T\\) poss\u00e9dant la valeur \\(v\\) pour la cl\u00e9.  </li> </ul>"},{"location":"SQL/1-BDD_intro/#relation-entre-deux-tables","title":"Relation entre deux tables","text":""},{"location":"SQL/1-BDD_intro/#deux-schemas","title":"Deux sch\u00e9mas","text":"<p>Soit une BDD mod\u00e9lisant une biblioth\u00e8que simplifi\u00e9e avec deux tables dont les sch\u00e9mas sont :  </p> livre \\(\\underline{\\text{titre}}\\) \\(\\texttt{string}\\) \\(\\text{auteur}\\) \\(\\texttt{string}\\) \\(\\text{ann\u00e9e de publication}\\) \\(\\texttt{int}\\) emprunteur \\(\\text{Nom}\\) \\(\\texttt{string}\\) \\(\\text{Livre emprunt\u00e9}\\) \\(\\texttt{string}\\)"},{"location":"SQL/1-BDD_intro/#deux-tables","title":"Deux tables","text":"<p>Une table \\(\\text{biblioth\u00e8que}\\) instanciant \\(\\text{livre}\\) :  </p> \\(\\texttt{titre}\\) \\(\\texttt{auteur}\\) \\(\\texttt{Publication}\\) \\(\\text{Harry Potter}\\) \\(\\text{J.K Rowling}\\) \\(1997\\) \\(\\text{Pens\u00e9es}\\) \\(\\text{Pascal}\\) \\(1670\\) \\(\\text{Marseille coquin}\\) \\(\\text{Anonyme}\\) \\(2016\\) <p>Une table \\(\\text{Clients}\\) instanciant \\(\\text{emprunteur}\\)</p> \\(\\texttt{Nom}\\) \\(\\texttt{Livre emprunt\u00e9}\\) \\(\\text{Hoareau}\\) \\(\\text{Harry Potter}\\) \\(\\text{Grondin}\\) \\(\\text{Pens\u00e9es}\\) \\(\\text{Dupont}\\) \\(\\text{Maths MP}\\) <p>On en conclut que Hoareau a emprunt\u00e9 \"Harry Potter\" et que Grondin est un petit coquin !  </p> <p>Dupont emprunte un ouvrage qui n'existe pas dans la \\(\\text{biblioth\u00e8que}\\),  ce qui concerne davantage l'administrateur de BDD que la vie priv\u00e9e  de Grondin.  </p>"},{"location":"SQL/1-BDD_intro/#cle-etrangere","title":"Cl\u00e9 \u00e9trang\u00e8re","text":"<p>D\u00e9finition</p> <p>Une cl\u00e9 \u00e9trang\u00e8re (repr\u00e9sent\u00e9e dans ce cours par un <code>#</code>) est un attribut qui est la cl\u00e9 primaire d'une autre relation. Elle permet d'\u00e9tablir le lien entre plusieurs relations. Elle met en \u00e9vidence les d\u00e9pendances fonctionnelles entre \\(2\\) tables.</p> <p>Remarque</p> <p>En SQL, on d\u00e9clare une cl\u00e9 \u00e9trang\u00e8re avec les mots cl\u00e9s \\(\\texttt{FOREIGN KEY}\\).</p> <p>On peut repr\u00e9senter les liens entre deux relations dans un diagramme  par une \ufb02\u00e8che depuis l'attribut vers la cl\u00e9 primaire.</p> <p>Si on impose que le domaine de livre \\(\\texttt{emprunt\u00e9}\\) est constitu\u00e9  exactement des livres apparaissant dans la relation \\(\\texttt{biblioth\u00e8que}\\), le sch\u00e9ma de \\(\\texttt{emprunteur}\\) devient</p> <p>Sh\u00e9ma r\u00e9f\u00e9ren\u00e7ant :</p> emprunteur \\(\\text{Nom}\\) \\(\\texttt{string}\\) \\(\\text{Livre emprunt\u00e9 } \\#\\) \\(\\texttt{titre}\\) \\[\u2193\\] <p>Sh\u00e9ma r\u00e9f\u00e9renc\u00e9 :</p> livre \\(\\underline{\\text{titre}}\\) \\(\\texttt{string}\\) \\(\\text{auteur}\\) \\(\\texttt{string}\\) \\(\\text{ann\u00e9e de publication}\\) \\(\\texttt{int}\\) <p>Le tuple \\((\\texttt{Dupont}, \\texttt{Maths MP})\\) ne peut plus \u00eatre un enregistrement de \\(\\texttt{Clients}\\) (vu plus haut) car \\(\\texttt{Maths MP}\\) n'est pas dans la colonne \"titre\" de  \\(\\texttt{Biblioth\u00e8que}\\).  </p> <p>La contrainte de cl\u00e9 \u00e9trang\u00e8re est g\u00e9r\u00e9e par la plupart des SGBD :  \\(\\texttt{Oracle, Microsoft SQL Server, PostgreSQL, SQLite, etc.}\\) </p>"},{"location":"SQL/1-BDD_intro/#modele-client-serveur","title":"Mod\u00e8le client-serveur","text":""},{"location":"SQL/1-BDD_intro/#architecture-client-serveur","title":"Architecture client-serveur","text":""},{"location":"SQL/1-BDD_intro/#mode-de-communication","title":"Mode de communication","text":"<ul> <li>Environnement client-serveur : mode de communication \u00e0 travers un  r\u00e9seau entre plusieurs programmes ou logiciels :</li> <li>le premier, le client, envoie des requ\u00eates ;</li> <li>l'autre ou les autres,les serveurs, attendent les requ\u00eates des clients et y r\u00e9pondent.  </li> </ul> <p>Par extension, le client d\u00e9signe \u00e9galement l'ordinateur sur lequel est ex\u00e9cut\u00e9 le logiciel client, et le serveur, l'ordinateur sur lequel est ex\u00e9cut\u00e9 le logiciel serveur.  </p>"},{"location":"SQL/1-BDD_intro/#vocabulaire","title":"Vocabulaire","text":"<p>Serveurs</p> <p>Souvent des ordinateurs d\u00e9di\u00e9s au logiciel serveur qu'ils  abritent (ex : serveur Web, serveur de bases de donn\u00e9es, d'impression  ...). Ils sont dot\u00e9s de capacit\u00e9s sup\u00e9rieures \u00e0 celles des ordinateurs  personnels en termes de puissance de calcul, d'entr\u00e9es-sorties et de  connexions r\u00e9seau.</p> <p>Clients</p> <p>Souvent des ordinateurs personnels ou des appareils  individuels (t\u00e9l\u00e9phone, tablette), mais pas syst\u00e9matiquement.  </p> <p>Nombre de clients</p> <p>Un serveur peut r\u00e9pondre aux requ\u00eates d'un grand  nombre de clients.  </p> <p>Exemples</p> <p>Grande vari\u00e9t\u00e9 de logiciels serveurs et de logiciels clients en fonction des  besoins \u00e0 servir :</p> <ul> <li>un serveur web publie des pages web demand\u00e9es par des navigateurs  web ;  </li> <li>un serveur de messagerie \u00e9lectronique envoie des mails \u00e0 des clients  de messagerie ;  </li> <li>un serveur de fichiers permet de stocker et consulter des fichiers sur le  r\u00e9seau ;  </li> <li>un serveur de donn\u00e9es \u00e0 communiquer des donn\u00e9es stock\u00e9es dans une  base de donn\u00e9es, etc...  </li> </ul>"},{"location":"SQL/1-BDD_intro/#notion-de-port","title":"Notion de port","text":"<p>La notion de port logiciel permet, sur un ordinateur donn\u00e9, de  distinguer di\ufb00\u00e9rents interlocuteurs. Ces interlocuteurs sont des  programmes informatiques qui, selon les cas, \u00e9coutent ou \u00e9mettent  des informations sur ces ports. Un port est distingu\u00e9 par son num\u00e9ro.  </p> <p>Image : \\(\\texttt{PORT} = \\texttt{PORTE}\\) donnant acc\u00e8s au syst\u00e8me d'exploitation. Pour fonctionner, un programme ouvre des portes pour acc\u00e9der aux  services de l'OS. Quand on ferme le programme, la porte n'a plus  besoin d'\u00eatre ouverte.</p> <p>Lorsqu'un logiciel client veut dialoguer avec un logiciel serveur (le  service), il a besoin de conna\u00eetre le port \u00e9cout\u00e9 par ce dernier. Par  exemple port \\(80\\) pour un serveur web HTTP ; port \\(3306\\) serveur de bases de donn\u00e9es MySQL ; port \\(8888\\) pour jupyter...  </p> <p><code>cat /etc/services</code> pour avoir la liste des services bien connus. Ou  <code>sudo netstat -antup | grep LISTEN</code> pour la liste des ports en \u00e9coute.  </p>"},{"location":"SQL/1-BDD_intro/#caracteristiques-dun-processus-serveur","title":"Caract\u00e9ristiques d'un processus serveur","text":"<p>Attend une connexion entrante sur un ou plusieurs ports r\u00e9seaux.  </p> <p>\u00c0 la connexion d'un client sur le port en \u00e9coute, ouvre un socket local  (interface de comunication) avec le syst\u00e8me d'exploitation;</p> <p>Suite \u00e0 la connexion, le processus serveur communique avec le client  suivant le protocole pr\u00e9vu par la couche \\(\\texttt{application}\\) du mod\u00e8le OSI.  </p>"},{"location":"SQL/1-BDD_intro/#caracteristiques-dun-processus-client","title":"Caract\u00e9ristiques d'un processus client","text":"<p>\u00c9tablit la connexion au serveur gr\u00e2ce \u00e0 son adresse IP et le port, qui  d\u00e9signe un service particulier du serveur. Un socket est cr\u00e9\u00e9 c\u00f4t\u00e9 client.</p> <p>Lorsque la connexion est accept\u00e9e par le serveur, les deux c\u00f4t\u00e9s  communiquent via les sockets comme le pr\u00e9voit la couche \\(\\texttt{application}\\) du mod\u00e8le OSI.</p> <p></p> <p>Figure \u2013 Architecture client-serveur</p> <p>La machine \u00e0 caf\u00e9</p> <p>Dans une caf\u00e9t\u00e9ria, les caf\u00e9s sont d\u00e9livr\u00e9s par un automate.</p> <p>Le client ins\u00e8re des pi\u00e8ces dans l'automate, s\u00e9lectionne sa boisson et  attend que la machine remplisse son gobelet.</p> <p>Le serveur est la machine \u00e0 caf\u00e9. Le couple (client, automate) est une  architecture client-serveur.</p> <p>Le client acc\u00e8de directement \u00e0 la ressource.</p> <ul> <li>Si le serveur est en panne, c'est au client d'en trouver un autre (pb de  maintenance)</li> <li>Si le client est malhonn\u00eate, il peut tenter d'ins\u00e9rer de fausses pi\u00e8ces (il  ne court aucun risque).  </li> </ul>"},{"location":"SQL/1-BDD_intro/#architecture-trois-tiers","title":"Architecture trois-tiers","text":"<p>Une brasserie</p> <p>Dans une brasserie, les gar\u00e7ons de caf\u00e9 ont acc\u00e8s directement au  percolateur.</p> <p>Le client (couche pr\u00e9sentation) s'assied \u00e0 une table, attend que le  gar\u00e7on (couche m\u00e9tier) vienne prendre sa commande.</p> <p>Une fois que le gar\u00e7on a pris la commande, il acc\u00e8de au percolateur  (couche acc\u00e8s aux donn\u00e9es) derri\u00e8re le comptoir, pr\u00e9pare l'expresso et  le ram\u00e8ne au client.</p> <p>Le triplet (client,gar\u00e7on,percolateur) est une architecture trois-tiers  (ou trois couches)  </p> <p>Le client acc\u00e8de n'acc\u00e8de plus directement \u00e0 la ressource. </p> <ul> <li>Si le percolateur est en panne, c'est au gar\u00e7on et pas au client d'en  trouver un autre (maintenance facilit\u00e9e, on peut imaginer un  percolateur d'appoint en attendant la r\u00e9paration du principal)  </li> <li>Si le client est malhonn\u00eate, il lui est plus di\ufb03cile d'acc\u00e9der au  percolateur pour se servir gratuitement (s\u00e9curit\u00e9 renforc\u00e9e).  </li> <li>Bien s\u00fbr, le client pourrait attendre que le gar\u00e7on prenne la  commande d'une autre personne pour acc\u00e9der en cachette au  percolateur. Il su\ufb03rait alors de mettre quelqu'un en permanence  derri\u00e8re le bar (le patron) et ce probl\u00e8me serait r\u00e9solu (mais on  passerait en architecture \\(4\\) couches).  </li> </ul>"},{"location":"SQL/1-BDD_intro/#principe","title":"Principe","text":"<p>D\u00e9finition</p> <p>Le mot tier signifie \u00e9tage ou niveau en anglais. On dit aussi couche.</p> <p>Une application est compos\u00e9e de \\(3\\) couches ind\u00e9pendantes :</p> <ul> <li>couche pr\u00e9sentation,</li> <li>couche traitements (on dit aussi m\u00e9tier ou application)</li> <li>couche d'acc\u00e8s aux donn\u00e9es.</li> </ul> <p>Ces \\(3\\) couches communiqueront entre elles \u00e0 l'aide de fonctions  sp\u00e9cifiques (des API : \\(A\\)pplication \\(P\\)rogramming \\(I\\)nterface ou Interfaces de programmation).  </p>"},{"location":"SQL/1-BDD_intro/#sgbd-et-architecture-trois-tiers","title":"SGBD et architecture trois-tiers","text":"<p>On r\u00e9partit les r\u00f4les entre :</p> <ul> <li>Un serveur contenant la base donn\u00e9es (non accessible par les clients)  </li> <li>Un syst\u00e8me de gestion de base donn\u00e9es : une interface souvent graphique entre les clients et la base.  <ul> <li>Elle transmet la demande (requ\u00eate) du client au serveur de donn\u00e9es.</li> <li>Elle r\u00e9cup\u00e8re la r\u00e9ponse du serveur de donn\u00e9es et la transmet au client.  </li> </ul> </li> <li>\\(\\color{red}\\text{Le point important : le client ne communique}\\) \\(\\color{red}\\underline{\\text{jamais}}\\text{ directement avec  le serveur de donn\u00e9es}\\).  </li> </ul> <p></p> <ul> <li>Seul le SGBD peut acc\u00e9der aux donn\u00e9es et les modifier.  </li> <li>Le client n'a pas besoin de conna\u00eetre le SQL : souvent une interface  graphique avec des cases \u00e0 cliquer lui \u00e9vite de le faire.  </li> <li>Le client n'a pas besoin d'installer de logiciel : un navigateur Web lui suffit.  </li> </ul>"},{"location":"SQL/2-UneTable/","title":"Requ\u00eates sur une table","text":"<p>Cr\u00e9dits</p> <ul> <li>Un cours de Quentin Fortier</li> <li>Le tuto SQL du W3C (indispensable)</li> <li>Un cours en fran\u00e7ais ici</li> </ul>"},{"location":"SQL/2-UneTable/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"SQL/2-UneTable/#langages-de-requetes","title":"Langages de requ\u00eates","text":"<p>On acc\u00e8de \u00e0 des informations d'une base de donn\u00e9e avec un langage de requ\u00eates.</p> <p>On n'utilise ni variable ni boucle contrairement aux langages de programmation habituels.</p> <p>On \u00e9crit (dans un certain langage) \\(\\underline{\\textsf{ce qu'on veut obtenir}}\\) mais pas \\(\\underline{\\textsf{comment l'obtenir}}\\). On laisse le SGBD se d\u00e9brouiller.</p> <p>Somme des capacit\u00e9s de salles</p> <p>D'apr\u00e8s un exemple de Q. Fortier. On cherche le nombre de places dans des salles de cin\u00e9ma climatis\u00e9es \u00e0 Marseille.</p> <ul> <li>En Python <pre><code>somme = 0\nfor salle in liste_des_salles:\n    si climatis\u00e9(salle) and situ\u00e9_\u00e0_Marseille(salle):\n        somme+= capacit\u00e9(salle)\n</code></pre></li> <li>Dans un langage de requ\u00eate : <pre><code>Calculer la somme des capacit\u00e9s des salles\n      de cin\u00e9ma climatis\u00e9es \u00e0 Marseille\n</code></pre></li> </ul>"},{"location":"SQL/2-UneTable/#sql","title":"SQL","text":"<p>Le langage de requ\u00eates le plus utilis\u00e9 est SQL (\\(S\\)tructured \\(Q\\)uery \\(L\\)angage) Plusieurs impl\u00e9mentations (avec des nuances dans la syntaxe)</p> <ul> <li>En \\(MPI\\), nous utilisons \\(\\text{MySQL}\\) open source, gratuit.</li> <li>\\(\\text{Oracle Database}\\) : propri\u00e9taire, payant</li> <li>\\(\\text{PostgreSQL}\\) : open source, gratuit.</li> <li>Pour les cours d'ITC, nous utilisons \\(\\text{SQLite}\\) et le navigateur l\u00e9ger \\(\\text{DB Browser for SQLite}\\).</li> </ul>"},{"location":"SQL/2-UneTable/#syntaxe-sql","title":"Syntaxe SQL","text":"<p>Chaque requ\u00eate est termin\u00e9e par un point virgule \"\\(\\texttt{ ; }\\)\"</p> <p>SQL n'est pas sensible \u00e0 la casse (majuscules/minuscules) mais il est d'usage d'\u00e9crire les mots cl\u00e9s en majuscules et les noms de tables et colonnes en minuscules.</p>"},{"location":"SQL/2-UneTable/#types-sql","title":"Types SQL","text":"<p>Les attributs peuvent \u00eatre de type</p> <ul> <li>\\(\\color{blue}\\texttt{INT}\\) entier</li> <li>\\(\\color{blue}\\texttt{CHAR(k)}\\) cha\u00eene d'au plus \\(k\\) caract\u00e8res</li> <li>\\(\\color{blue}\\texttt{FLOAT}\\) (nombre flottant)</li> <li>\\(\\color{blue}\\texttt{BOOLEAN}\\) : boul\u00e9en (en fait \\(0\\) ou \\(1\\))</li> <li>D'autres types existent comme un type \\(\\color{blue}\\texttt{TIME}\\) mais le programme se limite aux \\(4\\) pr\u00e9c\u00e9dents.</li> <li>Pour les dates, conform\u00e9ment au programme, on utilise des cha\u00eenes de caract\u00e8res au format \\(\\text{AAAA-MM-JJ}\\) : l'ordre lexicographique correspond alors \u00e0 l'ordre chronologique. De m\u00eame, les horaires sont \u00e9crits au format \\(\\text{HH-MM-SS}\\).</li> </ul>"},{"location":"SQL/2-UneTable/#creation","title":"Cr\u00e9ation","text":"<p>La syntaxe de cr\u00e9ation de table n'est pas au programme. On cr\u00e9e une table \\(\\texttt{Utilisateur}\\) avec une cl\u00e9 primaire \\(\\texttt{id}\\) qui est incr\u00e9ment\u00e9e automatiquement \u00e0 chaque nouvel utilisateur :</p> <p>Exemple du cours de \\(\\text{MPI}\\)</p> <pre><code>    CREATE TABLE utilisateur\n( id INT AUTO_INCREMENT ,\n  PRIMARY KEY(id),\n  nom VARCHAR (100) ,\n  prenom VARCHAR (100),\n  date_naissance DATE ,\n  pays VARCHAR (255),\n  code_postal INT (5) );\n</code></pre> <p>\\(\\text{MPI}\\) : Le type \\(\\color{blue}\\texttt{VARCHAR(100)}\\) indique que les cha\u00eenes de caract\u00e8res ont au plus \\(100\\) lettres contrairement \u00e0 \\(\\color{blue}\\texttt{CHAR(100)}\\) dont l'occupation en m\u00e9moire est fig\u00e9e.</p>"},{"location":"SQL/2-UneTable/#insertion","title":"Insertion","text":"<p>Syntaxe hors programme</p> <pre><code>INSERT INTO \u2018utilisateur\u2018\n(\u2018nom\u2018, \u2018prenom\u2018, \u2018date_naissance\u2018, \u2018pays\u2018,\n\u2018ville\u2018, \u2018habite_marseille\u2018)\nVALUES\n('DUPONT ','Pierre ','2002:11:30 ','UK','LONDON ','0'),\n('CAGOLE ','MARIE ','2001:02:23 ','F','ISTRES ','1')\n</code></pre>"},{"location":"SQL/2-UneTable/#interrogation-de-la-table","title":"Interrogation de la table","text":""},{"location":"SQL/2-UneTable/#contexte","title":"Contexte","text":"<p>Une fois la table cr\u00e9\u00e9e et remplie, on pose des questions sur son contenu.</p> <p>Pour faire tourner les exemples, se rendre sur W3C</p>"},{"location":"SQL/2-UneTable/#fonction-identite","title":"Fonction identit\u00e9","text":"<p>Afficher toutes les colonnes de la table client</p> <pre><code>SELECT * FROM Customers;\n</code></pre>"},{"location":"SQL/2-UneTable/#choix-de-colonnes","title":"Choix de colonnes","text":""},{"location":"SQL/2-UneTable/#projection","title":"Projection","text":"<p>On ne conserve que certaines colonnes, par exemple le nom de client et sa ville :</p> <pre><code>SELECT CustomerName , City FROM Customers;\n</code></pre> <p>Il s'agit d'une projection sur une ou plusieurs colonnes.</p>"},{"location":"SQL/2-UneTable/#filtrer-des-lignes","title":"Filtrer des lignes","text":""},{"location":"SQL/2-UneTable/#clause-colorbluetextttwhere-selection","title":"Clause \\(\\color{blue}\\texttt{WHERE}\\) (S\u00e9lection)","text":"<p>On ne conserve que certaines lignes dont les caract\u00e9ristiques sont filtr\u00e9es dans la clause \\(\\color{blue}\\texttt{WHERE}\\). Il s'agit d'une S\u00e9lection.</p> <p>Donner tous les renseignement sur les clients mexicains :</p> <pre><code>1 SELECT * FROM Customers\n2 WHERE Country='Mexico ';\n</code></pre>"},{"location":"SQL/2-UneTable/#filtrer-des-colonnes-et-des-lignes","title":"Filtrer des colonnes et des lignes","text":"<p>On peut enlever des lignes ET des colonnes.</p> <p>Donner toutes les villes ou vivent des clients en Grande-Bretagne :</p> <pre><code>SELECT City FROM Customers\nWHERE Country='UK';\n</code></pre> <p><p></p></p>"},{"location":"SQL/2-UneTable/#enlever-des-doublons","title":"Enlever des doublons","text":""},{"location":"SQL/2-UneTable/#colorbluetextttdistinct","title":"\\(\\color{blue}\\texttt{DISTINCT}\\)","text":"<p>On a vu que le SGBD travaille avec des multi-ensembles. Il n'est donc pas rare que les requ\u00eates de projection renvoient des doublons (contrairement aux projections du cours de maths).</p> <p>Le mot cl\u00e9 \\(\\color{blue}\\texttt{DISTINCT}\\) supprime les doublons.</p> <p>Donner sans doublon les villes des clients anglais.</p> <pre><code>SELECT DISTINCT City FROM Customers\nWHERE Country='UK';\n</code></pre> <p><p></p></p> <p>Figure \u2013 Une seule fois Londres</p>"},{"location":"SQL/2-UneTable/#operateurs-de-comparaison","title":"Op\u00e9rateurs de comparaison","text":"<ul> <li>\\(\\color{blue}\\texttt{=}\\) (et surtout pas \\(\\color{blue}\\texttt{==}\\))</li> <li>\\(\\color{blue}\\texttt{&lt;}\\), \\(\\color{blue}\\texttt{&lt;=}\\)</li> <li>\\(\\color{blue}\\texttt{!=}\\) (ou son \u00e9quivalent \\(\\color{blue}\\texttt{&lt;&gt;}\\))</li> <li>\\(\\color{blue}\\texttt{AND}\\), \\(\\color{blue}\\texttt{OR}\\), \\(\\color{blue}\\texttt{NOT}\\)</li> <li>\\(\\color{blue}\\texttt{LIKE}\\) (voir plus loin)</li> <li>\\(\\color{blue}\\texttt{IS NULL}\\) (pour rep\u00e9rer les cases vides ou non renseign\u00e9es) ; \\(\\color{blue}\\texttt{IS NOT}\\)</li> <li>\\(\\color{blue}\\texttt{NULL}\\) (pour rep\u00e9rer les cases non vides) ;</li> </ul>"},{"location":"SQL/2-UneTable/#calcul-avec-des-colonnes","title":"Calcul avec des colonnes","text":""},{"location":"SQL/2-UneTable/#renommage","title":"Renommage","text":"<p>Mot cl\u00e9 \\(\\color{blue}\\texttt{AS}\\)</p> <p>La somme de la colonne Quantit\u00e9 avec le num\u00e9ro de produit (ce qui ne signifie rien, bien s\u00fbr)</p> <pre><code>SELECT ProductID + Quantity AS Somme_DEBILE\nFROM OrderDetails;\n</code></pre> <p>Le renommage permettra d'utiliser ce r\u00e9sultat dans des requ\u00eates plus complexes.</p> Calcul de carr\u00e9 ou de racine<pre><code>SELECT POW(4, 2), POW(4, 0.5);\n</code></pre> <p>Observons que dans ce cas pr\u00e9cis, on veut juste un r\u00e9sultat num\u00e9rique sans lien avec aucune table. D'o\u00f9 l'absence de \\(\\color{blue}\\texttt{FROM}\\).</p>"},{"location":"SQL/2-UneTable/#comparaison","title":"Comparaison","text":""},{"location":"SQL/2-UneTable/#operateur-colorbluetextttlike","title":"Op\u00e9rateur \\(\\color{blue}\\texttt{LIKE}\\)","text":"<p>\\(\\color{blue}\\texttt{LIKE}\\) est utilis\u00e9 pour chercher un motif particulier dans une colonne dont le domaine est \\(\\color{blue}\\texttt{CHAR}\\). Deux jokers sont utilis\u00e9s en conjonction avec \\(\\color{blue}\\texttt{LIKE}\\)</p> <ul> <li>Le signe de pourcentage \\(\\%\\) repr\u00e9sente z\u00e9ro, un ou plusieurs caract\u00e8res.</li> <li>L'underscore \\(\\_\\) repr\u00e9sente un seul caract\u00e8re.</li> </ul> <pre><code>-- clients dont le nom commence par a\nSELECT * FROM Customers\nWHERE CustomerName LIKE 'a%';\n\n/* clients dont le nom a n pour\n2\u00e8me lettre et se termine par s*/\nSELECT * FROM Customers\nWHERE CustomerName LIKE '_n%s';\n</code></pre>"},{"location":"SQL/2-UneTable/#trier-avec-colorbluetextttorder-by","title":"Trier avec \\(\\color{blue}\\texttt{ORDER BY}\\)","text":"<p>Pour trier le r\u00e9sultat attendu par ordre croissant (par d\u00e9faut -mot cl\u00e9 \\(\\color{blue}\\texttt{ASC}\\)) ou d\u00e9croissant (mot cl\u00e9 \\(\\color{blue}\\texttt{DESC}\\)).</p> <p>Quand plusieurs colonnes sont indiqu\u00e9es, le tri se fait par ordre lexicographique.</p> <pre><code>SELECT column1 , column2 , ...\nFROM table_name\nORDER BY column1 , column2 , ... ASC|DESC;\n</code></pre> <p>Trier les clients par odre d\u00e9croissant de pays et croissant de nom :</p> <pre><code>1 SELECT * FROM Customers\n2 ORDER BY Country DESC , CustomerName ASC;\n</code></pre> <p>Co\u00fbt d'un tri en \\(O (n \\times log(n))\\).</p>"},{"location":"SQL/2-UneTable/#limiter-le-nombre-de-lignes","title":"Limiter le nombre de lignes","text":""},{"location":"SQL/2-UneTable/#colorbluetextttlimit-pour-mysql","title":"\\(\\color{blue}\\texttt{LIMIT}\\) pour MYSQL","text":"<p>Attention, ce code SQL fonctionne avec \\(\\text{MySQL}\\) mais pas \\(\\text{SQL SERVER}\\). Bien indiquer sur la copie qu'on travaille en \\(\\text{MySQL}\\) \\(!!\\) Voir ce qu'en dit le W3SCHOOL</p> <p>Syntaxe en \\(\\text{MYSQL}\\) et \\(\\text{SQLite}\\) (diff\u00e8re de \\(\\text{ORACLE}\\))</p> <pre><code>SELECT column_name(s)\nFROM table_name\nWHERE condition\nLIMIT number;\n</code></pre> <p>Seulement les \\(3\\) premi\u00e8res lignes de la r\u00e9ponse :</p> <pre><code>SELECT * FROM Customers LIMIT 3;\n</code></pre> <p>Affiche les lignes \\(0,1,2\\). Essayer ici.</p>"},{"location":"SQL/2-UneTable/#donner-un-point-de-depart-colorbluetextttoffset","title":"Donner un point de d\u00e9part : \\(\\color{blue}\\texttt{OFFSET}\\)","text":"<p>Seulement \\(3\\) lignes apr\u00e8s la sixi\u00e8me (incluse) :</p> <pre><code>SELECT * FROM Customers LIMIT 3 OFFSET 6;\n</code></pre> <p>Cela affiche les lignes \\(6,7,8\\). Noter la syntaxe : d'abord \\(\\color{blue}\\texttt{LIMIT}\\) ensuite \\(\\color{blue}\\texttt{OFFSET}\\).</p> <p>M\u00eame chose avec une syntaxe abr\u00e9g\u00e9e :</p> <pre><code>SELECT * FROM Customers LIMIT 6, 3\n</code></pre> <p>Noter qu'on met alors le \\(\\color{blue}\\texttt{OFFSET}\\) avant le nombre de lignes. Essayer ici.</p> <p>\\(\\color{blue}\\texttt{LIMIT k OFFSET 0}\\) est \u00e9quivalent \u00e0 \\(\\color{blue}\\texttt{LIMIT k}\\)</p>"},{"location":"SQL/2-UneTable/#cases-vides","title":"Cases vides","text":""},{"location":"SQL/2-UneTable/#le-mot-cle-colorbluetextttnull","title":"Le mot cl\u00e9 \\(\\color{blue}\\texttt{NULL}\\)","text":"<p>\\(\\color{blue}\\texttt{NULL}\\) est un mot cl\u00e9 indiquant une case vide.</p> <p>Deux op\u00e9rateurs y sont associ\u00e9s :</p> <ul> <li>\\(\\color{blue}\\texttt{IS NULL}\\) (pour rep\u00e9rer les cases vides ou non renseign\u00e9es) ;</li> <li>\\(\\color{blue}\\texttt{IS NOT NULL}\\) (pour rep\u00e9rer les cases non vides) ;</li> </ul> <p>Les noms de clients, celui de leur contact et leur adresse pour les clients dont le champ Adress est non vide</p> <pre><code>SELECT CustomerName , ContactName , Address\nFROM Customers\nWHERE Address IS NOT NULL;\n</code></pre>"},{"location":"SQL/2-UneTable/#application-dune-fonction-dagregation","title":"Application d'une fonction d'agr\u00e9gation","text":"<p>Il y en a \\(5\\) \u00e0 conna\u00eetre :</p> Correspondances Alg\u00e8bre relationnelle \\(\\color{blue}\\texttt{SQL}\\) comptage ou cardinal \\(\\color{blue}\\texttt{COUNT}\\) max \\(\\color{blue}\\texttt{MAX}\\) min \\(\\color{blue}\\texttt{MIN}\\) somme \\(\\color{blue}\\texttt{SUM}\\) moyenne \\(\\color{blue}\\texttt{AVG}\\) (pour \"average \") <p>Ces fonctions peuvent \u00eatre utilis\u00e9es pour des informations statistiques sur TOUTE la table ou bien les m\u00eames informations mais sur les \u00e9l\u00e9ments d'une PARTITION de la table (ce qu'on appelle des agr\u00e9gats)</p>"},{"location":"SQL/2-UneTable/#les-fonctions-colorbluetextttmincolorbluetexttt-maxcolorbluetexttt-sum","title":"Les fonctions \\(\\color{blue}\\texttt{MIN}\\),\\(\\color{blue}\\texttt{ MAX}\\),\\(\\color{blue}\\texttt{ SUM}\\)","text":"<p>Syntaxe :</p> <pre><code>SELECT MAX(nom_colonne) FROM table\n</code></pre> <p>Retourne une table d'une seule ligne et une seule colonne dont le nom est \\(\\texttt{MAX(nom}\\_ \\texttt{colonne)}\\)</p> <p>Donner le prix minimum parmi les produits et renommer le r\u00e9sultat</p> <pre><code>SELECT MIN(Price) AS SmallestPrice\nFROM Products;\n</code></pre> <p>Exercice</p> <p>Idem avec prix maximum</p> <p>Donner la somme des prix unitaires de la table produit.</p> <pre><code>SELECT SUM(Price) AS Somme\nFROM Products;\n</code></pre> <p>Donner les produits dont le prix unitaire est maximum (plusieurs r\u00e9ponses possibles) (attendre d'avoir vu les requ\u00eates imbriqu\u00e9es)</p>"},{"location":"SQL/2-UneTable/#moyenne","title":"Moyenne","text":"<p>Le prix unitaire moyen des produits :</p> <pre><code>SELECT AVG(Price) AS Moyenne\nFROM Products\n;\n</code></pre>"},{"location":"SQL/2-UneTable/#compter","title":"Compter","text":"<p>La fonction \\(\\color{blue}\\texttt{COUNT}\\) a un comportement particulier</p> <ul> <li>\\(\\color{blue}\\texttt{COUNT(a)}\\) : Compte le nombre de fois que \\(a\\) est diff\u00e9rent de \\(\\color{blue}\\texttt{NULL}\\).</li> <li>Souvent on compte le nombre total d'enregistrements avec \\(\\color{blue}\\texttt{COUNT(*)}\\).</li> </ul> <p>donner le nombre de clients</p> <pre><code>SELECT COUNT (*) AS Nombre_de_clients\nFROM Customers;\n</code></pre>"},{"location":"SQL/2-UneTable/#le-mot-cle-colorbluetextttin","title":"Le mot cl\u00e9 \\(\\color{blue}\\texttt{IN}\\)","text":""},{"location":"SQL/2-UneTable/#un-raccourci-pour-eviter-de-multiples-conditions-textttor","title":"Un raccourci pour \u00e9viter de multiples conditions \\(\\texttt{OR}\\)","text":"<p>Pas explicitement au programme (mais pas explicitement interdit)</p> <ul> <li>Syntaxe \\(1\\) :</li> </ul> <pre><code>SELECT column_name(s)\nFROM table_name\nWHERE column_name IN (value1 , value2 , ...);\n</code></pre> <ul> <li>Syntaxe \\(2\\) : Dans des requ\u00eates imbriqu\u00e9es (patience)</li> </ul> <pre><code>SELECT column_name(s)\nFROM table_name\nWHERE column_name IN (SELECT STATEMENT );\n</code></pre> <p>Tous les clients allemands, fran\u00e7ais et anglais :</p> <pre><code>SELECT * FROM Customers\nWHERE Country IN ('Germany ', 'France ', 'UK');\n</code></pre> <p>Tous les clients qui sont dans le m\u00eame pays qu'au moins un fournisseur : (patience, on en parlera quand on verra les requ\u00eates imbriqu\u00e9es)</p>"},{"location":"SQL/3-DeuxTables/","title":"Requ\u00eates sur plusieurs tables","text":"<p>Cr\u00e9dits</p> <ul> <li>Un cours de Quentin Fortier</li> <li>Le tuto SQL du W3C (indispensable)</li> <li>Un cours en fran\u00e7ais ici</li> </ul>"},{"location":"SQL/3-DeuxTables/#operateurs-ensemblistes-usuels","title":"Op\u00e9rateurs ensemblistes usuels","text":""},{"location":"SQL/3-DeuxTables/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":"<p>Ces op\u00e9rateurs ensemblistes concernent uniquement des relations ayant le m\u00eame sch\u00e9ma.</p> \\(\\texttt{P1}\\) Nom Id Pr\u00e9nom Hoareau \\(2011\\) Patrice Grondin \\(5256\\) Marie Dupont \\(52\\) Patrice \\(\\texttt{P2}\\) Nom Id Pr\u00e9nom Dupont \\(52\\) Patrice Grondin \\(5256\\) Pierre <p>Il existe la notion de sch\u00e9mas compatibles quand deux relations ont le m\u00eame nombre d'attributs et que les attributs ont le m\u00eame domaine.</p> <p>PB : deux attributs de m\u00eame domaine pouvant avoir des s\u00e9mantiques diff\u00e9rentes. Ex : \\(\\texttt{Age }\\)et\\(\\texttt{ Nombre de carottes}\\).</p>"},{"location":"SQL/3-DeuxTables/#union","title":"Union","text":"<p>Union</p> <p>L'union de deux relations \\(R_1(S )\\) et \\(R_2(S )\\) est l'ensemble des \\(n\\text{-uplets}\\) appartenant \u00e0 \\(R_1(S )\\) ou \\(R_2(S )\\). On la note \\(R_1 \u222aR_2(S )\\) ou plus simplement \\(R_1 \u222aR_2\\).</p> \\(\\texttt{P1 \u222a P2}\\) Nom Id Pr\u00e9nom Dupont \\(52\\) Patrice Grondin \\(5256\\) Pierre Hoareau \\(2011\\) Patrice Grondin \\(5256\\) Marie"},{"location":"SQL/3-DeuxTables/#intersection","title":"Intersection","text":"<p>Intersection</p> <p>L'intersection de deux relations \\(R_1(S )\\) et \\(R_2(S )\\) est l'ensemble des \\(n\\text{-uplets}\\) appartenant \u00e0 \\(R_1(S )\\) et \\(R_2(S )\\). On la note \\(R_1 \u2229 R_2(S )\\) ou plus simplement \\(R_1 \u2229R_2\\).</p> \\(P1\u2229P2\\) Nom Id Pr\u00e9nom Dupont \\(52\\) Patrice"},{"location":"SQL/3-DeuxTables/#difference","title":"Diff\u00e9rence","text":"<p>Diff\u00e9rence</p> <p>La diff\u00e9rence de deux relations \\(R_1(S )\\) et \\(R_2(S )\\) est l'ensemble des \\(n\\text{-uplets}\\) appartenant \u00e0 \\(R_1(S )\\) mais pas \u00e0 \\(R_2(S )\\). On la note \\(R_1 \u2212R_2(S )\\) ou plus simplement \\(R_1 \u2212R_2\\).</p> \\(\\texttt{P1\u2212P2}\\) Nom Id Pr\u00e9nom Grondin \\(5256\\) Pierre Hoareau \\(2011\\) Patrice <p>Remarque</p> <p>Pour tous ces op\u00e9rateurs binaires, le sch\u00e9ma de la nouvelle table construite est le m\u00eame que celui des deux tables entr\u00e9es.</p>"},{"location":"SQL/3-DeuxTables/#operations-ensemblistes","title":"Op\u00e9rations ensemblistes","text":""},{"location":"SQL/3-DeuxTables/#le-mot-cle-colorbluetextttunion","title":"Le mot cl\u00e9 \\(\\color{blue}\\texttt{UNION}\\)","text":"<p>\\(\\color{blue}\\texttt{UNION}\\), \\(\\color{blue}\\texttt{INTERSECT}\\) et \\(\\color{blue}\\texttt{EXCEPT}\\) sur des tables de m\u00eame sh\u00e9ma.</p> <pre><code>SELECT * FROM R1 UNION SELECT * FROM R2 ;\n</code></pre> <p>\\(\\color{blue}\\texttt{UNION}\\) donne la r\u00e9union sans doublon de lignes, \\(\\color{blue}\\texttt{UNION ALL}\\) donne la r\u00e9union avec potentiellement des doublons de lignes.</p> <p>La liste sans doublon des villes o\u00f9 il y a des clients ou des fournisseurs.</p> <pre><code>SELECT City FROM Customers\nUNION\nSELECT City FROM Suppliers\n</code></pre> <p>\\(\\color{blue}\\texttt{UNION ALL}\\) pour autoriser les doublons (pratique pour voir les effectifs par ville).</p>"},{"location":"SQL/3-DeuxTables/#intersection_1","title":"Intersection","text":"<p>Malheureusement, certains SGBD ne prennent pas en charge les commande \\(\\texttt{EXCEPT}\\) et \\(\\texttt{INTERSECT}\\) : il faut se d\u00e9brouiller autrement : avec une jointure ou avec le mot cl\u00e9 \\(\\color{blue}\\texttt{IN}\\).</p> <p>Avec jointure (cf plus loin)</p> <p>Avec \\(\\color{blue}\\texttt{IN}\\) on r\u00e9cup\u00e8re les villes de clients qui sont aussi des villes d'op\u00e9rateurs :</p> <pre><code>SELECT DISTINCT City FROM Customers\nWHERE City IN(\nSELECT City FROM Suppliers\nORDER BY City);\n</code></pre> <p>Noter le \\(\\color{blue}\\texttt{DISTINCT}\\) pour \u00e9viter les doublons</p> <p>Remarque</p> <p>En \\(\\text{SQLite}\\), la commande \\(\\color{blue}\\texttt{INTERSECT}\\) est bien reconnue.</p>"},{"location":"SQL/3-DeuxTables/#soustraction-ensembliste","title":"Soustraction ensembliste","text":"<p>La commande \\(\\color{blue}\\texttt{EXCEPT}\\) (parfois \\(\\color{blue}\\texttt{MINUS}\\)) existante sur d'autres SGBD n'est pas implant\u00e9e en \\(MySQL\\).</p> <p>Mais on peut s'en passer. Donner sans doublon les villes de clients qui ne sont pas des villes de fournisseurs :</p> <pre><code>SELECT DISTINCT CITY FROM Customers\nWHERE City NOT IN(\nSELECT CITY FROM Suppliers );\n</code></pre> <p>La commande \\(\\color{blue}\\texttt{MINUS}\\) est bien implant\u00e9e en \\(\\text{SQLite}\\).</p>"},{"location":"SQL/3-DeuxTables/#produits-cartesien-jointure","title":"Produits cart\u00e9sien, jointure","text":""},{"location":"SQL/3-DeuxTables/#produit-cartesien","title":"Produit cart\u00e9sien","text":""},{"location":"SQL/3-DeuxTables/#presentation","title":"Pr\u00e9sentation","text":"<p>La concat\u00e9nation des listes \\(S\\) ,\\(S'\\) est not\u00e9e \\(S + S '\\).</p> <p>\\((1,2) + (2,4) = (1,2,2,4)\\). </p> <p>Cet op\u00e9rateur est parfois not\u00e9 de fa\u00e7on plus pr\u00e9cise \\(\\uplus\\).</p> <p>Produit cart\u00e9sien</p> <p>Si \\(R (S )\\) et \\(R '(S ')\\) sont deux relations de sch\u00e9mas \\(\\underline{\\text{disjoints}}\\), on appelle produit cart\u00e9sien et on note \\(R \u00d7R '\\) la relation de sch\u00e9ma \\(S + S '\\) d\u00e9finie par :</p> <p>\\((R \u00d7R ')(S + S ') = {(u_1,...,u_n ,v_1,...v_m ) |(u_1,...,u_n ) \u2208 R(S)\u2227(v_1,...,v_m) \u2208 R'(S')}\\)</p> <p>Remarque</p> <p>\\(\\text{card}(R \u00d7R ') = \\text{card}(R ) \u00d7 \\text{card}(R ')\\) et \\(\\text{card}(S + S ') = \\text{card}(S ) + \\text{card}(S ')\\) (si \\(S\\) ,\\(S'\\) ont des sch\u00e9mas disjoints).</p> \\(\\texttt{El\u00e8ve}\\) Nom Pr\u00e9nom Classe Dupont Jean \\(\\text{MPSI}\\) \\(1\\) Michel Jacques \\(\\text{MPSI}\\) \\(1\\) \\(\\texttt{Prof}\\) Nom Mati\u00e8re Tartempion Maths Duchmol Anglais Schprountz Allemand <p>Pour faire le produit cart\u00e9sien il faut d'abord renommer pour avoir des sch\u00e9mas disjoints :</p> \\(\\texttt{El\u00e8ve}\\) \\(\u00d7\\) \\(\u03c1_{\\text{Nom\u2190Lehrer}} \\texttt{(Prof)}\\) Nom Pr\u00e9nom Classe Lehrer Mati\u00e8re Dupont Jean \\(\\text{MPSI}\\) \\(1\\) Tartempion Maths Michel Jeacques \\(\\text{MPSI}\\) \\(1\\) Duchmol Anglais Dupont Jean \\(\\text{MPSI}\\) \\(1\\) Duchmol Anglais Michel Jeacques \\(\\text{MPSI}\\) \\(1\\) Tartempion Maths Dupont Jean \\(\\text{MPSI}\\) \\(1\\) Schprountz Allemand Michel Jeacques \\(\\text{MPSI}\\) \\(1\\) Schprountz Allemand"},{"location":"SQL/3-DeuxTables/#jointure-croisee","title":"Jointure crois\u00e9e","text":"<p>Il existe un op\u00e9rateur \\(\\color{blue}\\texttt{CROSS JOIN}\\) (pas universellement reconnu) mais la syntaxe suivante est universelle :</p> <pre><code>--produit cart\u00e9sien de deux tables\nSELECT * FROM table1 , table2\n</code></pre> <p>R\u00e9cup\u00e9rer tous les tuples (fournisseur,exp\u00e9diteur) :</p> <pre><code>SELECT * FROM Suppliers , Shippers;\n--87 r\u00e9sultats\n</code></pre> <p>Remarque</p> <p>Le cardinal du produit cart\u00e9sien est le produit des cardinaux :</p> <pre><code>1 SELECT COUNT (*) FROM Suppliers\n2 UNION\n3 SELECT COUNT (*) FROM Shippers\n4 -- donne 3 et 29\n</code></pre> <p>Exercice</p> <p>Y a t'il des produits qui ont \u00e9t\u00e9 achet\u00e9s dans la m\u00eame quantit\u00e9 que d'autres ?</p> Correction <pre><code>SELECT Q2-Q1 &lt;&gt; 0 FROM\n(SELECT COUNT(*) AS Q2 FROM \n(SELECT DISTINCT Quantity FROM OrderDetails) AS T2) AS R2,\n(SELECT COUNT(*) AS Q1 FROM\n(SELECT Quantity FROM OrderDetails) AS T1) AS R1\n</code></pre>"},{"location":"SQL/3-DeuxTables/#complement-de-notations","title":"Compl\u00e9ment de notations","text":"<p>\\(\u03c0_A(R )\\) repr\u00e9sente la projection de la relation \\(R\\) sur les colonnes de l'ensemble d'attributs \\(A\\) (on conserve toutes les lignes, on ne garde que certaine colonnes).</p> <p>\\(\u03c3_T (R )\\) est la s\u00e9lection de \\(R\\) selon le test \\(T\\) (on conserve toutes les colonnes, on ne garde que les lignes qui v\u00e9rifient le test).</p> <p>Exercice</p> <p>On suppose que toutes les personnes (client ou fournisseur) ont renseign\u00e9 l'attribut \\(\\texttt{City}\\) dans la BDD \\(\\texttt{Northwind}\\) du W3C. Calculer la moyenne de personnes (client ou fournisseur) qui vivent dans une m\u00eame ville (client ou fournisseur).</p> Indication <p>Il s'agit de faire la diff\u00e9rence entre le cardinal de la r\u00e9ponse d'un \\(\\color{blue}\\texttt{UNION ALL}\\) avec celui de la r\u00e9ponse d'un \\(\\color{blue}\\texttt{UNION}\\)</p> <p>Penser \u00e0 un produit cart\u00e9sien.</p> Correction <pre><code>SELECT C1/C2 FROM\n(SELECT Count(*) AS C1 FROM\n(SELECT City FROM Customers\nUNION ALL\nSELECT City FROM Suppliers) AS Ville1) AS R1,\n(SELECT Count(*) AS C2 FROM\n(SELECT City FROM Customers UNION\nSELECT City FROM Suppliers) AS Ville2) AS R2\n</code></pre>"},{"location":"SQL/3-DeuxTables/#division-cartesienne","title":"Division cart\u00e9sienne","text":""},{"location":"SQL/3-DeuxTables/#presentation_1","title":"Pr\u00e9sentation","text":"<p>\\(\\color{blue}\\texttt{Notion non explicitement au programme ITC et MPII}\\). (laiss\u00e9e pour info). Soient deux tables \\(R\\) ,\\(S\\) de sch\u00e9ma \\(A\\) et \\(B\\) telles que \\(B \u2282A\\). On pose \\(C = A \u2212B\\) (en notant la soustraction ensembliste comme la diff\u00e9rence des entiers).</p> <p>Division cart\u00e9sienne</p> <p>On appelle division cart\u00e9sienne de \\(R\\) par \\(S\\) , la plus grande table \\(T\\) de sch\u00e9ma \\(C\\) telle que \\(S \u00d7T \u2282R\\) . On note \\(T = R \u00f7S\\)</p> <p>En notant \\(\u03c0_C\\) la projection sur \\(C\\) :</p> <ul> <li>On pose \\(T_1 = \u03c0_C (R )\\). \\(T_1\\) a \\(C\\) pour sch\u00e9ma.</li> <li>Soit \\(T_2 = \u03c0_C ((S \u00d7T_1) \u2212R )\\).</li> <li>Alors \\(T = T_1 \u2212T_2\\)</li> <li>La division cart\u00e9sienne est donc plus petite que la projection sur \\(C\\)</li> <li>La division est utilis\u00e9e pour r\u00e9pondre \u00e0 des requ\u00eates de type : \" quels sont les produits achet\u00e9s par tous les clients ? \"</li> </ul> \\(\\texttt{R'}\\) \\(\\texttt{R}\\) Nom Classe Nom Classe Nom-Prof Dupont \\(\\text{MPSI 1}\\) Dupont \\(\\text{MPSI 1}\\) Tartempion Martin \\(\\text{MPSI 1}\\) Martin \\(\\text{MPSI 1}\\) Tartempion Bernard \\(\\text{PCSI 2}\\) Bernard \\(\\text{PCSI 2}\\) Tartempion Dupont \\(\\text{MPSI 1}\\) Duchmol Bernard \\(\\text{PCSI 2}\\) Duchmol <p>Chercher la division cart\u00e9sienne (not\u00e9e \\(\\texttt{DC}\\)) de \\(R\\) par \\(R'\\).</p> <p>\\(R\u00f7R'\\) a pour sch\u00e9ma le seul attribut qui est dans le sch\u00e9ma de \\(R\\) et pas dans celui de \\(R\\)'.</p> <p>Posons \\(\\texttt{DC}= \\{\\text{Tartempion}, \\text{Duchmol}\\}\\), \\(\\{(\\text{Dupont, MPSI 1}),(\\text{Martin, MPSI 2}),(\\text{Bernard, PCSI 2})\\}\u00d7\\texttt{DC}\\) a \\(6\\) lignes, donc plus que n\u00e9cessaire. Alors \\(\\texttt{DC}\\) est trop gros.</p> <p>Avec \\(\\texttt{DC}= \\{\\text{Duchmol}\\}\\), \\(\\{(\\text{Dupont, MPSI 1}),(\\text{Martin, MPSI 2}),(\\text{Bernard, PCSI 2})\\}\u00d7\\texttt{DC}\\) contient la ligne \\((\\text{Martin, MPSI 1, Duchmol})\\) qui n'est pas dans \\(\\texttt{Eleve-Prof}\\).</p> <p>R\u00e9ponse : \\(\\texttt{DC}\\) vaut</p> \\(\\texttt{DC=R\u00f7R'}\\) \\(\\texttt{R''}\\) Nom-Prof Nom-Eleve Classe Nom-Prof Tartempion Dupont \\(\\text{MPSI 1}\\) Duchmol Bernard \\(\\text{PCSI 2}\\) Duchmol <p>On a \\((R\u00f7R'\u00d7R')\u222aR'' = R\\).</p>"},{"location":"SQL/3-DeuxTables/#un-exemple-plus-elabore","title":"Un exemple plus \u00e9labor\u00e9","text":"<p>Figure \u2013 Une table</p> <p>Question : quels sont les acteurs qui ont tourn\u00e9 dans tous les films de Hitchcock ? (on ne dispose pas du quantificateur universel).</p> <p>Films tourn\u00e9s par Hitchcock :</p> <p>\\(T_H = \u03c0_{Titre,Directeur} (\u03c3_{Directeur ='Hitchcock'} (Film))\\). La table \\(T_H\\) admet (Titre, Directeur ) pour sch\u00e9ma et est constitu\u00e9e de couples (titre, Hitchcock).</p> <p>Tous les acteurs : \\(A = \u03c0_{Acteur} (Film)\\). On cherche \\(A_2\\) : l'ensemble des acteurs qui ont tourn\u00e9 dans tous les films de Hitchcock. C'est le plus grand sous-ensemble de \\(A\\) tel que \\(T_H \u00d7A_2 \u2282Film\\), donc \\(A_2 = Film \u00f7T_H\\) .</p> <p>Remarque</p> <p>Tous les acteurs dans \\(A_2\\) ont tourn\u00e9 dans tous les films de Hitchcock et un acteur qui n'est pas dans \\(A_2\\) a manqu\u00e9 au moins un film de Hitchcock.</p> <p>\\(T_H \u00d7A\\) : toutes les associations (titre, Hitchcock, acteur) possibles de titres de Hitchcock avec un acteur, m\u00eame celles qui n'existent pas.</p> <p>\\((T_H \u00d7A) \u2212Film\\) : seulement les associations (titre, Hitchcock, acteur) qui n'existent pas. Si un nom d'acteur et un film figurent dans une m\u00eame ligne de cette table, cet acteur n'a pas tourn\u00e9 dans ce film d'Hitchcock.</p> <p>\\(A' = \u03c0_{Acteur} ((T_H \u00d7A) \u2212Film)\\) : les acteurs qui n'ont pas tourn\u00e9 dans au moins un film d'Hitchcock.</p> <p>\\(A_2 = A \u2212A'\\) : les acteurs qui ont tourn\u00e9 dans tous les films d'Hitchcok. \\(A_2 = Film \u00f7\u03c0_{Titre,Directeur} (\u03c3_{Directeur ='Hitchcock '}(Film))\\)</p>"},{"location":"SQL/3-DeuxTables/#jointure-symetrique","title":"Jointure sym\u00e9trique","text":""},{"location":"SQL/3-DeuxTables/#recollement-de-deux-relations","title":"Recollement de deux relations","text":"<p>Soient \\(R (S )\\) et \\(R '(S ')\\) deux relations de sch\u00e9mas disjoints et \\(A \u2208S\\) , \\(A' \u2208S '\\) deux attributs de m\u00eame domaine. On appelle jointure sym\u00e9trique de \\(R\\) et \\(R '\\) selon \\((A,A')\\) et on note \\(R\\Join_{[A=A']}R'\\)  les \u00e9l\u00e9ments \\(e\\) de \\(R \u00d7R '\\) tels que \\(e.A = e.A'\\)</p> <p>\\(R\\Join_{[A=A']}R ' := \u03c3_{A=A'}R \u00d7R ' = \\left \\{e \u2208R \u00d7R ' |e.A = e.A' \\right \\}\\)</p> <p>De la m\u00eame fa\u00e7on qu' on peut se passer en logique classique de l'op\u00e9rateur \\(\u21d2\\) (d\u00e9fini avec \\(\u2228\\) et \\(\u00ac\\)), on n'a pas besoin en th\u00e9orie de l'op\u00e9rateur de jointure \\(\\Join_{[*=\u25a1]}\\) car il est d\u00e9fini comme compos\u00e9e d'autres op\u00e9rateurs.</p> <p>Mais se serait une mauvaise id\u00e9e en terme de complexit\u00e9 : co\u00fbt en \\(O (|R |\u00d7|R '|)\\) tests alors qu'il existe des implantations utilisant des index avec un co\u00fbt lin\u00e9aire en nombre de tests.</p> <p>Quel est le sch\u00e9ma de \\(R\\Join_{[A=A']}R '\\) ?</p> <p>La jointure est une s\u00e9lection du produit cart\u00e9sien \\(R \u00d7R '\\) donc : \\(S + S '\\).</p>"},{"location":"SQL/3-DeuxTables/#exemple","title":"Exemple","text":"\\(\\texttt{Livre}\\) \\(\\texttt{Auteur}\\) Titre Nom-auteur Nom Pr\u00e9nom Madame Bovary Flaubert Flaubert Gustave Le p\u00e8re Goriot Balzac (de) Balzac (de) Honor\u00e9 <p>R\u00e9aliser la jointure sym\u00e9trique selon (\\(\\texttt{Nom-auteur},\\texttt{ Nom}\\)).</p> \\(\\texttt{Livre}\\Join_{[\\texttt{Nom-auteur=Nom}]}\\texttt{Auteur}\\) Titre Nom-auteur Nom Pr\u00e9nom Madame Bovary Flaubert Flaubert Gustave Le p\u00e8re Goriot Balzac (de) Balzac (de) Honor\u00e9 <p>Il y a des doublons de valeurs. Comment \u00e9viter cela ?</p> \\(\\pi_{\\texttt{Titre,Nom,Pr\u00e9nom}}(\\texttt{Livre}\\Join_{[\\texttt{Nom-auteur=Nom}]}\\texttt{Auteur})\\) Titre Nom Pr\u00e9nom Madame Bovary Flaubert Gustave Le p\u00e8re Goriot Balzac (de) Honor\u00e9"},{"location":"SQL/3-DeuxTables/#operations-ensemblistes_1","title":"Op\u00e9rations ensemblistes","text":""},{"location":"SQL/3-DeuxTables/#jointure-symetrique_1","title":"Jointure sym\u00e9trique","text":"<p>Pour croiser des informations en provenance de plusieurs tables :</p> <ul> <li>Principe : r\u00e9cup\u00e9rer les lignes de deux tables lorsque ces lignes ont une caract\u00e9ristique commune.</li> <li>En th\u00e9orie, ces tables ont des sh\u00e9mas disjoints.</li> <li>Syntaxe :</li> </ul> <pre><code>SELECT * FROM table1\nINNER JOIN table2\nON table1.colt1 = table2.colt2\n</code></pre> <p>Noms des clients et leurs num\u00e9ros d'achats :</p> <pre><code>SELECT Orders.OrderID , Customers.CustomerName\nFROM Orders\nINNER JOIN Customers\nON Orders.CustomerID = Customers.CustomerID;\n</code></pre> <p>Exercice (improvis\u00e9)</p> <p>Pour chaque achat, donner le prix pay\u00e9.</p> Correction <pre><code>SELECT OrderDetailID, P.Price * OD.Quantity FROM OrderDetails AS OD\nINNER JOIN Products AS P\nON OD.ProductID = P.ProductID\n</code></pre>"},{"location":"SQL/3-DeuxTables/#jointure-et-intersection","title":"Jointure et intersection","text":"<p>On peut se servir d'une jointure pour obtenir l'intersection de deux tables de m\u00eame sch\u00e9ma.</p> <p>Donner les villes o\u00f9 il y a des clients et des fournisseurs :</p> <pre><code>SELECT C.City FROM Customers AS C\nINNER JOIN Suppliers AS S\nON S.City = C.City\n</code></pre>"},{"location":"SQL/3-DeuxTables/#jointures-colorbluetextttleft-join","title":"Jointures \\(\\color{blue}\\texttt{LEFT JOIN}\\)","text":"<p>Hors programme pour l'ITC</p> <ul> <li>La jointure que nous avons vue \\(\\color{blue}\\texttt{R1 JOIN R2 ON A=B}\\) est sym\u00e9trique : les enregistrements de \\(\\texttt{R1}\\) qui ont une valeur de \\(\\texttt{A}\\) qui n'existe pas dans \\(\\texttt{D}\\) n'apparaissent pas dans le r\u00e9sultat.</li> <li>Parfois on a besoin de faire appara\u00eetre, en plus du r\u00e9sultat de la jointure sym\u00e9trique, les valeurs de \\(\\texttt{R1}\\) : c'est la jointure gauche (\\(\\color{blue}\\texttt{LEFT JOIN}\\))</li> </ul> <p>Donner le nom et la ville de chaque client et compl\u00e9ter l'information par le nom des fournisseurs qui vivent dans la m\u00eame ville que lui.</p> <pre><code>SELECT C.CustomerName , C.City , S.SupplierName\nFROM Customers AS C LEFT JOIN Suppliers as S\nON C.City=S.City\n</code></pre> <p>Remarque</p> <p>Certaines des lignes obtenues sont compl\u00e8tes, d'autres pas.</p>"},{"location":"SQL/3-DeuxTables/#jointure-right-join","title":"Jointure RIGHT JOIN","text":"<p>Hors programme pour l'ITC</p> <p>Il existe de m\u00eame une jointure droite de mot cl\u00e9 \\(\\color{blue}\\texttt{RIGHT JOIN}\\)</p> <p>Donner toutes les informations sur les employ\u00e9s et les ventes qu'ils ont \u00e9ventuellement assur\u00e9es.</p> <pre><code>SELECT Orders.OrderID , Employees.LastName ,\nEmployees.FirstName\nFROM Orders\nRIGHT JOIN Employees\nON Orders.EmployeeID = Employees.EmployeeID\nORDER BY Orders.OrderID;\n</code></pre> <p>On constate que le pauvre Adam West n'a effectu\u00e9 aucune vente.</p>"},{"location":"SQL/3-DeuxTables/#auto-jointure","title":"Auto-jointure","text":"<p>Exercice</p> <p>Donner tous les couples de clients qui vivent dans la m\u00eame ville. On n'accepte pas les \" doublons \" comme (Dupont, Durand) et (Durand, Dupont) ni les identifiants identiques comme (Dupont, Dupont) sauf si il s'agit de personnes diff\u00e9rentes (le nom n'est pas une cl\u00e9 primaire).</p> Solution <pre><code>SELECT C1.CustomerName, C2.CustomerName, C1.City FROM \nCustomers AS C1 \nINNER JOIN Customers AS C2 \nON C1.City = C2.City WHERE C1.CustomerID &lt; C2.CustomerID\n</code></pre>"},{"location":"SQL/3-DeuxTables/#jointure-sur-plus-de-deux-tables","title":"Jointure sur plus de deux tables","text":"<p>Pour chaque client, indiquer ses achats et l'entreprise qui a livr\u00e9 ces achats :</p> <pre><code>SELECT Orders.OrderID , Customers.CustomerName ,\n    Shippers.ShipperName\nFROM (( Orders\nINNER JOIN Customers\nON Orders.CustomerID = Customers.CustomerID)\nINNER JOIN Shippers\nON Orders.ShipperID = Shippers.ShipperID );\n</code></pre> <p>Remarque</p> <p>Les SGBD peuvent \u00eatre plus ou moins permissifs sur le parenth\u00e9sage. Mais l'op\u00e9ration de jointure interne est associative.</p>"},{"location":"SQL/4-Agregations/","title":"Agr\u00e9gations","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Un cours de Quentin Fortier</li> <li>Le tuto SQL du W3C (indispensable)</li> <li>Un cours en fran\u00e7ais [ici]https://sql.sh/cours</li> </ul>"},{"location":"SQL/4-Agregations/#objectif","title":"Objectif","text":"<p>Les fonctions d'agr\u00e9gation dans le lagage SQL permettent d'effectuer des op\u00e9rations statistiques sur \\(\\color{red}\\text{un ensemble d'enrengistrment}\\)</p> <p>Contrairement aux autres op\u00e9rateurs, elles s'appliquent \u00e0 des ensembles (ou agr\u00e9gats) de lignes et pas seulement \u00e0 des lignes isol\u00e9es.</p> <p>R\u00e9cup\u00e9rer des informations concernant un groupe de lignes.</p> <p>Exercice donner pour chaque ville </p> <ul> <li>le nombre de commandes pass\u00e9es par les clients habitant cette ville,</li> <li>le prix le plux cher pay\u00e9.</li> <li>la moyenne des \u00e2ges des clients.</li> <li>la somme des totales des commandes des habitants de cette ville.</li> </ul>"},{"location":"SQL/4-Agregations/#compter","title":"Compter","text":"<p>Il s'agit de regrouper les lignes par agr\u00e9gats pr\u00e9sentant une caract\u00e9ristique commune.</p> <pre><code>SELECT column_name(s)\nFROM table_name\nWHERE condition\nGROUP BY column_name(s)\n-- ORDER BY column_name(s); (facultatif : trier)\n</code></pre> <p>Nombre de clients par pays :</p> <pre><code>-- liste des pays et du nombre\n-- de clients qui y vivent */\nSELECT COUNT(CustomerID), Country\nFROM Customers\nGROUP BY Country;\n</code></pre> <p>\\(\\color{blue}\\texttt{COUNT(\u2217)}\\) est \u00e9quivalent \u00e0 \\(\\color{blue}\\texttt{COUNT(CustomerID)}\\) car l'identifiant \u00e9tant une cl\u00e9 primaire, il n'y a pas de \\(\\color{blue}\\texttt{NULL}\\) dans la colonne.</p>"},{"location":"SQL/4-Agregations/#agregation","title":"Agr\u00e9gation","text":"<p>Nombre de clients par pays, rang\u00e9 par ordre d\u00e9croissant d'effectif</p> <pre><code>SELECT COUNT (CustomerID), Country\nFROM Customers\nGROUP BY Country\nORDER BY COUNT(CustomerID) DESC;\n</code></pre>"},{"location":"SQL/4-Agregations/#les-5-fonctions-dagregation","title":"Les \\(5\\) fonctions d'agr\u00e9gation","text":"<ul> <li><code>AVG()</code> pour calculer la moyenne sur un ensemble d'enrengistrement</li> <li><code>COUNT()</code> pour compter le nombre d'enrengistrement sur une table ou une colonne.</li> <li><code>MAX()</code> pour r\u00e9cup\u00e9rer la valeur maximum d'une colonne sur un ensemble de ligne. Cela s'applique \u00e0 la fois pour des donn\u00e9es num\u00e9riques ou alphanum\u00e9rique</li> <li><code>MIN()</code> r\u00e9cup\u00e9rer la valeur minimum de la m\u00eame mani\u00e8re que <code>MAX()</code></li> <li><code>SUM()</code> calculer la somme sur un ensemble d'enrengistrement</li> </ul> <p>Pour chaque cat\u00e9gorie de produits donner l'effectif, le prix moyen, le prix le plus bas, le plus \u00e9lev\u00e9 et la somme des prix :</p> <pre><code>SELECT CategoryID, AVG(Price) AS Moyenne ,\n       Min(Price) AS Inf, Max(Price) AS Sup,\n       Count(\u2217) AS Nb, SUM(Price) AS Somme\nFROM Products\nGROUP BY CategoryID;\n</code></pre> <p>Exercice</p> <p>Quel est le nombre maximum de clients par pays ?</p> Correction <pre><code>SELECT Country, COUNT(*) AS NBC FROM Customers\nGROUP BY Country AS A\n</code></pre>"},{"location":"SQL/4-Agregations/#colorbluetexttthaving","title":"\\(\\color{blue}\\texttt{HAVING}\\)","text":"<p>Fixer des conditions sur les groupes affich\u00e9s (par exemple ceux au dessus d'un certain effectif) et non pas sur les enrengistrements affich\u00e9s (ce qui est le boulot de \\(\\color{blue}\\texttt{WHERE}\\)).</p> <p>\\(\\color{blue}\\texttt{HAVING}\\) permet de filtrer les agr\u00e9gats de lignes en utilisant (uniquement) les fonctions d'aggr\u00e9gation <code>SUM</code>, <code>COUNT</code>, <code>AVG</code>, <code>MIN</code>, <code>MAX</code>.</p> <p>On filtre donc des agr\u00e9gats (d'enregistrements) plut\u00f4t que des enrengistrements.</p> <pre><code>SELECT column_name(s)\nFROM table_name\nWHERE condition sur les lignes\nGROUP BY column_name(s)\nHAVING condition sur les ensembles de lignes\nORDER BY column_name(s);\n</code></pre> <p>Nombres de clients par pays si il y a plus de \\(5\\) clients dans ce pays :</p> <pre><code>SELECT COUNT(CustomerID), Country\nFROM Customers\nGROUP BY Country\nHAVING COUNT(CustomerID) &gt; 5;\n</code></pre> <p>Exercice</p> <ul> <li>Donner le pays dans lequel se trouve le plus de clients.</li> <li>Donner le prix (unitaire) moyen des produits d\u00e9livr\u00e9s par les fournisseurs de chaque ville si le produit le moins cher dans cette ville c\u00f4ute plus de \\(20\\) dollars (prix unitaire).</li> </ul> Correction le pays avec le plus de clients<pre><code>SELECT Country FROM Customers\nGROUP BY Country\nHAVING Count(*) =\n(SELECT MAX(NBC) FROM\n(SELECT Country, COUNT(*) AS NBC FROM Customers\nGROUP BY Country) AS A)\n</code></pre> <pre><code>SELECT City, MIN(Price) FROM Suppliers AS S\nJOIN Products AS P \nON P.SupplierID = S.SupplierID\nGROUP BY S.City\nHAVING MIN(Price) &gt; 20\n</code></pre>"},{"location":"SQL/5-Entit%C3%A9-Relation/","title":"Mod\u00e8le entit\u00e9-association","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Un cours de Quentin Fortier</li> <li>Le tuto SQLdu W3C (indispensable)</li> <li>Un cours en fran\u00e7ais ici</li> <li>Cette page de Wikipedia</li> <li>Un cours de Laurent Audbert</li> </ul>"},{"location":"SQL/5-Entit%C3%A9-Relation/#entites","title":"Entit\u00e9s","text":"<p>Entit\u00e9</p> <p>Une entit\u00e9 est un objet concret ou abstrait \u00e0 propos duquel on souhaite conserver des informations. Exemple : Client, Facture...</p> <p>Une entit\u00e9 peut \u00eatre</p> <ul> <li>un objet physique comme une voiture</li> <li>un \u00e9v\u00e8nement comme une r\u00e9paration de voiture</li> <li>ou un concept comme une transaction commerciale</li> </ul> <p>Une entit\u00e9 poss\u00e8de un ou plusieurs attributs (propri\u00e9t\u00e9 attach\u00e9e \u00e0 une entit\u00e9).</p> <p>Exemple d'entit\u00e9</p> <p>livre, attributs : nombre de page, auteur, date de publication etc.</p>"},{"location":"SQL/5-Entit%C3%A9-Relation/#identifiant-dentite","title":"Identifiant d'entit\u00e9","text":"<p>Identifiant d'entit\u00e9</p> <p>On appele identifiant d'entit\u00e9 un ensemble minimal d'attributs caract\u00e9risant de fa\u00e7on unique chaque occurrence d'un type d'entit\u00e9.</p> <p>entit\u00e9 livre, identifiant d'entit\u00e9 ISBN (l'ISBN est un num\u00e9ro unique attribu\u00e9 \u00e0 un livre - mais pas \u00e0 un exemplaire-).</p> <p>On retrouve une notion proche de la cl\u00e9 primaire. Au moment du passage au mod\u00e8le relationnel, chaque entit\u00e9 est traduite par une table dont la cl\u00e9 primaire se d\u00e9duit de l'identifiant.</p> <p>On souligne ci-apr\u00e8s les identifiants d'entit\u00e9s dans la repr\u00e9sentation graphique.</p>"},{"location":"SQL/5-Entit%C3%A9-Relation/#des-attributs-particuliers","title":"Des attributs particuliers","text":"<p>Consid\u00e9rons une entit\u00e9 \\(\\textsf{Film}\\).</p> <ul> <li>Un film poss\u00e8de un titre. Il y donc un attribut \\(\\color{blue}\\texttt{Titre}\\).</li> <li>Un film peut poss\u00e9der plusieurs genre (horreur et comique par exemple). Il y a donc un attribut \\(\\color{blue}\\texttt{Genre}\\) qui peut prendre plusieurs valeurs pour un m\u00eame film. Un tel attribut est dit attribut multiple. Par exemple, on peut l'\u00e9crire en gras dans le diagramme EA.</li> <li>Un film peut avoir re\u00e7ut un Oscar (et dans ce cas lors d'une unique ann\u00e9e). L'attribut \\(\\color{blue}\\texttt{Oscar}\\) devrait donc d\u00e9signer une ann\u00e9e ou rien (analogie : type option en OCaml). Un tel attribut est dit optionnel. Il pourrait \u00eatre repr\u00e9sent\u00e9 entre paranth\u00e8ses dans le diagramme EA.</li> </ul>"},{"location":"SQL/5-Entit%C3%A9-Relation/#association","title":"Association","text":"<p>Association</p> <p>Une association est une liaison existant entre les entit\u00e9s. Le degr\u00e9 d'une association est le nombre d'entit\u00e9s intervenant dans l'association</p> <p>Commande. Les clients commandent des produits</p> <p><p></p></p> <ul> <li>Ici \\(\\texttt{Commande}\\) est une relation binaire (donc de degr\u00e9 \\(2\\)).</li> <li>Graphiquement : Entit\u00e9s/Rectangles ; Associations/Ellipses.</li> <li>Autre exemple : r\u00e9seau social. Entit\u00e9 : membre ; Association : \"est ami de \".</li> </ul>"},{"location":"SQL/5-Entit%C3%A9-Relation/#relation-ntext-aire","title":"Relation \\(n\\text{-aire}\\)","text":"<p>Un client commande un produit dans un magasin. L'association \\(\\texttt{Commande}\\) est \\(3\\text{-aire}\\).</p> <p>Une relation \\(n\\text{-aire}\\) peut \u00eatre transform\u00e9e en relation binaire en introduisant une nouvelle entit\u00e9 pour la relation. \\(\\texttt{Commande}\\) devient une entit\u00e9. On introduit \\(3\\) relations \\(\\texttt{passe, dans, de}\\).</p> <p></p> <p>Un client \\(\\color{blue}\\texttt{passe}\\) une commande \\(\\color{blue}\\texttt{de}\\) produit \\(\\color{blue}\\texttt{dans}\\) un magasin. Toutes les associations sont devenues binaires.</p>"},{"location":"SQL/5-Entit%C3%A9-Relation/#cardinalite-de-patte","title":"Cardinalit\u00e9 de patte","text":"<p>On peut sp\u00e9cifier le lien entre une entit\u00e9 et une association avec un couple \\((n,p)\\) indiquant le nombre minimum et maximum de fois que l'entit\u00e9 peut appara\u00eetre dans l'association. Certains auteurs pr\u00e9f\u00e8rent \u00e9crire \\(\\texttt{n-p}\\) ou \\(\\texttt{n..p}\\).</p> <p>Un tel couple est appel\u00e9 cardinalit\u00e9 de patte. Il y a deux cardinalit\u00e9s de pattes pour une association binaire, trois pour une ternaire et.</p> <p>Les couples de cardinalit\u00e9s de pattes utilis\u00e9s sont de la forme \\((0,1)\\) ; \\((0,n)\\) ; \\((1,1)\\) (souvent not\u00e9 \\(1\\) plus simplement) et \\((1,n)\\). La notation litt\u00e9rale \\(n\\) signifie \"plusieurs \".</p> <p>Salari\u00e9 \\(\\color{blue}\\texttt{Employ\u00e9Par}\\) Entreprise. Un salari\u00e9 n'a qu'un employeur. Cardinalit\u00e9 \\((1,1)\\) ( not\u00e9e souvent \\(1\\)) pour le lien entre l'entit\u00e9 Salari\u00e9 et l'association \\(\\color{blue}\\texttt{Employ\u00e9Par}\\).</p> <p>Une entreprise peut employer plusieurs salari\u00e9s (un nombre ind\u00e9termin\u00e9) ou aucun. Cardinalit\u00e9 \\((0,n)\\) entre \\(\\texttt{Entreprise}\\) et \\(\\color{blue}\\texttt{Employ\u00e9Par}\\).</p> <p>On peut \u00eatre tr\u00e8s explicite : Avec un SGBD relationnel, nous pourrons contraindre des cardinalit\u00e9s \u00e0 des valeurs comme 2, 3 ou plus en utilisant des d\u00e9clencheurs (trigger).</p> <p>Exemple : En Andorre, un client fran\u00e7ais peut acheter au plus \\(1.5\\) litre d'alcool fort et passer la douane pour rentrer en France sans probl\u00e8me. Il peut donc acheter \\(150\\) \\(\\text{cl}\\) de whisky single malt. La cardinalit\u00e9 est de \\((0,150)\\) entre l'entit\u00e9 \\(\\texttt{Client}\\) et l'association \\(\\color{blue}\\texttt{ach\u00e8te sant probl\u00e8me avec la douane}\\).</p>"},{"location":"SQL/5-Entit%C3%A9-Relation/#cardinalite-dassociation","title":"Cardinalit\u00e9 d'association","text":"<p>Les valeurs prises sont \\(0,1\\), ou plusieurs qui est not\u00e9 selon les cas \\(n\\) ou parfois \\(\u2217\\)</p> <ul> <li>Si une cardinalit\u00e9 maximale est connue et vaut \\(2, 3\\) ou plus, alors nous consid\u00e9rons qu'elle est ind\u00e9termin\u00e9e et vaut \\(n\\). En effet, si nous connaissons \\(n\\) au moment de la conception, il se peut que cette valeur \u00e9volue au cours du temps.</li> <li>La cardinalit\u00e9 max est sup\u00e9rieure \u00e0 la cardinalit\u00e9 min.</li> <li>Consid\u00e9rons une association binaire dont les pattes sont de cardinalit\u00e9s \\((a,b)\\) et \\((c ,d )\\). On appelle cardinalit\u00e9 d'association le couple \\((b,d )\\) (not\u00e9 \\(\\texttt{b - d}\\)) form\u00e9 des cardinalit\u00e9 maximum des deux pattes (voir exemple suivant).</li> </ul> <p>Example</p> <p><p></p></p> <ul> <li>Un fabricant peut fournir \\(0\\) ou plusieurs produits au magasin, un produit n'est fabriqu\u00e9 que par un fabricant.</li> <li>Les valeurs usuelles pour les cardinalit\u00e9s sont \\(0,1\\) et \\(\u2217\\) (plusieurs).</li> <li>Plut\u00f4t que de caract\u00e9riser les liens entre entit\u00e9 et associations, on peut repr\u00e9senter directement les liens entre deux entit\u00e9s : c'est la cardinalit\u00e9 d'association.</li> <li>On les \u00e9crits sous la forme \\(\\texttt{1-1}\\), \\(\\texttt{1-*}\\) (et sym\u00e9triquement \\(\\texttt{*-1}\\)) ou \\(\\texttt{*-*}\\) et on forme ces symboles \u00e0 partir des cardinalit\u00e9s maximales.</li> <li>Par exemple, l'association entre \\(\\texttt{Produit}\\) et \\(\\texttt{Fabriquant}\\) est \\(\\texttt{1-*}\\) car un m\u00eame fabriquant peut fournir plusieurs produits.</li> </ul>"},{"location":"SQL/5-Entit%C3%A9-Relation/#cardinalites-dassociations-entre-entites","title":"Cardinalit\u00e9s d'associations entre entit\u00e9s","text":"<p>Types d'associations binaires entre une entit\u00e9 \\(a\\) et une entit\u00e9 \\(b\\)</p> <ul> <li>\\(\\color{darkblue}\\texttt{1-1}\\) (one-to-one) A chaque \\(a\\) correspond exactement un b et r\u00e9ciproquement. Exemple : l'association dirige est de type \\(\\texttt{1-1}\\) entre les entit\u00e9s \\(\\texttt{Proviseur}\\) et \\(\\texttt{Lyc\u00e9e}\\)</li> <li>\\(\\color{darkblue}\\texttt{1-*}\\) (one-to-many) A chaque \\(a\\) correspondent plusieurs \\(b\\). Exemple : Un \\(\\texttt{compte en banque}\\) poss\u00e8de un unique \\(\\texttt{d\u00e9tenteur}\\), mais chaque \\(\\texttt{d\u00e9tenteur}\\) peut d\u00e9tenir plusieurs comptes.</li> <li>\\(\\color{darkblue}\\texttt{*-*}\\) (many-to-many) \u00e0 chaque \\(a\\) correspondent plusieurs \\(b\\), et \u00e0 chaque \\(b\\) correspondent plusieurs \\(a\\). Exemple : une \\(\\texttt{p\u00e2tisserie}\\) peut proposer plusieurs \\(\\texttt{types de g\u00e2teaux}\\) et un \\(\\texttt{type de g\u00e2teau}\\) peut \u00eatre propos\u00e9 par plusieurs \\(\\texttt{p\u00e2tisseries}\\).</li> </ul> <p>association \\(n\\text{-aire}\\) inappropri\u00e9e</p> <p><p></p></p> <ul> <li>Le type association ternaire \\(\\color{blue}\\texttt{Concerne}\\) associant les types entit\u00e9 \\(\\texttt{Facture}\\), \\(\\texttt{Produit}\\) et \\(\\texttt{Client}\\) repr\u00e9sent\u00e9 ici est inappropri\u00e9 puisqu'une facture donn\u00e9e est toujours adress\u00e9e au m\u00eame client.</li> <li>En effet, cette mod\u00e9lisation implique pour les associations \\(\\color{blue}\\texttt{Concerne}\\) une r\u00e9p\u00e9tition du num\u00e9ro de client pour chaque produit d'une m\u00eame facture.</li> <li>La solution consiste \u00e0 \u00e9clater le type association ternaire \\(\\color{blue}\\texttt{Concerne}\\) en deux type association binaires \\(\\color{blue}\\texttt{Concerne}\\) et \\(\\color{blue}\\texttt{Re\u00e7oit}\\).</li> </ul> <p><p></p></p> <p>(Laurent Audibert)</p>"},{"location":"SQL/5-Entit%C3%A9-Relation/#contraintes","title":"Contraintes","text":"<p>Les contraintes d'int\u00e9grit\u00e9 traduisent des sp\u00e9cifications de la situation \u00e9tudi\u00e9e qui ne peuvent \u00eatre repr\u00e9sent\u00e9es par le mod\u00e8le entit\u00e9-association. Elles ne sont pas bien repr\u00e9sent\u00e9e par nos diagrammes EA sommaires.</p> <p>Les contraintes d'identit\u00e9s statiques doivent \u00eatre satisfaite \u00e0 chaque instant. Par exemple :</p> <ul> <li>\"\u00e2ge du client \\(\u2265 18\\) \"ou \"Noms et pr\u00e9noms sont des attributs obligatoires \"(se traduira en \\(\\color{blue}\\texttt{NULL}\\) interdit)</li> <li>\"Num\u00e9ro de t\u00e9l\u00e9phone \"peut \u00eatre facultatif (se traduira en \\(\\color{blue}\\texttt{NULL}\\) autoris\u00e9)</li> </ul> <p>Les contraintes dynamiques : Exemple \"taille d'un enfant \"ne peut que cro\u00eetre.</p>"},{"location":"SQL/5-Entit%C3%A9-Relation/#methode-de-creation-dun-modele-conceptuel-de-donnees","title":"M\u00e9thode de cr\u00e9ation d'un mod\u00e8le conceptuel de donn\u00e9es","text":"<p>Pour cr\u00e9er un sch\u00e9ma entit\u00e9-association</p> <ul> <li>on identifie les types d'entit\u00e9s</li> <li>on identifie les types d'associations entre entit\u00e9s.</li> <li>on identifie les attributs des entit\u00e9s et associations</li> <li>on \u00e9value les cardinalit\u00e9s des associations</li> <li>on exprime les \u00e9ventuelles contraintes d'int\u00e9grit\u00e9.</li> </ul>"},{"location":"SQL/5-Entit%C3%A9-Relation/#conversion-en-base-de-donneeprocede-simplifie","title":"Conversion en base de donn\u00e9eproc\u00e9d\u00e9 simplifi\u00e9","text":"<p>Pour concevoir une base de donn\u00e9e :</p> <ul> <li>Utiliser une table par entit\u00e9.</li> <li>Pour chaque association entre \\(a\\) et \\(b\\) :<ul> <li>Si association \\(\\texttt{1 - 1}\\) : Fusionner les tables \\(a\\) et \\(b\\).</li> <li>Si association \\(\\texttt{1 - \u2217}\\) : Ajouter un attribut (cl\u00e9 \u00e9trang\u00e8re) dans une table faisant r\u00e9f\u00e9rence \u00e0 l'autre.</li> <li>Si association \\(\\texttt{\u2217 - \u2217}\\) : Ajouter une table ayant \\(2\\) cl\u00e9 \u00e9trang\u00e8re pour faire r\u00e9f\u00e9rence \u00e0 \\(a\\) et \\(b\\). Une telle table est appel\u00e9e table de liaison. Sa cl\u00e9 primaire est souvent l'ensemble de ces attributs.</li> </ul> </li> </ul> <p>(Q. Fortier)</p>"},{"location":"SQL/5-Entit%C3%A9-Relation/#interpretation-de-la-cardinalite","title":"Interpr\u00e9tation de la cardinalit\u00e9","text":"<p>La r\u00e8gle pour placer la cl\u00e9 \u00e9trang\u00e8re pour une association \\(\\texttt{1 - \u2217}\\) doit \u00eatre nuanc\u00e9e selon la fa\u00e7on dont on comprend la cardinalit\u00e9.</p> <p>La c\u00e9r\u00e9monie des Oscars est pr\u00e9sent\u00e9e par une seule personne (par an) mais une personne peut pr\u00e9senter plusieurs fois la c\u00e9r\u00e9monie.</p> <p>Certains auteurs pr\u00e9conisent ceci :</p> <p><p></p></p> <p>Le \\(1\\) (qui signifie \\((1,1)\\)) \u00e0 c\u00f4t\u00e9 de \\(\\texttt{Personne}\\) signifie pour ces auteurs qu'un Oscar n'est pr\u00e9sent\u00e9 (forme passive) que par une personne. Mais qu'une personne peut tr\u00e8s bien pr\u00e9senter plusieurs Oscar (\\((1,n)\\) du c\u00f4t\u00e9 d'\\(\\texttt{Oscar}\\)). On a donc une cardinalit\u00e9 d'association \\(\\texttt{1 - n}\\).</p> <p>Q : Pourquoi \\((1,n)\\) et pas \\((0,n)\\) ?</p> <p>Pour M.Noyer, il place les cardinalit\u00e9s de pattes ainsi :</p> <p><p></p></p> <p>On a donc une cardinalit\u00e9 d'association \\(\\texttt{n - 1}\\). Il est de toute fa\u00e7on clair pour tout le monde qu'il faut mettre une cl\u00e9 \u00e9trang\u00e8re dans \\(\\texttt{Oscar}\\) vers \\(\\texttt{Personne}\\).</p>"},{"location":"SQL/5-Entit%C3%A9-Relation/#ordre-de-creation-des-tables","title":"Ordre de cr\u00e9ation des tables","text":"<p>Les sommets sont les tables et les arcs repr\u00e9sentent les cl\u00e9s \u00e9trang\u00e8res.</p> <p>A priori, le graphe est acyclique. On construit un tri topologique pour en d\u00e9duire dans quel ordre cr\u00e9er les tables. Si \\(b\\) a une cl\u00e9 \u00e9trang\u00e8re r\u00e9f\u00e9ren\u00e7ant un attribut de \\(a\\), il faut cr\u00e9er \\(a\\) avant \\(b\\).</p>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/","title":"Tableaux redimensionnables et Listes cha\u00een\u00e9es","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Openclassroom ici</li> <li>Wikipedia l\u00e0</li> </ul>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#tableaux-redimensionnables","title":"Tableaux redimensionnables","text":""},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#objectif","title":"Objectif","text":"<ul> <li>La taille d'un tableau C ou OCaml doit \u00eatre connue \u00e0 la d\u00e9claration.</li> <li>Il n'est pourtant pas toujours ais\u00e9 de d\u00e9terminer la taille dont on a besoin \u00e0 l'avance.</li> <li>On se donne donc la possibilit\u00e9 de d'augmenter la capacit\u00e9 du tableau si besoin.</li> </ul>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#interface","title":"Interface","text":"<p>Dans un fichier <code>vector.h</code> :</p> <pre><code>// Structure de tableau redimensionnable d'entiers\ntypedef struct Vector vector;\nvector\u2217 vector_make (int capacity); // cr\u00e9er un vecteur vide\nint vector_size(vector\u2217 v); // O(1) esp\u00e9r\u00e9\nint vector_get(vector\u2217 v, int i); // O(1)\nvoid vector_set(vector\u2217 v, int i, int x);\nvoid vector_resize(vector\u2217 v, int s);\nvoid vector_delete (vector\u2217 v);\n</code></pre> <ul> <li>La fonction <code>vector_make</code> est appel\u00e9e un constructeur ; <code>vector_get</code> un accesseur et <code>vector_set</code> un mutateur (ou encore transformateur).</li> <li>On ne pr\u00e9cise pas l'impl\u00e9mentation concr\u00e8te de la structure <code>vector</code> mais les op\u00e9rations qu'on peut effectuer dessus. Cette structure de donn\u00e9es est dite abstraite.</li> </ul>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#implementation-concrete","title":"Impl\u00e9mentation concr\u00e8te","text":"<p>L'impl\u00e9mentation concr\u00e8te de la structure pr\u00e9c\u00e9dente repose (par exemple) sur l'utilisation d'une structure dont un champ interne est un tableau d'entier. Mais ceci est compl\u00e8tement transparent pour l'utilisateur !</p>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#implementaion","title":"Impl\u00e9mentaion","text":"<p>Dans un fichier <code>vector.c</code> \u00e9crivons :</p> <pre><code>typedef struct Vector {\n    int capacity;\n    int\u2217 data ; // tableau de taille 'capacity'\n    int size; // invariant 0 &lt;= 'size' &lt;= 'capacity'\n} vector;\n</code></pre> <ul> <li>En interne : tableau d'entiers de taille <code>capacity</code></li> <li><code>size</code> : nombre d'\u00e9l\u00e9ments du tableau redimensionnable. Dans l'impl\u00e9mentation propos\u00e9e ici, il fixe une borne sup\u00e9rieure du nombre d'\u00e9l\u00e9ments \u00e0 mettre dans le tableau.</li> </ul>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#creation","title":"Cr\u00e9ation","text":"<p>Comme d'habitude on pr\u00e9f\u00e8re renvoyer des pointeurs sur structure :</p> <pre><code>vector\u2217 vector_create (){\n    vector\u2217 v = malloc(sizeof(vector));\n    v\u2212&gt;capacity = 0;\n    v\u2212&gt;data = NULL;\n    v\u2212&gt;size = 0;// il faudra redimensionner avant toute action\nreturn v;\n}\n</code></pre>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#taille-consultation-modification","title":"Taille, consultation, modification","text":"<pre><code>int vector_size(vector\u2217 v){\n    return v\u2212&gt; size;\n}\n\nint vector_get(vector\u2217 v, int i){\n    // renvoyer  le contenu de la case i\n    assert (0 &lt;= i &amp;&amp; i &lt; v\u2212&gt;size);\n    return v\u2212&gt;data[i];\n}\n\n// Fonction outil \u00e0 ne pas utiliser directement\n// A utiliser avec pr\u00e9caution car aucun\n// contr\u00f4le de la capacit\u00e9 du tableau\nvoid vector_set(vector\u2217 v, int i, int x){\n    // ajouter x en position i\n    v\u2212&gt;data[i] = x;\n}\n</code></pre> <p>En fait, nous utiliserons <code>vector_set</code> comme fonction auxiliaire d'une fonction <code>vector_push</code> , qui ajoute un \u00e9l\u00e9ment et incr\u00e9mente la taille du tableau (en lan\u00e7ant parfois un redimensionnement).</p>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#redimensionnement","title":"Redimensionnement","text":"<pre><code>void vector_resize(vector\u2217 v, int c){\n    assert(0 &lt;= c);\n    if(c &gt; v\u2212&gt;capacity){\n        v\u2212&gt;capacity = 2 \u2217 v\u2212&gt;capacity;\n        if (v\u2212&gt;capacity &lt; c)\n            v\u2212&gt;capacity = c;\n        // la capacit\u00e9 est donc au moins multipli\u00e9e par 2\n        int* old = v\u2212&gt;data;\n        v\u2212&gt;data = malloc(v\u2212&gt;capacity \u2217 sizeof(int)); // O(1) suppos\u00e9\n        for(int i = 0; i &lt; v\u2212&gt;size; i++)\n            v\u2212&gt;data[i] = old [i];\n        free(old);\n    }\n}\n</code></pre> <ul> <li>Si <code>c &gt; v-&gt;capacity</code> , on redimensionne en <code>max(2*v-&gt;capacity,c)</code>.</li> <li>On r\u00e9alloue un nouveau tableau interne et on copie les valeurs de l'ancien dedans.</li> <li>On d\u00e9salloue l'ancien tableau; puis on red\u00e9fini la taille du tableau redimensionnable</li> </ul>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#accumulation","title":"Accumulation","text":"<p>La fonction <code>vector_push</code> ajoute un \u00e9l\u00e9ment et incr\u00e9mente la taille du tableau.</p> <pre><code>void vector_push (vector\u2217 v, int x){\n    int n = v\u2212&gt;size;\n    vector_resize(v , n+1) ; // O(1) ou O(2 \u2217 v\u2212&gt;size)\n    vector_set(v, n, x) ; // O(1)\n    v\u2212&gt;size = n+1;\n}\n</code></pre> <ul> <li>Si on n'utilise que cette fonction pour ajouter des \u00e9l\u00e9ments, la taille du tableau est bien en ad\u00e9quation avec le nombre d'\u00e9l\u00e9ments qui ont \u00e9t\u00e9 effectivement ajout\u00e9s.</li> <li>Avec <code>push</code> et le test <code>(v-&gt;size == 0)</code> on a presque tout ce qu'il faut pour une structure de pile (voir chapitre suivant). Il ne reste qu'\u00e0 ajouter un pop !</li> </ul>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#complexite-amortie-dune-sequence-doperations","title":"Complexit\u00e9 amortie d'une s\u00e9quence d'op\u00e9rations","text":"<ul> <li>On consid\u00e8re une s\u00e9quence de \\(n\\) op\u00e9rations <code>vector_push</code> \u00e0 partir d'une cr\u00e9ation avec <code>vector_create(1)</code> et on montre que la complexit\u00e9 est lin\u00e9aire en \\(n\\).</li> <li>On pourra donc en d\u00e9duire que la complexit\u00e9 amortie d'une op\u00e9ration vector_push est en <code>O(1)</code>.</li> <li>M\u00e9thode directe :<ul> <li>Pour ajouter \\(n\\) \u00e9l\u00e9ments successivement \u00e0 partir d'un tableau de taille initiale 1, on fait des redimensionnements avec des co\u00fbts respectifs \\(1,2,4,...,2^k\\) o\u00f9 \\(k = \\lfloor log2(n)\\rfloor\\) (nombre de copies).</li> <li>A ces redimensionnements s'ajoute un co\u00fbt constant \\(O (1)\\) pour chaque op\u00e9ration <code>vector_push</code> (comparaisons dans le redimensionnement + \u00e9criture). On obtient donc une complexit\u00e9 encadr\u00e9e par des multiples de</li> </ul> </li> </ul> <p>\\(n \u00d71 + \\sum_{i=0}^k 2^i = n + 2^{k +1} \u22121 \\simeq n + 2n \u22121 = \u0398(n)\\)</p> <ul> <li>Chaque op\u00e9ration de <code>vector_push</code> a une complexit\u00e9 amortie \\(O (1)\\).</li> </ul>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#complexite-dune-sequence-doperations","title":"Complexit\u00e9 d'une s\u00e9quence d'op\u00e9rations","text":""},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#methode-du-potentiel","title":"M\u00e9thode du potentiel","text":"<ul> <li>Pour all\u00e9ger les notations, on note \\(c\\) pour <code>v-&gt;capacity</code> et \\(s\\) pour <code>v-&gt;size</code> et \\(v\\) le tableau qui subit une op\u00e9ration.</li> <li>On peut poser comme potentiel :</li> </ul> <p>\\(\u03c6(v ) \\underset{def}= max(0, 4s \u22122c )\\)</p> <p>Comme \\(s\\) grossit de \\(1\\) en \\(1\\) \u00e0 chaque op\u00e9ration <code>vector_push</code> , le redimensionnement n'arrive que si \\(s \\simeq c\\) , et, dans ce cas il y a en gros \\(2s\\) op\u00e9rations d'acc\u00e8s (lecture/\u00e9criture).</p> <ul> <li>Si \\(v\\) n'est pas redimensionn\u00e9, le co\u00fbt r\u00e9el est \\(1\\) et donc le co\u00fbt amorti est \\(a = 1 + \u03c6(apr\u00e8s) \u2212\u03c6(avant)\\)<ul> <li>si \\(s + 1 \u2264 \\frac{c}{2}\\) , alors les potentiels avant et apr\u00e8s sont nuls. Donc \\(a = 1\\).</li> <li>Si \\(s + 1 &gt; \\frac{c}{2}\\) , alors \\(s \u2265 \\frac{c}{2}\\) donc \\(4s \u22652c\\) . Alors : \\(a = 1 + (4(s + 1) \u22122c ) \u2212(4s \u22122c ) = 5\\)</li> </ul> </li> <li>Si \\(v\\) est redimensionn\u00e9, co\u00fbt r\u00e9el : \\(1 + 2s\\) (copies de \\(s\\) \u00e9l\u00e9ments plus qqs op\u00e9rations en \\(O (1)\\)). Alors \\(c = s\\) au coup d'avant et la nouvelle capacit\u00e9 est \\(c' = 2s\\) . Le co\u00fbt amorti est \\(5\\). En effet : \\(a = 1+2s +(4(s +1)\u22122c')\u2212(4s \u22122c ) = 1+2s +(4(s +1)\u22124s )\u2212(4s \u22122s)\\)</li> <li>Le co\u00fbt amorti de la s\u00e9quence est donc major\u00e9 par une constante. Par le corollaire du th\u00e9or\u00e8me d'amortissement, chaque op\u00e9ration de la s\u00e9quence a une complexit\u00e9 amortie en \\(O(1)\\).</li> </ul>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#listes-chainees","title":"Listes cha\u00een\u00e9es","text":""},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#definitions","title":"D\u00e9finitions","text":"<p>Liste chain\u00e9e</p> <p>Collection ordonn\u00e9e et de taille arbitraire d'\u00e9l\u00e9ments de m\u00eame type.</p> <p>Repr\u00e9sentation en m\u00e9moire</p> <p>Succession de cellules faites d'un contenu et d'un pointeur vers une autre cellule.</p> <p>Image</p> <p>La liste cha\u00een\u00e9e peut \u00eatre repr\u00e9sent\u00e9e par une cha\u00eene dont les maillons sont les cellules.</p>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#liste-simplement-chaine","title":"Liste simplement cha\u00een\u00e9","text":"<ul> <li>Deux informations composent chaque \u00e9l\u00e9ment de la liste cha\u00een\u00e9e :<ul> <li>la valeur associ\u00e9e \u00e0 l'\u00e9l\u00e9ment,</li> <li>un pointeur vers l'\u00e9l\u00e9ment suivant (ou successeur).</li> </ul> </li> <li>Comme un seul \u00e9l\u00e9ment de la liste est point\u00e9, l'acc\u00e8s se fait uniquement dans un sens. La fin de la liste est marqu\u00e9e par une valeur sentinelle, ici le pointeur <code>NULL</code>. L'usage d'un n\u0153ud sentinelle est aussi possible, notamment pour les listes cycliques.</li> <li>Le premier \u00e9l\u00e9ment de la liste a la valeur \\(12\\), le dernier a la valeur \\(37\\) et son pointeur est <code>NULL</code>.</li> </ul>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#primitives","title":"Primitives","text":"<p>Les primitives sur les listes cha\u00een\u00e9es n'ont pas un nom aussi codifi\u00e9 que celles sur les piles. Citons en quelques unes :</p> <ul> <li>\u00ab Placement sur le premier \u00e9l\u00e9ment \u00bb : place l'index sur le premier \u00e9l\u00e9ment de la liste.</li> <li>\u00ab Placement sur le dernier \u00e9l\u00e9ment \u00bb : place l'index sur le dernier \u00e9l\u00e9ment de la liste.</li> <li>\u00ab Placement sur l'\u00e9l\u00e9ment suivant \u00bb : place l'index sur l'\u00e9l\u00e9ment qui suit l'\u00e9l\u00e9ment courant si c'est possible.</li> <li>\u00ab Placement sur l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent \u00bb : place l'index sur l'\u00e9l\u00e9ment qui pr\u00e9c\u00e8de l'\u00e9l\u00e9ment courant si c'est possible.</li> <li>\u00ab Liste est-elle vide ? \u00bb : Retourne vrai si la liste est vide, faux sinon.</li> <li>\u00ab L'\u00e9l\u00e9ment courant est-il le premier ? \u00bb : Retourne vrai si l'\u00e9l\u00e9ment courant est le premier \u00e9l\u00e9ment de la liste, faux sinon.</li> <li>\u00ab L'\u00e9l\u00e9ment courant est-il le dernier ? \u00bb : Retourne vrai si l'\u00e9l\u00e9ment courant est le dernier \u00e9l\u00e9ment de la liste, faux sinon.</li> <li>\u00ab Nombre d'\u00e9l\u00e9ments \u00bb : renvoie le nombre d'\u00e9l\u00e9ments dans la liste.</li> <li>\u00ab Ajouter en queue \u00bb : ajoute un \u00e9l\u00e9ment apr\u00e8s le dernier \u00e9l\u00e9ment de la liste (efficace seulement pour une liste doublement cha\u00een\u00e9e).</li> <li>\u00ab Ajouter en t\u00eate \u00bb : ajoute un \u00e9l\u00e9ment avant le premier \u00e9l\u00e9ment de la liste.</li> <li>\u00ab Insertion \u00bb : ins\u00e8re un \u00e9l\u00e9ment avant l'\u00e9l\u00e9ment courant.</li> <li>\u00ab Remplacement \u00bb : Remplace l'\u00e9l\u00e9ment courant.</li> <li>\u00ab Suppression \u00bb : Supprime l'\u00e9l\u00e9ment courant.</li> </ul> <p>Nous en implanterons quelques unes en TP.</p>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#implementation-par-tableau","title":"Impl\u00e9mentation par tableau","text":"<ul> <li>On peut impl\u00e9menter cette structure par un tableau \\(t\\) et un indice \\(i\\) indiquant la derni\u00e8re case significative du tableau.</li> <li>Les cellules sont alors contigu\u00ebs et \\(\\color{red}\\text{on acc\u00e8de rapidement au k-\u00e8me \u00e9l\u00e9ment}\\). \\(O(1)\\)</li> <li>Pour ajouter un \u00e9l\u00e9ment : si \\(i &lt; |t |\u22121\\), on incr\u00e9mente l'indice \\(i\\) et on enregistre le nouvel el\u00e9ment en position \\(i\\) . \\(O (1)\\)</li> <li>Pour supprimer le dernier \u00e9l\u00e9ment, si \\(i &gt; 0\\), on d\u00e9cr\u00e9mente simplement la taille. \\(O (1)\\)</li> <li>Probl\u00e8mes : que faire si on veut ajouter un \u00e9l\u00e9ment alors que \\(i = |t |\u22121\\) ou si on veut supprimer un \u00e9l\u00e9ment en position \\(k &lt; i\\)?<ul> <li>si \\(i = |t |\u22121\\) et si on veut ajouter un \u00e9l\u00e9ment, on doit faire une r\u00e9allocation qui va se traduire par la recherche d'une zone m\u00e9moire avec suffisament de cases contigu\u00ebs et une copie de t dans la nouvelle zone. Co\u00fbteux. \\(O (|t |)\\).</li> <li>si on veut supprimer l'\u00e9l\u00e9ment 0 du tableau, il faut d\u00e9caler d'un cran vers la gauche tous les \u00e9l\u00e9ments du tableau. Co\u00fbteux. Potentiellement en \\(O(|t|)\\) si le tableau est plein.</li> </ul> </li> </ul>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#mplementation-par-chainage-ajout-dun-element","title":"mpl\u00e9mentation par cha\u00eenage (Ajout d'un \u00e9l\u00e9ment)","text":"<p>Situation initiale :</p> <p></p> <p>On veut ins\u00e9rer un nouvel \u00e9l\u00e9ment \u00e9l\u00e9ment \\(E\\) de valeur \\(200\\) apr\u00e8s l'\u00e9l\u00e9ment \\(B\\) de valeur \\(99\\) (et donc avant l'\u00e9l\u00e9ment \\(C\\) de valeur \\(37\\)).</p> <p>On change le pointeur (initialement <code>NULL</code>) de \\(E\\) : \\(E\\) pointe maintenant vers l'\u00e9l\u00e9ment \\(C\\).</p> <p></p> <p>On suprime le lien de \\(B\\) vers \\(C\\) et on fait pointer \\(B\\) vers \\(E\\)</p> <p></p>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#un-type-c","title":"Un type C","text":"<p>Type d'un \u00e9l\u00e9ment de la liste :</p> <pre><code>// openClassRoom et Wikipedia :\ntypedef struct Element Element ;\nstruct Element{\n    int val;\n    Element\u2217 next ;\n};\n</code></pre> <p>Structure de contr\u00f4le. On donne le type d'une liste. C'est une structure qui contient juste un pointeur vers le premier <code>Element</code> de la liste.</p> <pre><code>typedef struct Liste Liste;\nstructListe{\n    Element\u2217 first;\n    int size; // facultatif\n};\n</code></pre>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#en-ocaml","title":"En OCaml","text":""},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#un-type-list","title":"Un type list","text":"<ul> <li>On peut utiliser</li> </ul> <pre><code>type 'a list = Empty | List of 'a * 'a list\n(* Exemple : -&gt; 1 -&gt; 2-&gt; 3*)\nlet l = List (1,List(2,List(3,Empty)))\n</code></pre> <ul> <li>Un type r\u00e9alisant les m\u00eames op\u00e9rations est pr\u00e9d\u00e9fini en OCaml : le type <code>list</code> dont les primitives sont implant\u00e9es dans le module \\(\\texttt{List}\\).</li> <li> <p>Comme en C, une valeur de type <code>list</code> est un pointeur vers un bloc m\u00e9moire de deux valeurs, l'\u00e9l\u00e9ment et la suite de la liste.</p> </li> <li> <p>Par exemple, <code>let lst = 1::2::3::[]</code> alloue \\(3\\) blocs m\u00e9moires. Et la variable <code>lst</code> contient un pointeur vers la premi\u00e8re cellule.</p> </li> </ul> <p></p> <ul> <li>On voit appara\u00eetre \\(3\\) parties par bloc m\u00e9moire contre \\(2\\) en C. Une partie de chaque bloc est en effet utilis\u00e9e par OCaml pour stocker des m\u00e9ta-informations (not\u00e9e ici <code>::</code>) comme la nature du bloc et sa taille. Cette m\u00e9ta-information est utilis\u00e9e en particulier par le Garbage Collector d'OCaml.</li> </ul>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#listes-en-c-vs-ocaml","title":"Listes en C vs OCaml","text":"<p>Persistance</p> <ul> <li>En C, les listes sont mutables (on peut modifier <code>e-&gt;val</code> et <code>e-&gt;next</code>)</li> <li>Tandis qu'en OCaml aucune partie de la liste n'est modifiable.</li> </ul> <p>Polymorphisme</p> <ul> <li>En C les listes sont monomorphes (un seul type de donn\u00e9es : celui indiqu\u00e9 dans la d\u00e9claration de structure). </li> <li>En OCaml, les listes sont polymorphes (il peut y avoir des listes de n'importe quoi).</li> </ul> <p>Homog\u00e9neit\u00e9</p> <p>En OCaml comme en C, les listes sont homog\u00e8nes (tous les \u00e9l\u00e9ments ont le m\u00eame type que le premier). En Python les listes sont h\u00e9t\u00e9rog\u00e8nes.</p>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#autres-types-de-listes","title":"Autres types de listes","text":""},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#listes-doublement-chainees","title":"Listes doublement cha\u00een\u00e9es","text":"<ul> <li>Un pointeur vers l'\u00e9l\u00e9ment pr\u00e9c\u00e9dent (ou pr\u00e9d\u00e9cesseur) est ajout\u00e9. L'acc\u00e8s peut alors se faire indiff\u00e9remment dans les deux sens : de successeur en successeur, ou de pr\u00e9d\u00e9cesseur en pr\u00e9d\u00e9cesseur.</li> <li>plus co\u00fbteuse en m\u00e9moire (un pointeur suppl\u00e9mentaire par \u00e9l\u00e9ment) et en nombre d'instructions pour la mise \u00e0 jour : une insertion co\u00fbte quatre copies de pointeurs, contre deux dans le cas d'une liste simplement cha\u00een\u00e9e.</li> <li>En revanche, \u00e0 partir d'un \u00e9l\u00e9ment courant, on peut ins\u00e9rer un nouvel \u00e9l\u00e9ment avant ou apr\u00e8s (pour une liste simplement cha\u00een\u00e9e, on peut ins\u00e9rer seulement apr\u00e8s l'\u00e9l\u00e9ment courant).</li> </ul>"},{"location":"Structures%20Sequentielles/1-Tableaux-ListeChainee/#cycles","title":"Cycles","text":"<ul> <li>Une liste cyclique (ou circulaire) est cr\u00e9\u00e9e lorsque le dernier \u00e9l\u00e9ment poss\u00e8de une r\u00e9f\u00e9rence vers le premier \u00e9l\u00e9ment (si la liste est doublement cha\u00een\u00e9e, alors le premier \u00e9l\u00e9ment poss\u00e8de aussi une r\u00e9f\u00e9rence vers le dernier).</li> <li>L'utilisation de ce type de liste requiert des pr\u00e9cautions pour \u00e9viter des parcours infinis, par exemple, lors d'une recherche vaine d'\u00e9l\u00e9ment.</li> <li>Pour cr\u00e9er une liste circulaire \u00e0 partir d'une liste simplemnent cha\u00een\u00e9e : faire pointer le pointeur du dernier \u00e9l\u00e9ment (initialement \\(\\texttt{Null}\\)) vers le premier \u00e9l\u00e9ment.</li> </ul>"},{"location":"Structures%20Sequentielles/2-PilesFiles/","title":"Piles et Files","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Wikipedia : en fran\u00e7ais et (plus complet mais en anglais) ici</li> <li>La documentation sur le module Stack de OCaml</li> <li>La documentation sur le module Queue de OCaml</li> </ul>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#piles","title":"Piles","text":""},{"location":"Structures%20Sequentielles/2-PilesFiles/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":""},{"location":"Structures%20Sequentielles/2-PilesFiles/#pile","title":"Pile","text":"<p>Pile (stack en anglais )</p> <p>C'est une structure de donn\u00e9es fond\u00e9e sur le principe \u00ab dernier arriv\u00e9, premier sorti \u00bb (ou \\(\\texttt{LIFO}\\) pour \\(\\texttt{Last In, First Out}\\)), ce qui veut dire que les derniers \u00e9l\u00e9ments ajout\u00e9s \u00e0 la pile seront les premiers \u00e0 \u00eatre r\u00e9cup\u00e9r\u00e9s.</p> <p>Le fonctionnement est celui d'une pile d'assiettes : on ajoute des assiettes sur la pile, et on les r\u00e9cup\u00e8re dans l'ordre inverse, en commen\u00e7ant par la derni\u00e8re ajout\u00e9e.</p> <p></p> <p>Figure \u2013 Empiler et d\u00e9piler</p> <p><p></p></p> <p>Figure \u2013 Empilement de \\(A\\) puis$ B$, d\u00e9pilement de \\(B\\) puis \\(A\\) \\((\\texttt{LIFO})\\)</p>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#historique","title":"Historique","text":"<ul> <li>Turing 1946. Description th\u00e9orique d'appel et de retour de sous-routines.</li> <li>Klaus Samelson et Friedrich L. Bauer de l'universit\u00e9 Technique de M \u0308unich g\u00e9n\u00e9ralisent l'id\u00e9e en 1955 en pr\u00e9sentant une mod\u00e9lisation du fonctionnement des ordinateurs \u00e0 base de piles.</li> <li>M\u00eame concept, ind\u00e9pendamment d\u00e9velopp\u00e9 par l'australien Charles Leonard Hamblin en 1957.</li> </ul>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#les-primitives-indispensables","title":"Les primitives indispensables","text":"<ul> <li>\u00ab Empiler \u00bb : ajoute un \u00e9l\u00e9ment sur la pile. Terme anglais correspondant : \u00ab Push \u00bb .</li> <li>\u00ab D\u00e9piler \u00bb : enl\u00e8ve l'\u00e9l\u00e9ment au sommet de la pile et le renvoie. Terme anglais correspondant : \u00ab Pop \u00bb .</li> <li>\u00ab La pile est-elle vide ? \u00bb : renvoie vrai si la pile est vide, faux sinon. \\(\\Leftrightarrow\\) \u00ab is_empty \u00bb</li> </ul>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#autres-primitives","title":"Autres primitives","text":"<p>Elles peuvent \u00eatre obtenues \u00e0 partir des 3 premi\u00e8res :</p> <ul> <li>\u00ab Nombre d'\u00e9l\u00e9ments de la pile \u00bb : renvoie le nombre d'\u00e9l\u00e9ments dans la pile. Complexit\u00e9 : Selon les impl\u00e9mentations, peut \u00eatre fait soit en temps constant soit en temps lin\u00e9aire.</li> <li>\u00ab Quel est l'\u00e9l\u00e9ment de t\u00eate ? \u00bb : renvoie l'\u00e9l\u00e9ment de t\u00eate sans le d\u00e9sempiler. Terme anglais correspondant : \u00ab Peek \u00bb .</li> <li>\u00ab Vider la pile \u00bb : d\u00e9piler tous les \u00e9l\u00e9ments. Complexit\u00e9 : Selon l'impl\u00e9mentation, cela peut \u00eatre fait en temps constant ou lin\u00e9aire. Terme anglais correspondant : \u00ab Clear \u00bb .</li> <li>\u00ab Dupliquer l'\u00e9l\u00e9ment de t\u00eate \u00bb et \u00ab \u00e9changer les deux premiers \u00e9l\u00e9ments \u00bb : existe sur les calculatrices fonctionnant en notation polonaise inverse (style HP). Termes anglais correspondants : \u00ab Dup \u00bb  et \u00ab Swap \u00bb respectivement</li> </ul>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#un-peu-de-maths","title":"Un peu de maths","text":"<p>En mati\u00e8re de structures abstraites, on peut consid\u00e9rer qu'une pile est un mono\u00efde libre, c'est-\u00e0-dire un ensemble muni d'une loi de composition interne (la concat\u00e9nation) associative et poss\u00e9dant un \u00e9l\u00e9ment neutre (la pile vide).</p>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#applications","title":"Applications","text":"<ul> <li>La plupart des microprocesseurs g\u00e8rent nativement une pile. Elle correspond alors \u00e0 une zone de la m\u00e9moire, et le processeur retient l'adresse du dernier \u00e9l\u00e9ment.</li> <li>Dans un navigateur web, une pile sert \u00e0 m\u00e9moriser les pages Web visit\u00e9es. L'adresse de chaque nouvelle page visit\u00e9e est empil\u00e9e et l'utilisateur d\u00e9sempile l'adresse de la page pr\u00e9c\u00e9dente en cliquant le bouton \u00ab Afficher la page pr\u00e9c\u00e9dente \u00bb .</li> <li>L'\u00e9valuation des expressions math\u00e9matiques en notation post-fix\u00e9e (ou polonaise inverse) utilise une pile.</li> <li>La fonction \u00ab Annuler la frappe \u00bb (en anglais Undo) d'un traitement de texte m\u00e9morise les modifications apport\u00e9es au texte dans une pile.</li> <li>Un algorithme de recherche en profondeur d'abord utilise une pile pour m\u00e9moriser les n\u0153uds visit\u00e9s.</li> <li>Inversion d'un tableau ou d'une cha\u00eene de caract\u00e8res.</li> <li>Les algorithmes r\u00e9cursifs admis par certains langages \\((\\texttt{LISP, C, Python,} \\text{ etc...})\\) utilisent implicitement une pile d'appel.</li> </ul>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#listes-ocaml-et-piles","title":"Listes OCaml et piles","text":"<ul> <li>En OCaml, les listes ont un comportement de piles (fonctionnelles). Il n'y a donc pas besoin d'importer de module particulier pour b\u00e9n\u00e9ficier d'une structure de pile.</li> <li>Les listes OCaml ne sont pas des structures imp\u00e9ratives : il n'y a pas d'effets de bord.  \\(\\color{red}\\text{Pour une structure de pile imp\u00e9rative pr\u00e9f\u00e9rer le module Stack.}\\)</li> </ul>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#en-ocaml","title":"En OCaml","text":"<pre><code>open Stack ;;(*charger le module Stack (pile)*)\nlet s = create ();;(*cr\u00e9ation d'une pile vide*)\npush 3 s; push 6 s; push 7 s;;\n(*-&gt; ajouter 3 nombres dans la pile*)\nlet s' = copy(s);;(*faire une copie de la pile*)\nfor i = 0 to 2 do\n    (*notre premi\u00e8re boucle for CAML*)\n    (*pos s : retire le sommet*)\n    Printf.printf \"%d; \" (pop s);\ndone ;;\ntry\n    (*On sait que le code suivant risque\n    de g\u00e9n\u00e9rer une exception ...\n    ... Mais on 'essaye ' quand m\u00eame (try) !*)\n    print_int (pop s);\n    (*on risque depiler une pile vide!!*)\n    with Empty -&gt;\n        print_string \"pile vide : t ouf ???\\n\";;\n</code></pre>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#rendu-jusquaux-empilements","title":"Rendu (jusqu'aux empilements)","text":"<pre><code># open Stack;;\n# let s = create ();;\nval s : '_a Stack.t = &lt;abstr&gt;\n# push 3 s; push 6 s; push 7 s;;\n- : unit = ()\n# let s' = copy(s);;\nval s' : int Stack.t = &lt;abstr&gt;\n# for i = 0 to 2 do\n    Printf.printf \"%d; \" (pop s);\ndone;;\n    7; 6; 3; - : unit = ()\n# push 3 s; push 6 s; push 7 s;;\n- : unit = ()\n\n# let s' = copy(s);;\nval s' : int Stack.t = &lt;abstr&gt;\n# for i = 0 to 2 do\n    (*notre premi\u00e8re boucle for CAML*)\n    Printf.printf \"%d; \" (pop s);\ndone;;\n    7; 6; 3; - : unit = ()\n# try\n    (*On sait que le code suivant risque de g\u00e9n\u00e9rer une exception *)\n    (*mais on 'essaye' quand m\u00eame (try)*)\n    print_int (pop s);(*on risque de d\u00e9piler une pile vide*)\nwith Empty -&gt; print_string \"vous avez voulu d\u00e9piler une pile vide\\n\";;\n        vous avez voulu d\u00e9piler une pile vide\n- : unit = ()\n</code></pre>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#des-piles-en-c","title":"Des piles en C","text":""},{"location":"Structures%20Sequentielles/2-PilesFiles/#a-partir-de-tableaux-redimensionnables","title":"\u00c0 partir de tableaux redimensionnables","text":"<p>Dans le fichier <code>vector.c</code> (cf. cours listes), ajoutons :</p> <pre><code>// renvoie le sommet SANS d\u00e9piler\nint vector_top(vector\u2217 v){\n// renvoie l'\u00e9l\u00e9ment en haut depile SANS d\u00e9piler \nint n = vector_size(v) \u2212 1;\nassert(0 &lt;= n);\nreturn vector_get(v, n);\n}\n\n// D\u00e9pile le sommet et le renvoie\n// d\u00e9cr\u00e9mente v\u2212&gt;size + redimensionnement possible\nint vector_pop(vector\u2217 v){\n    int n = vector_size(v) \u2212 1;\n    assert(0 &lt;= n);\n    int r = vector_get(v, n);\n    vector_resize(v, n); //\n    return r;\n}\n</code></pre>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#a-partir-de-listes-chainees","title":"\u00c0 partir de listes cha\u00een\u00e9es","text":"<p>Dans le fichier <code>tplc.c</code> (cf TP sur les listes cha\u00een\u00e9es) ajoutons :</p> <pre><code>Liste\u2217 create(){// cr\u00e9e une liste vide\n    Liste\u2217 liste = malloc(sizeof(Liste));\n    liste\u2212&gt;first = NULL;\n    return liste;\n}\n\nvoid push(Liste\u2217 liste,int x){//empiler\n    ajouterDebut(liste, x);\n}\n\nint pop(Liste*  liste){// d\u00e9piler\n    return supprimer(liste, 0);\n}\n</code></pre>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#files","title":"Files","text":""},{"location":"Structures%20Sequentielles/2-PilesFiles/#definition","title":"D\u00e9finition","text":"<p>File (queue en anglais)</p> <p>En informatique, c'est une structure de donn\u00e9es bas\u00e9e sur le principe du Premier entr\u00e9, premier sorti, en anglais \\(\\texttt{FIFO}\\) \\(\\texttt{(First In, First Out)}\\), ce qui veut dire que les premiers \u00e9l\u00e9ments ajout\u00e9s \u00e0 la file seront les premiers \u00e0 \u00eatre r\u00e9cup\u00e9r\u00e9s.</p> <p>Le fonctionnement ressemble \u00e0 une file d'attente \u00e0 la poste : les premi\u00e8res personnes \u00e0 arriver sont les premi\u00e8res personnes \u00e0 sortir de la file.</p> <p></p> <p>Figure \u2013 Une pile \\((\\texttt{FIFO})\\)</p>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#applications_1","title":"Applications","text":"<ul> <li>Usage : M\u00e9moriser temporairement des transactions qui doivent attendre pour \u00eatre trait\u00e9es dans l'ordre d'arriv\u00e9e.</li> <li>Les serveurs d'impression, qui doivent traiter les requ\u00eates dans l'ordre dans lequel elles arrivent, et les ins\u00e8rent dans une file d'attente (ou une queue).</li> <li>Certains moteurs multit\u00e2ches, dans un syst\u00e8me d'exploitation, qui doivent accorder du temps-machine \u00e0 chaque t\u00e2che, sans en privil\u00e9gier aucune.</li> <li>Un algorithme de parcours en largeur d'abord dans un graphe utilise une file pour m\u00e9moriser les n\u0153uds visit\u00e9s.</li> <li>Pour cr\u00e9er toutes sortes de m\u00e9moires tampons (en anglais buffers).</li> </ul>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#primitives","title":"Primitives","text":"<p>Voici les primitives commun\u00e9ment utilis\u00e9es pour manipuler des files. Il n'existe pas de normalisation pour les primitives de manipulation de file. Leurs noms sont donc indiqu\u00e9s de mani\u00e8re informelle.</p> <ul> <li>\u00ab Mettre dans la file \u00bb : ajoute un \u00e9l\u00e9ment dans la file. Terme anglais correspondant : \u00ab Enqueue \u00bb .</li> <li>\u00ab D\u00e9filer \u00bb : renvoie le prochain \u00e9l\u00e9ment de la file, et le retire de la file. Terme anglais correspondant : \u00ab Dequeue \u00bb .</li> <li>\u00ab La file est-elle vide ? \u00bb : renvoie \u00ab vrai \u00bb si la file est vide, \u00ab faux \u00bb sinon.</li> <li>\u00ab Nombre d'\u00e9l\u00e9ments dans la file \u00bb : renvoie le nombre d'\u00e9l\u00e9ments dans la file.</li> </ul>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#implementation-en-ocaml","title":"Impl\u00e9mentation en OCaml","text":"<ul> <li>On peut utiliser une liste comme une file \\(\\texttt{FIFO}\\).</li> <li>Pas efficace : alors que les ajouts et suppressions en fin de liste sont rapides, les op\u00e9rations d'insertions ou de retraits en d\u00e9but de liste sont lentes (car tous les autres \u00e9l\u00e9ments doivent \u00eatre d\u00e9cal\u00e9s d'une position).</li> <li>Pour impl\u00e9menter une file, utiliser le module OCaml Queue qui a \u00e9t\u00e9 con\u00e7ue pour fournir des op\u00e9rations d'ajouts et de retraits rapides dans la file.</li> </ul>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#en-ocaml_1","title":"En OCaml","text":"<pre><code>open Queue ;;(* importer le module *)\nlet q = create ();;(*file vide*)\nlet q' = copy(q);;(*copy de q*)\npush 3 q; push 6 q; push 7 q;;(* ajout de 3 6 7*)\nfor i = 0 to 2 do (*vider q*)\n    print_int (take q)\ndone ;;(* defiler 3 fois*)\ntry\n    print_int (take q);(*d\u00e9filer une file vide*)\nwith Empty -&gt; print_string \"file vide\\n\";;\n</code></pre> <p>Une exception \\(\\texttt{Empty}\\) est soulev\u00e9e quand on essaye de d\u00e9filer (\\(\\texttt{take}\\)) une file vide.</p>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#rendu","title":"Rendu","text":"<pre><code># open Queue;;\n# let q = create ();;\nval q : '_a Queue.t = &lt;abstr &gt;\n# let q' = copy(q);;\nval q' : '_a Queue.t = &lt;abstr &gt;\n# push 3 q; push 6 q; push 7 q;;\n - : unit = ()\n# for i = 0 to 2 do (* vider q*)\n    print_int (take q); (*d\u00e9filer *)\ndone;;\n    367- : unit = ()\n# try\n    print_int (take q);(*d\u00e9filer une file vide*)\nwith Empty -&gt; print_string \"file vide\\n\";;\n    file vide\n - : unit = ()\n</code></pre>"},{"location":"Structures%20Sequentielles/2-PilesFiles/#implementations","title":"Impl\u00e9mentations","text":"<p>En C, on peut cr\u00e9er les structures suivantes :</p> <pre><code>// ce qu'on met dans la file\ntypedef struct _element{// on y met ce qu'on veut :\nint v; // valeur ( mais autres champs possibles)\n} elt;\n\ntypedef struct _m{// liste dblt cha\u00een\u00e9e ( why not ?)\n    elt val;\n    struct _m\u2217 next; // suivant\n    struct _m\u2217 prev; // pr\u00e9c\u00e9dent\n}maillon;\n\ntypedef struct _p{// structure de contr\u00f4le\n    maillon\u2217 first; // pointe vers le 1er maillon\n    maillon\u2217 last; // pointe vers le dernier\n    // autres infos, par exemple :\n    int size; // incr avec push, decr avec take\n} grip;\n</code></pre>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/","title":"Dictionnaires","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Tableaux associatifs (Wikipedia)</li> <li>openclassrooms</li> <li>Informatique Tronc Commun (Serge Bays - Ellipse)</li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#generalites","title":"G\u00e9n\u00e9ralit\u00e9s","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#tableaux-associatifs","title":"Tableaux associatifs","text":"<p>Un tableau associatif</p> <p>Aussi appel\u00e9 dictionnaire ou table d'association est un type de donn\u00e9es associant \u00e0 un ensemble de clefs un ensemble correspondant de valeurs.</p> <p>Chaque clef est associ\u00e9e \u00e0 une valeur : un tableau associatif correspond donc \u00e0 une application en math\u00e9matiques.</p> <p>Grossi\u00e8rement, le tableau associatif est une g\u00e9n\u00e9ralisation du tableau : alors que le tableau traditionnel associe des entiers cons\u00e9cutifs \u00e0 des valeurs d'un certain type, le tableau associatif associe des valeurs d'un type arbitraire \u00e0 des valeurs d'un autre type.</p> <p>Exemples de la vie courrante</p> <ul> <li>Dictionnaire franco-anglais. Les cl\u00e9s sont les mots en fran\u00e7ais et les valeurs les traductions en anglais.</li> <li>Annuaire : les clefs sont les noms des usagers, les valeurs sont les num\u00e9ros de t\u00e9l\u00e9phone.</li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#operations-courantes","title":"Op\u00e9rations courantes","text":"<p>Op\u00e9rations dont la complexit\u00e9 temporelle attendue est en \\(O (1)\\) :</p> <ul> <li>ajout : association d'une nouvelle valeur \u00e0 une nouvelle clef ;</li> <li>modification : association d'une nouvelle valeur \u00e0 une ancienne clef ;</li> <li>suppression : suppression d'une clef et de la valeur correspondante ;</li> <li>recherche : d\u00e9termination de la valeur associ\u00e9e \u00e0 une clef, si elle existe ;</li> </ul> <p>\\(\\color{red}\\text{Le plus souvent ces op\u00e9rations ont un coup moyen en } O (1)\\) \\(\\color{red}\\text{et une complexit\u00e9 au pire (rarement atteinte) en } O (n)\\) \\(\\color{red}\\text{ (o\u00f9 n est le nombre de cl\u00e9s)}\\)</p> <p>Dans les sujets de concours d'ITC, sauf mention du contraire, on peut supposer abusivement que \\(\\color{red}\\text{les op\u00e9rations d'ajout-insertion-recherche-modification}\\) \\(\\color{red}\\text{sont en temps constant au pire cas.}\\)</p> <p>Souvent, on s'accorde la possibilit\u00e9 de boucler sur les cl\u00e9s du dictionnaire.</p>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#ordre-des-cles","title":"Ordre des cl\u00e9s","text":"<p>Dans un tableau (consid\u00e9r\u00e9 comme un dictionnaire dont les cl\u00e9s sont des entiers), il y a un ordre naturel pour les clefs : celui des entiers.</p> <p>Mais la notion th\u00e9orique de dictionnaire \\(\\color{red}\\text{n'impose en rien que l'ensemble des cl\u00e9s possibles soit ordonn\u00e9.}\\)</p> <p>Toutefois, les langages impl\u00e9mentant les dictionnaires autorisent souvent le parcours des cl\u00e9s.</p> <ul> <li>En \\(\\texttt{Python}\\), un dictionnaire est un it\u00e9rable, c'est \u00e0 dire qu'on peut parcourir son contenu avec une boucle <code>for</code> .</li> <li>Actuellement en \\(\\texttt{Python}\\) (mais \u00e7a peut changer), l'ordre du parcours des cl\u00e9s est celui de l'insertion.</li> </ul> <p>Il faut bien comprendre que m\u00eame si l'ensemble des cl\u00e9s est ordonn\u00e9, le parcours des cl\u00e9s ne respecte pas en g\u00e9n\u00e9ral ce caract\u00e8re.</p>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#implementations","title":"Impl\u00e9mentations","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#structures-courantes","title":"Structures courantes","text":"<p>L'impl\u00e9mentation la plus simple est la liste d'association (liste de couples cl\u00e9, valeur)</p> <pre><code>l = [(\"toto\",45),(53,89), (\"XX\",203.5)]\n</code></pre> <p>Insertion en \\(O(1)\\), recherche en \\(O(n)\\).</p> <p>Les dictionnaires sont le plus souvent utilis\u00e9s lorsque l'op\u00e9ration de recherche est la plus fr\u00e9quente. Pour cette raison, la conception privil\u00e9gie fr\u00e9quemment cette op\u00e9ration, au d\u00e9triment de l'efficacit\u00e9 de l'ajout et de l'occupation m\u00e9moire par rapport \u00e0 d'autres structures de donn\u00e9es.</p> <p>Deux structures sont particuli\u00e8rement efficaces pour repr\u00e9senter les tableaux associatifs : la table de hachage et l'arbre \u00e9quilibr\u00e9 (cette derni\u00e8re notion n'est pas explicitement au programme d'ITC).</p>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#implementation","title":"Impl\u00e9mentation","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#comparaison-des-complexites-temporelles","title":"Comparaison des complexit\u00e9s temporelles","text":"Op\u00e9rations Tables de hachage Arbre \u00e9quilibr\u00e9 Insertion \\(O (1)\\) moyenne, \\(O (n)\\) pire \\(O (log (n))\\) moyenne et pire. recherche \\(O (1)\\) moyenne, \\(O (n\\)) pire \\(O (log (n))\\) moyenne et pire. <ul> <li>En g\u00e9n\u00e9ral, les tables de hachage ont une repr\u00e9sentation plus compacte en m\u00e9moire.</li> <li>Les tables de hachage imposent la cr\u00e9ation (souvent difficile) d'une fonction de hachage, les arbres \u00e9quilibr\u00e9s ont juste besoin d'un ordre total sur les clefs.</li> <li>L'ensemble des cl\u00e9s n'a pas besoin d'un ordre total pour les tables de hachage.</li> <li>Les arbres \u00e9quilibr\u00e9s s'impl\u00e9mentent bien avec des structures de donn\u00e9es persistantes.</li> <li>Les tables de hachage utilisent un tableau (donc mutable).</li> <li>En \\(\\texttt{Python}\\), les dictionnaires sont impl\u00e9ment\u00e9s par des tables de hachage.</li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#un-bemol-sur-la-complexite-temporelle","title":"Un b\u00e9mol sur la complexit\u00e9 temporelle","text":"<p>En co\u00fbt amorti, les dictionnaires implant\u00e9s par tables de hachages (comme \u00e9tudi\u00e9s dans le cours) ont une insertion et une recherche en \\(O (1)\\) en co\u00fbt amorti dans un monde merveilleux sans collision.</p> <p>Cette affirmation doit \u00eatre relativis\u00e9e :</p> <ul> <li>D'abord le hachage lui-m\u00eame de la cl\u00e9 peut \u00eatre co\u00fbteux (en g\u00e9n\u00e9ral de l'ODG de la taille de la cl\u00e9). Sauf si (comme c'est souvent le cas), on travaille avec des cl\u00e9s de tailles born\u00e9es.</li> <li>Dans le cas d'une gestion des collisions par listes cha\u00een\u00e9es ou par sondage lin\u00e9aire, si le hachage ne suit pas une loi de distribution uniforme, la complexit\u00e9 des insertions et recherches peut \u00eatre alourdie.</li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#rappels-sur-les-listes-textttpython-et-les-tableaux","title":"Rappels sur les listes \\(\\texttt{Python}\\) et les tableaux","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#fonctionnement-dun-tableau","title":"Fonctionnement d'un tableau","text":"<ul> <li>Consid\u00e9rons une liste \\(\\texttt{Python}\\) \\(L\\) dont les \u00e9l\u00e9ments sont not\u00e9s \\(E_0,E_1,E_2,...\\)</li> <li>Les adresses des \u00e9l\u00e9ments de \\(L\\) (des mots binaires de \\(8\\) ou \\(4\\) octets) sont enregistr\u00e9es dans un tableau d'adresse. Ces mots/adresses occupent des places contigu\u00ebs en m\u00e9moire.</li> <li>\\(\\texttt{Python}\\) conna\u00eet l'adresse du d\u00e9but du tableau des adresses de la liste \\(L\\). Il retrouve n'importe quel \u00e9l\u00e9ment par une op\u00e9ration simple. Par exemple il trouve l'adresse de \\(E_3\\) en calculant :</li> </ul> <p>\\(\\kern 3pc\\)adresse de \\(E_0 + 3 \u00d7\\) taille d'une adresse</p> <p>Dans la suite on note \\(a_0\\) l'adresse de \\(E_0\\) et \\(t\\) la taille d'une adresse.</p> <p>Trouver le \\(3\\)\u00e8me \u00e9l\u00e9ment d'une liste \\(L\\)</p> <p><p></p></p> <p>Lorsqu'on entre \\(\\texttt{L[3]}\\), \\(\\texttt{Python}\\) acc\u00e8de \u00e0 l'adresse o\u00f9 est stock\u00e9e \\(E_3\\) en ajoutant \\(3\\) fois la taille d'une adresse \u00e0 l'adresse \\(a_0\\). \\(\\texttt{Python}\\) retourne alors le contenu trouv\u00e9 \u00e0 l'adresse \\(a_3\\).</p>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#principe-de-fonctionnement","title":"Principe de fonctionnement","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#objectif-et-fonctionnement","title":"Objectif et fonctionnement","text":"<ul> <li>Une fonction de hachage r\u00e9partit les paires cl\u00e9\u2013valeur dans un tableau d'alv\u00e9oles (une case du tableau est une alv\u00e9ole).</li> <li>Elle transforme une cl\u00e9 en une valeur de hachage, ce qui donne la position dans un tableau.</li> <li>Son calcul se fait parfois en deux temps :<ul> <li>Une fonction de hachage particuli\u00e8re \u00e0 l'application est utilis\u00e9e pour produire un nombre entier \u00e0 partir de la cl\u00e9 ;</li> <li>Ce nombre entier est converti en une position possible de la table, en g\u00e9n\u00e9ral en calculant le reste modulo la taille de la table.</li> </ul> </li> <li>Si la cl\u00e9 n'est pas un entier naturel, on fait en sorte de la consid\u00e9rer comme telle. Par exemple, pour les cha\u00eenes de caract\u00e8res :<ul> <li>on consid\u00e8re chaque caract\u00e8re comme un nombre (par exemple avec le code \\(\\texttt{ASCII}\\)) ;</li> <li>puis on le combine tous les nombres obtenus par une fonction rapide (souvent le \\(\\texttt{XOR -OU EXCLUSIF-}\\)).</li> <li>Les divisions sont \u00e0 \u00e9viter en raison de leur relative lenteur sur certaines machines.</li> </ul> </li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#presentation-simplifiee","title":"Pr\u00e9sentation simplifi\u00e9e","text":"<ul> <li>On dispose donc d'une fonction \\(h\\) dite de hachage qui va de l'ensemble des cl\u00e9s vers l'ensemble des indexes d'un tableau de couples (cl\u00e9s,valeurs) (les \u00e9l\u00e9ments du tableau sont appel\u00e9s alv\u00e9oles).</li> <li>Lorsqu'on ajoute une nouvelle association (John Smith,+1555-8976), la valeur \\(h\\)(John Smith) est calcul\u00e9e. C'est l'indice d'une case du tableau d'association.</li> <li>A la case \\(h\\)(John Smith), on met le tuple (John Smith,+1555-8976).</li> <li>Si la fonction de hachage est injective (ce qui n'arrive presque jamais), deux cl\u00e9s diff\u00e9rentes ont deux valeurs de hachage diff\u00e9rentes et on n'a aucun probl\u00e8me de collision.</li> </ul> <p>Un annuaire ; cas sans colllision</p> <p><p></p></p>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#collisions-grumelage","title":"Collisions, grumelage","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#gestion-des-collisions","title":"Gestion des collisions","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#par-chainage","title":"Par cha\u00eenage","text":"<ul> <li>On g\u00e8re un tableau de liste cha\u00een\u00e9es.</li> <li>Les alv\u00e9oles ne sont plus des tuples (cl\u00e9,valeur) mais des \\(\\color{red}\\text{listes cha\u00een\u00e9es de tuples}\\). Ces listes sont vides par d\u00e9faut.</li> <li>Lors de l'ajout d'une nouvelle association comme \\((B ,230)\\), on cherche l'av\u00e9ole \u00e0 l'indice \\(h(B )\\) du tableau des alv\u00e9oles. Il s'agit d'une liste cha\u00een\u00e9e. On ajoute au bout de cette liste cha\u00een\u00e9e l'association \\((B ,230)\\).</li> <li>Dans une recherche, le pire cas se produit quand la fonction de hachage associe un m\u00eame indice \u00e0 de nombreuses cl\u00e9s. Pour rechercher une cl\u00e9 particuli\u00e8re, il faut alors parcourir toute la liste cha\u00een\u00e9e de l'alv\u00e9ole.</li> </ul> <p><p></p></p>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#par-adressage-ouvert","title":"Par adressage ouvert","text":"<p>Les enregistrements (cl\u00e9s,valeurs) sont stock\u00e9s dans un tableau.</p> <p>Lorsqu'on ins\u00e8re l'association \\((k ,v )\\), on v\u00e9rifie si la case \\(h(k )\\) du tableau est libre.</p> <ul> <li>Si c'est le cas, tout va bien, on place l'association case \\(h(k )\\).</li> <li>Sinon, on part de la case \\(h(k)\\) et on explore le tableau selon une certaine fonction de sondage.<ul> <li>La plus simple de ces fonctions consiste \u00e0 exlorer d'abord la case \\(h(k ) + 1\\) puis la case \\(h(k ) + 2\\) etc. On l'appelle sondage lin\u00e9aire (l'intervalle entre deux cases explor\u00e9es est constant).  Bien s\u00fbr, il faut travailler modulo le nombre de cases dans le tableau.</li> <li>Autre m\u00e9thode, le sondage quadratique : l'\u00e9cart entre deux sondages augmente lin\u00e9airement. Encore une fois, travailler modulo.</li> </ul> </li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#cas-dun-sondage-lineaire-insertion","title":"Cas d'un sondage lin\u00e9aire (Insertion)","text":"<ul> <li>On ins\u00e8re d'abord John Smith et son num\u00e9ro. La valeur de hachage est \\(152\\). Pas de probl\u00e8me.</li> <li>On veut ins\u00e9rer ensuite Sandra Dee et son num\u00e9ro. Malheureusement, la valeur de hachage est aussi \\(152\\) : il y a collision. On ajoute donc les coordonn\u00e9es de Sandra \u00e0 la premi\u00e8re case libre apr\u00e8s \\(152\\), soit \\(153\\).</li> <li>Arrive Ted Baker. La valeur de hachage associ\u00e9e est \\(153\\). Cette valeur est bien unique mais la case correspondante est h\u00e9las occup\u00e9e par Sandra (laquelle a \u00e9t\u00e9 d\u00e9plac\u00e9e par rapport \u00e0 sa valeur de hachage). On cherche donc pour Ted, la prochaine case vide, soit \\(154\\).</li> </ul> <p>Exemple tir\u00e9 de wikipedia</p> <p><p></p></p> <ul> <li>On cherche les coordonn\u00e9es de Ted. La valeur de hachage est \\(153\\).</li> <li>En inspectant l'alv\u00e9ole de la case \\(153\\), on se rend compte que la cl\u00e9 stock\u00e9e est Sandra Dee et non Ted Baker.</li> <li>On examine donc la prochaine case selon le sondage lin\u00e9aire (ici, case courante \\(+ 1\\)). Cette fois-ci, la cl\u00e9 stock\u00e9e est bien Ted Baker. On renvoie son num\u00e9ro.</li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#sondage-quadratique-et-double-sondage","title":"Sondage quadratique et double sondage","text":"<p>D'apr\u00e8s Wikipedia</p> <ul> <li>Sondage quadratique : l'intervalle entre les alv\u00e9oles augmente lin\u00e9airement (les indices des alv\u00e9oles augmentent donc quadratiquement). En voici un exemple :</li> </ul> <p>\\(h_i (x ) = \\left(h(x) + (\u22121)^{i +1} \u00b7\\left\\lceil \\frac{i}{2} \\right\\rceil^2 \\right) \\text{ mod }k\\)</p> <p>o\u00f9 \\(k\\) est le nombre d'alv\u00e9oles et \\(i\\) le num\u00e9ro de la tentative (les \\(i \u22121\\) premi\u00e8res tentatives ont \u00e9chou\u00e9 \u00e0 trouver une case vide) ;</p> <ul> <li>le double hachage : l'indice de l'alv\u00e9ole est donn\u00e9 par une deuxi\u00e8me fonction de hachage, ou hachage secondaire. En cas de collision en case \\(h(k)\\) on calcule la nouvelle position en \\(h_2(h(k))\\).</li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#comparaison-des-performances","title":"Comparaison des performances","text":"<ul> <li>Le sondage lin\u00e9aire poss\u00e8de la meilleure performance en termes de cache, mais est sensible \u00e0 l'effet de grumelage d\u00e9crit plus haut. </li> <li>Le double hachage ne permet pas d'utiliser le cache efficacement, mais permet de r\u00e9duire presque compl\u00e8tement ce grumelage, au prix d'une complexit\u00e9 plus \u00e9lev\u00e9e.</li> <li>Le sondage quadratique se situe entre le lin\u00e9aire et le double hachage au niveau des performances.</li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#choix-dune-bonne-fonction-de-hachage","title":"Choix d'une bonne fonction de hachage","text":"<ul> <li>Pour de bonnes performances il faut trouver un compromis entre<ul> <li>la rapidit\u00e9 du calcul du hachage</li> <li>La taille \u00e0 r\u00e9server pour l'espace de hachage,</li> <li>La r\u00e9duction du risque de collisions</li> </ul> </li> <li>Prendre un nombre premier comme taille de table de hachage \u00e9vite les probl\u00e8mes de diviseurs communs et donc de collisions. Prendre une puissance de 2 comme taille permet un calcul modulo rapide.</li> <li>Il y a grumelage quand les valeurs de hachage se retrouvent c\u00f4te \u00e0 c\u00f4te dans la table (cf exemple avec Ted Baker). Pour l'\u00e9viter :<ul> <li>Privil\u00e9gier les fonctions de hachage avec une distribution uniforme des valeurs de hachage.</li> <li>Le rapport \\(\\text{fc} = \\frac{n}{k}\\) o\u00f9 \\(n\\) est le nombre de tuples cl\u00e9s-valeurs et \\(k\\) la capacit\u00e9 du tableau est appel\u00e9 facteur de compression. Si \\(\\text{fc} &gt; \\frac{1}{3}\\) , le risque de collision augmente.</li> <li>En \\(\\texttt{Python}\\), redimensionnement du tableau d\u00e8s que le facteur de compression d\u00e9passe \\(\\frac{2}{3}\\). La capacit\u00e9 est alors multipli\u00e9e par \\(2\\).</li> </ul> </li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#hachage-en-textttpython","title":"Hachage en \\(\\texttt{Python}\\)","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#la-fonction-hash","title":"La fonction <code>hash</code>","text":"<ul> <li>La fonction <code>hash</code> code les cl\u00e9s (Les cl\u00e9s doivent \u00eatre immutables -tuples, cha\u00eenes de caract\u00e8res...-).</li> <li>Puis, \\(\\texttt{Python}\\) calcule <code>hash(cl\u00e9)%n</code> o\u00f9 \\(n\\) est la taille du tableau sous-jacent.</li> <li>Deux cl\u00e9s consid\u00e9r\u00e9es comme \u00e9gales par <code>==</code> ont la m\u00eame valeur de hash. Ainsi</li> </ul> Listing 3 \u2013 Python Console<pre><code>&gt;&gt;&gt;hash(1)==hash(1.0)\nTrue\n</code></pre>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#taille-du-tableau-sous-jacent","title":"Taille du tableau sous-jacent","text":"<ul> <li>En \\(\\texttt{Python}\\), on redimensionne le dictionnaire si le facteur de compression d\u00e9passe \\(\\frac{2}{3}\\)</li> <li>Les tailles sont des puissances de \\(2\\)<ul> <li>De \\(1\\) \u00e0 \\(5\\) \u00e9l\u00e9ments la capacit\u00e9 est \\(2^3 = 8\\) car \\(\\frac{3}{2} \u00d75 = 7.5 &lt;2^3\\); en revanche \\(\\frac{3}{2} \u00d76 = 9\\) (redimensionner).</li> <li>De \\(6\\) jusqu'\u00e0 \\(10\\) \u00e9l\u00e9ments la capacit\u00e9 est \\(16\\) puisque \\(\\frac{3}{2} \u00d710 = 15 &lt;2^4\\); mais \\(\\frac{3}{2} \u00d711 = 16.5\\)</li> <li>On a \\(\\frac{2}{3} \u00d732 = 21.3\\) : donc \u00e0 partir de \\(22\\) la capacit\u00e9 passe \u00e0 \\(64\\)</li> </ul> </li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#calcul-du-modulo","title":"Calcul du modulo","text":"<ul> <li>La capacit\u00e9 du dictionnaire est de la forme \\(n = 2^p\\)</li> <li>\\(2^p \u22121\\) s'\u00e9crit en binaire comme un mot avec \\(p\\) lettres \\(1\\)</li> <li><code>h%n</code> et <code>h&amp;(n-1)</code> ont la m\u00eame valeur ( <code>&amp;</code> d\u00e9signe le \\(\\texttt{ET}\\) bit \u00e0 bit).</li> </ul> <p>Si on cr\u00e9e un dictionnaire avec un \u00e9l\u00e9ment, la capacit\u00e9 est \\(8\\). On calcule la position pour ins\u00e9rer un nouvel \u00e9l\u00e9ment de cl\u00e9 <code>c</code> par <code>hash(c)%8</code> ou encore <code>h(c)&amp;7</code>.</p>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#proprietes-de-hash","title":"Propri\u00e9t\u00e9s de <code>hash</code>","text":"<ul> <li>Si \\(i \u2208\\mathbb{N}, i \\neq \u22121\\) et \\(\u22122^{61} + 1 &lt;i &lt;2^{61} + 1\\), alors <code>hash(i)</code> vaut \\(i\\). <code>hash(2**61-1)</code> et <code>hash(-2**61+1)</code> valent \\(0\\), <code>hash(-1)</code> vaut \\(-2\\)</li> <li>Si \\(x\\) est un flottant \u00e9gal \u00e0 \\(\\frac{p}{q}\\) alors <code>hash(x)</code> vaut <code>int(p*M/q)%M</code> avec \\(M = 2^{61} \u22121\\) (on l'appelle le modulus).</li> <li>Si la cl\u00e9 est une cha\u00eene de caract\u00e8res, la valeur de hachage<ul> <li>est calcul\u00e9e \u00e0 partir d'une fonction al\u00e9atoirement choisie \u00e0 chaque ouverture de session,</li> <li>et a pour valeur un entier sur \\(64\\) bits.</li> </ul> </li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#manipulation-de-dictionnaires-en-textttpython","title":"Manipulation de dictionnaires en \\(\\texttt{Python}\\)","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#primitives","title":"Primitives","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#la-classe-ou-le-type-textttdict","title":"La classe ou le type \\(\\texttt{dict}\\)","text":"<p>En \\(\\texttt{Python}\\), un dictionnaire est une instance de la classe <code>dict</code> .</p> <pre><code>mydico=dict()#creation d'un dico vide\ntype(mydico)\n</code></pre> Rendu<pre><code>dict\n</code></pre> <pre><code>mydico={}#creation d'un dico vide\ntype(mydico)\n</code></pre> Rendu<pre><code>dict\n</code></pre>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#ajout-de-cles-et-valeurs","title":"Ajout de cl\u00e9s et valeurs","text":"<ul> <li>Ajouts successifs depuis un dictionnaire vide :</li> </ul> <pre><code>mydico={}#cree dico vide\nmydico[\"ceciEstUneClef1\"]=\"CeciEstUneValeur1\"\nmydico[\"blabla\"]=132\nmydico[125.36]=[1,2,3]\nprint(mydico)# cl\u00e9s et valeurs peuvent etre n'importe quoi\n</code></pre> <ul> <li>M\u00e9thode \\(2\\) :</li> </ul> <pre><code>1 dico2={'ceciEstUneClef1': 'CeciEstUneValeur1',\\\n         'blabla': 132, 125.36: [1, 2, 3]}\n</code></pre>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#acces","title":"Acc\u00e8s","text":"<ul> <li>Acc\u00e8s. On indique entre crochet la cl\u00e9 \u00e0 laquelle on veut acc\u00e9der :</li> </ul> <pre><code>mydico[\"blabla\"]\n</code></pre> Rendu<pre><code>123\n</code></pre> <ul> <li>Si la cl\u00e9 n'existe pas, une exception est soulev\u00e9e :</li> </ul> Listing 5 \u2013 cl\u00e9 inexistante<pre><code>mydico[\"cleFarfelue\"]\n</code></pre> <pre><code>---\nKeyError       Traceback (most recent call last)\n&lt;ipython-input-4-62aa81b7dbb7&gt; in &lt;module&gt;()\n      1 mydico[\"blabla\"]\n----&gt; 2 mydico[\"cleFarfelue\"] #exception KeyError\nKeyError: 'cleFarfelue'\n</code></pre>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#completion-simultanee-suppression-de-cle","title":"Compl\u00e9tion simultan\u00e9e, suppression de cl\u00e9","text":"<ul> <li>On peut cr\u00e9er un dictionnaire complexe d'une seule commande :</li> </ul> <pre><code>placard = {\"chemise\":3, \"pantalon\":6, \"tee-shirt\":7}\n</code></pre> <ul> <li>On supprime une cl\u00e9 et la valeur associ\u00e9e, sans retour de valeur :</li> </ul> <pre><code>del placard[\"chemise\"]# pas de valeur retournee\nplacard\n</code></pre> rendu<pre><code>{'tee-shirt': 7, 'pantalon': 6}\n</code></pre> <ul> <li>Suppression de cl\u00e9 avec retour de la valeur supprim\u00e9e correspondante :</li> </ul> <pre><code>print(placard.pop('tee-shirt')) # une valeur retournee\nplacard\n</code></pre> Rendu<pre><code>7\n{'pantalon': 6}\n</code></pre>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#modifier","title":"Modifier","text":"<ul> <li>Cl\u00e9 existante, la valeur correspondante est modifi\u00e9e :</li> </ul> <pre><code>placard['pantalon']=19 # passe de 6 a 19 pantalons\n</code></pre> Rendu<pre><code>{'pantalon': 19}\n</code></pre> <ul> <li>Si la cl\u00e9 n'existe pas d\u00e9j\u00e0, elle est cr\u00e9\u00e9e :</li> </ul> <pre><code>placard['smoking']=2\nplacard\n</code></pre> Rendu<pre><code>{'smoking': 2, 'pantalon': 19}\n</code></pre>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#valeurs-hachables","title":"Valeurs hachables","text":"<pre><code>d = {\"toto\":1}\nl = [1,2,3]\nd[l] = 3\n</code></pre> Rendu<pre><code>----------------------------------------------\nTypeError Traceback (most recent call last)\nCell In[14], line 3\n      1 d = {\"toto\":1}\n      2 l = [1,2,3]\n----&gt; 3 d[l] = 3\nTypeError: unhashable type: 'list'\n</code></pre> <p>Les clefs de dictionnaires doivent \u00eatre immuables.</p>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#parcours","title":"Parcours","text":"<p>Parcourir les cl\u00e9s : - Avec la m\u00e9thode <code>.keys</code> </p> <pre><code>for cle in placard.keys():\n    print(\"la cle \",cle, \"correspond a la valeur \",placard[cle])\n</code></pre> Rendu<pre><code>la cle smoking correspond a la valeur 2\nla cle pantalon correspond a la valeur 19\n</code></pre> <ul> <li>En utilisant une syntaxe all\u00e9g\u00e9e :</li> </ul> Listing 7 \u2013 Effet similaire au pr\u00e9c\u00e9dent<pre><code>for cle in placard:\n    print(\"la cle \",cle, \"correspond a la valeur \",placard[cle])\n</code></pre> <p>Parcourir les valeurs :</p> <pre><code>inventaire={\"pommes\":30,\"bi\u00e8res\":1,\"bananes\":17}\nfor v in inventaire.values():\n    print(v, end=\",\")\n</code></pre> Rendu<pre><code>30,1,17\n</code></pre> <ul> <li>Tester une valeur :</li> </ul> <pre><code>for k,v in inventaire.items():\n    if v==1:\n        print(\"Attention, refaire le stock de {}\".format(k))\n</code></pre> Rendu<pre><code>Attention, refaire le stock de bi\u00e8res\n</code></pre>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#fonctions-et-parametres-nommes","title":"Fonctions et param\u00e8tres nomm\u00e9s","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#objectif","title":"Objectif","text":"<ul> <li>On veut passer \u00e0 une fonction un nombre arbitraire de variables (par exemple) num\u00e9riques et en faire (par exemple) la somme.</li> </ul> <p>Exemple d'appel</p> <pre><code>somme(p=1,q=3,r=2)\n</code></pre> <ul> <li>On souhaite effectuer \\(1+3+2\\).</li> <li><code>p,q,r</code> sont ce qu'on appelle des param\u00e8tres nomm\u00e9s. Ils sont pass\u00e9 \u00e0 la fonction en arguments de la forme <code>nom_var=valeur</code>.</li> <li>On ne conna\u00eet pas \u00e0 l'avance les nom, les valeur ni le nombre des sparam\u00e8tres nomm\u00e9s</li> </ul>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#recuperer-les-parametres-nommes","title":"R\u00e9cup\u00e9rer les param\u00e8tres nomm\u00e9s","text":"<p>R\u00e9cup\u00e9rer les param\u00e8tres nomm\u00e9s : faire pr\u00e9c\u00e9der un nom quelconque par deux \u00e9toiles <code>**</code>.</p> Listing 8 \u2013 Les param\u00e8tres nomm\u00e9s sont en fait stock\u00e9s dans un dictionnaire<pre><code>def recupere(**parametres_nommes):\n    print \"param\u00e8tres nomm\u00e9s{}\".format(parametres_nommes)\n    recupere(p=1,q=2)\n</code></pre> <p>param\u00e8tres nomm\u00e9s : <code>{'q': 2, ' p' : 1}</code></p> <p>Exercice</p> <p>\u00c9crire la fonction <code>somme</code> qui fait la somme de ses param\u00e8tres nomm\u00e9s (ceux-ci \u00e9tant en nombre arbitraire)</p> <p>Correction</p> <pre><code>def somme(**args):\n    return sum([args[k] for k in args])\n</code></pre> Listing 9 \u2013 Deux fa\u00e7ons \u00e9quivalentes d'appeler la fonction<pre><code>somme(p=6, q=3), somme(**{'p':6,'q':3})\n</code></pre> Rendu<pre><code>(9,9)\n</code></pre>"},{"location":"Structures%20Sequentielles/3-Dictionnaires/#dictionnaires-par-comprehensions","title":"Dictionnaires par compr\u00e9hensions","text":""},{"location":"Structures%20Sequentielles/3-Dictionnaires/#construction-par-comprehension","title":"Construction par compr\u00e9hension","text":"<p>Comme les listes, les dictionnaires peuvent se construire par compr\u00e9hension.</p> Listing 10 \u2013 dictionnaire plusDeTrois construit par compr\u00e9hension<pre><code>bac_legumes={'bananes':6,'courgettes':2,'carottes':10}\nplusDeTrois={c:v for (c,v) in bac_legumes.items() if v&gt;2}\nplusDeTrois\n</code></pre> Rendu<pre><code>{'bananes': 6, 'carottes': 10}\n</code></pre>"},{"location":"Tests/1-Tests/","title":"Tests","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Sur la nuance entre erreur et d\u00e9faut, cet article de Cynthia Lefevre.  </li> <li>Ce cours du Labri.  </li> <li>Cet article de Wikipedia.  </li> <li>Ce cours du LRI de Paris-Saclay</li> <li>Un cours du CNAM avec des exemples de normes r\u00e9clamant les  crit\u00e8res \u00e9tudi\u00e9s.  </li> </ul>"},{"location":"Tests/1-Tests/#presentation","title":"Pr\u00e9sentation","text":""},{"location":"Tests/1-Tests/#terminologie","title":"Terminologie","text":"<p>D\u00e9finition: Erreur</p> <p>Action humaine produisant un r\u00e9sultat incorrect \\(\\color{red}\\text{\"l'erreur est humaine\"}\\)</p> <p>D\u00e9finition: D\u00e9faut</p> <p>Une imperfection dans un composant (ou un syst\u00e8me) qui peut conduire \u00e0 ce que ce composant (ou syst\u00e8me) n'ex\u00e9cute pas les fonctions requises. \\(\\color{red}\\text{On cherche les d\u00e9fauts sans manipuler le syst\u00e8me}\\).</p> <p>D\u00e9finition: D\u00e9faillance ou Panne</p> <p>\\(\\text{IEEE 729}\\) : La fin de la capacit\u00e9 d'un syst\u00e8me ou d'un de ses composants d'effectuer la fonction requise, ou de l'effectuer \u00e0 l'int\u00e9rieur de limites sp\u00e9cifi\u00e9es. \\(\\color{red}\\text{On cherche une d\u00e9faillance en manipulant le syst\u00e8me}\\).</p> <p>D\u00e9finition : Anolamie</p> <p>Un \u00e9cart entre le r\u00e9sultat attendu et celui obtenu.</p> <p>Remarque</p> <p>Ce n'est pas parce qu'il y a anomalie qu'il y a d\u00e9faut. Peut-\u00eatre le testeur a-t-il compris la sp\u00e9cification d'une fa\u00e7on et le d\u00e9veloppeur d'une autre.</p>"},{"location":"Tests/1-Tests/#defaut-vs-defaillance","title":"D\u00e9faut VS D\u00e9faillance","text":"<p>Il y a un rapport de causalit\u00e9.  </p> <ul> <li>A retenir : Un d\u00e9faut (dans le code) ou une erreur (de l'utilisateur du  programme) peut causer (un jour) une d\u00e9faillance.  </li> <li>On peut trouver un d\u00e9faut sans manipuler le syst\u00e8me (analyse du  code).  </li> <li>Mais on trouve une d\u00e9faillance en manipulant le syst\u00e8me.  </li> </ul>"},{"location":"Tests/1-Tests/#test","title":"Test","text":"<p>D\u00e9finition (norme \\(\\text{IEEE 729}\\) ) : Le test est un processus manuel ou automatique, qui vise \u00e0 \u00e9tablir qu'un syst\u00e8me v\u00e9rifie les propri\u00e9t\u00e9s  exig\u00e9es par sa sp\u00e9cification, ou \u00e0 d\u00e9tecter des di\ufb00\u00e9rences entre les  r\u00e9sultats engendr\u00e9s par le syst\u00e8me et ceux qui sont attendus par la  sp\u00e9cification.  </p> <p>Le test ne se pr\u00e9occupe pas des erreurs. Ce n'est pas au testeur de pointer les imperfections humaines.  </p> <p>Le test met en \u00e9vidence les d\u00e9fauts afin de pr\u00e9venir les d\u00e9faillances.  </p>"},{"location":"Tests/1-Tests/#tests-en-general","title":"Tests en g\u00e9n\u00e9ral","text":"<p>Toute fabrication de produit suit les \u00e9tapes suivantes  </p> <ul> <li>Conception</li> <li>R\u00e9alisation</li> <li>Tests  </li> </ul> <p>Test : On s'assure que le produit final correspond \u00e0 ce qui a \u00e9t\u00e9  demand\u00e9 selon divers crit\u00e8res :  </p> <ul> <li>esth\u00e9tique</li> <li>performance</li> <li>ergonomie</li> <li>fonctionnalit\u00e9</li> <li>robustesse etc.  </li> </ul> <p>Des Bogues aux cons\u00e9quences d\u00e9sastreuses</p> <ul> <li> <p>Su\u00e8de - \\(1980\\) :  \\(776\\) millions d'euros (\\(275\\) millions de dollars de \\(1980\\)). \\(104\\) camions semi-remorques de \\(35\\) tonnes, c'est la cargaison que le Zenobia emporta par le fond lors de son naufrage, \\(1\\) mois seulement apr\u00e8s son lancement inaugural. Pourquoi ? Un bug dans le logiciel de contr\u00f4le des ballasts surremplissait les r\u00e9servoirs par rapport aux indications qui lui \u00e9taient envoy\u00e9es.</p> </li> <li> <p>EADS - \\(1996\\) : \\(266\\) millions d'euros (\\(200\\) millions d'euros de \\(1996\\)) Le \\(4\\) juin \\(1996\\) (\\(1\\)er vol), la fus\u00e9e Ariane \\(5\\) s'est \u00e9lev\u00e9e jusqu'\u00e0 la moiti\u00e9 du ciel, avant que son logiciel ne coupe les moteurs et que le lanceur explose en plein vol. Pourquoi ? L'acc\u00e9l\u00e9ration maximale de la fus\u00e9e a d\u00e9pass\u00e9 la valeur admissible par le logiciel, g\u00e9n\u00e9rant une erreur g\u00e9n\u00e9rale et donc l'autodestruction. Valeurs recopi\u00e9es du programme Ariane \\(4\\) (moins puissante). La simulation avait \u00e9t\u00e9 annul\u00e9e afin d'\u00e9conomiser \\(800.000\\) francs (\\(119000\\) euros).</p> </li> </ul>"},{"location":"Tests/1-Tests/#cout-des-tests","title":"Co\u00fbt des tests","text":"<ul> <li>Budget IT : Budget allou\u00e9 aux technologies de l'information (ou IT pour Information Technology).</li> <li>Dans les entreprises, la part du budget IT consacr\u00e9e aux tests et \u00e0 l'assurance qualit\u00e9 augmente de \\(9\\) points d'une ann\u00e9e sur l'autre selon Capgemini.</li> <li>De \\(26\\)% en \\(2014\\), elle passe \u00e0 \\(35\\) % en \\(2015\\).</li> <li>Il \u00e9tait pr\u00e9vu qu'en \\(2018\\), la part des tests et de la qualit\u00e9 passe \u00e0 \\(40\\) % du total. (Source Silicon)</li> </ul>"},{"location":"Tests/1-Tests/#vvt","title":"VVT","text":"<p>\\(V\\)alidation, \\(V\\)\u00e9rification et \\(T\\)est logiciel.</p> <p>D\u00e9monstration automatique (Hum !) : exhaustive mais consid\u00e9r\u00e9e comme trop co\u00fbteuse.  </p> <p>Model Checking : v\u00e9rifier si le mod\u00e8le d'un syst\u00e8me satisfait une  propri\u00e9t\u00e9. Par exemple, on souhaite v\u00e9rifier qu'un programme ne se  bloque pas, qu'une variable n'est jamais nulle, etc. G\u00e9n\u00e9ralement, la  propri\u00e9t\u00e9 est \u00e9crite dans un langage, souvent en logique temporelle.  La v\u00e9rification est g\u00e9n\u00e9ralement faite de mani\u00e8re automatique.  </p> <p>Test : non exhaustif mais facile \u00e0 mettre en \u0153uvre (bon rapport qualit\u00e9/temps).  </p>"},{"location":"Tests/1-Tests/#cycle-en-v","title":"Cycle en V","text":"<p>Le test commence d\u00e8s le d\u00e9but !  </p> <p></p> <p>Figure \u2013 Le cycle en V du G\u00e9nie Logiciel (d'apr\u00e8s Irif)</p>"},{"location":"Tests/1-Tests/#classification","title":"Classification","text":""},{"location":"Tests/1-Tests/#selon-le-niveau-au-cycle-de-developpement","title":"Selon le niveau au cycle de d\u00e9veloppement","text":"<ul> <li>Tests de recette : test de r\u00e9ception du logiciel chez le client final  </li> <li>Tests int\u00e9gration syst\u00e8me : test de l'int\u00e9gration du logiciel avec  d'autres logiciels  </li> <li>Tests systeme : test d'acception du logiciel avant livraison (nouvelle  version par exemple). G\u00e9n\u00e9ralement e\ufb00ectu\u00e9 par le client dans ses  locaux apr\u00e8s installation du syst\u00e8me ou d'une unit\u00e9 fonctionnelle, avec  la participation du fournisseur.  </li> <li>Tests Integration : test de l'int\u00e9gration des di\ufb00\u00e9rents composants  (avec ou sans hardware)  </li> <li>\\(\\color{red}\\text{Tests Unitaires : tests \u00e9l\u00e9mentaires des composants logiciels (une fonction, un module, ...)  }\\)</li> </ul>"},{"location":"Tests/1-Tests/#selon-la-caracteristique","title":"Selon la caract\u00e9ristique","text":"<ul> <li>\\(\\color{red}\\text{Tests fonctionnels : destin\u00e9s \u00e0 s'assurer que, dans le contexte d'utilisation}\\) \\(\\color{red}\\text{r\u00e9elle, le comportement fonctionnel obtenu est bien  conforme avec celui attendu.}\\)</li> <li>Tests de performance (rapidit\u00e9, consommation m\u00e9moire etc.)  </li> <li>Tests de robustesse (mon serveur va-t-il bien r\u00e9agir \u00e0 un a\ufb04ux de  connexion ?)  </li> <li>Tests de vuln\u00e9rabilit\u00e9 : suis-je bien prot\u00e9g\u00e9 face aux risques  d'intrusions ?  </li> </ul>"},{"location":"Tests/1-Tests/#selon-le-niveau-daccessibilite","title":"Selon le niveau d'accessibilit\u00e9","text":"<ul> <li>Tests de type bo\u00eete noire : technique de conception de test,  fonctionnel ou non, qui n'est pas fond\u00e9e sur l'analyse de la structure  interne du composant ou du syst\u00e8me mais sur la d\u00e9finition du  composant ou du syst\u00e8me.  </li> <li>Tests de type bo\u00eete blanche : technique de conception de test, en  g\u00e9n\u00e9ral fonctionnel, fond\u00e9e sur l'analyse de la structure interne du  composant ou du syst\u00e8me.  </li> </ul> <p>Pour comparer les deux.</p>"},{"location":"Tests/1-Tests/#divers","title":"Divers","text":"<p>Tests de non-r\u00e9gression : \u00e0 la suite de la modification d'un logiciel (ou  d'un de ses constituants), un test de r\u00e9gression a pour but de montrer que  les autres parties du logiciel n'ont pas \u00e9t\u00e9 a\ufb00ect\u00e9es par cette modification.  </p>"},{"location":"Tests/1-Tests/#en-cpge","title":"En CPGE","text":"<ul> <li>Tests unitaires en g\u00e9n\u00e9ral bo\u00eete blanche et fonctionnels.  </li> <li>Moyen : pour tout exercice, cr\u00e9er un fichier ou une fonction de tests.  </li> <li>Rendu de projets : les tests sont imp\u00e9ratifs.  </li> </ul>"},{"location":"Tests/1-Tests/#copmlementarite-des-tests-fonctionnels-et-structurels","title":"Copml\u00e9mentarit\u00e9 des tests fonctionnels et structurels","text":"<p>En examinant ce qui a \u00e9t\u00e9 r\u00e9alis\u00e9, on ne prend pas forc\u00e9ment en compte ce qui aurait du \u00eatre fait</p> <ul> <li>Les approches structurelles (bo\u00eete blanche) d\u00e9tectent plus facilement les erreurs commises</li> <li>Les approches fonctionnelles (bo\u00eete noire) d\u00e9tectent plus facilement les erreurs d'omission</li> </ul>"},{"location":"Tests/1-Tests/#partitionnement-limite","title":"Partitionnement, limite","text":""},{"location":"Tests/1-Tests/#partitionnement-du-domaine-dentree","title":"Partitionnement du domaine d'entr\u00e9e","text":"<ul> <li>Il s'agit de r\u00e9partir les donn\u00e9es en un nombre fini de classes  d'\u00e9quivalence, sans restreindre le degr\u00e9 d'exigence. Cette m\u00e9thode est  g\u00e9n\u00e9ralement utilis\u00e9e pour r\u00e9duire le nombre total de cas de test \u00e0 un  ensemble fini.  </li> <li>Exemple : test d'une zone de saisie attendant des nombres de \\(1\\) \u00e0 \\(1000\\).  </li> <li>Classe des donn\u00e9es valides d'entr\u00e9e : s\u00e9lectionner un (ou quelques)  nombre.s dans \\([\\![ 2, 99]\\!]\\) (exemple : \\(50\\) et \\(800\\)).  </li> <li>Classe des donn\u00e9es inf\u00e9rieure \u00e0 \\(0\\) : s\u00e9lectionner un ou plusieurs nombres  n\u00e9gatifs (\\(-1\\) et \\(-100\\) par exemple).  </li> <li>Classe des donn\u00e9es sup\u00e9rieures \u00e0 \\(1001\\) : choisir \\(1050\\) et \\(2300\\) par  exemple.  </li> </ul>"},{"location":"Tests/1-Tests/#tests-aux-limites","title":"Tests aux limites","text":""},{"location":"Tests/1-Tests/#test-dune-zone-de-saisie-attendant-des-nombres-de-1-a-1000","title":"Test d'une zone de saisie attendant des nombres de 1 \u00e0 1000","text":"<p>En compl\u00e9ment du partitionnement du domaine d'entr\u00e9e, on ajoute les  tests aux limites</p> <ul> <li>Ce sont les donn\u00e9es encore valides mais au del\u00e0 desquelles les entr\u00e9es  ne le sont plus.  </li> <li>Il faut imp\u00e9rativement tester \\(1\\) et \\(1000\\). On peut y ajouter les valeurs  <ul> <li>juste en dessous des bornes : \\(0\\) et \\(999\\) </li> <li>juste au-dessus des bornes : \\(2\\) et \\(1001\\) </li> </ul> </li> <li>Si un des tests ne donne pas le r\u00e9sutat attendu, le programme n'est  pas correct. En revanche, le programme peut \u00eatre incorrect m\u00eame si  tous les tests du sc\u00e9nario donnent satisfaction.  </li> </ul>"},{"location":"Tests/1-Tests/#graphe-de-flots-de-controle","title":"Graphe de flots de contr\u00f4le","text":""},{"location":"Tests/1-Tests/#rappel-tests-unitaires-tests-fonctionnels","title":"Rappel : Tests unitaires ; tests fonctionnels","text":"<p>En CPGE on s'int\u00e9resse uniquement aux \\(\\color{red}\\text{Test Unitaires : tests \u00e9l\u00e9mentaires des composants logiciels (une fonction, un module, ...)}\\);</p> <p>La plupart des tests que nous avons \u00e9crits jusqu'\u00e0 pr\u00e9sent \u00e9taient des \\(\\color{red}\\text{Tests fonctionnels (\"bo\u00eete noire\") : destin\u00e9s \u00e0 s'assurer que, dans le contexte d'utilisation}\\) \\(\\color{red}\\text{r\u00e9elle, le comportement fonctionnel obtenu est bien conforme avec celui attendu}\\). On cr\u00e9e des tests sans ce soucier du code \u00e9crit.</p>"},{"location":"Tests/1-Tests/#tests-structurels","title":"Tests structurels","text":"<p>dits aussi tests bo\u00eete blanche</p> <ul> <li>S\u00e9lection de tests \u00e0 partir de l'analyse du code source du syst\u00e8me  </li> <li>Constructions des tests uniquement pour du code d\u00e9j\u00e0 \u00e9crit.  </li> </ul> <p></p>"},{"location":"Tests/1-Tests/#test-structurel","title":"Test structurel","text":"<ul> <li>Utiliser la structure du code pour d\u00e9river des cas de tests.  </li> <li>Compl\u00e9mentaire des tests fonctionnels car on \u00e9tudie la r\u00e9alisation et  pas seulement la sp\u00e9cification.  </li> <li>Il y a deux m\u00e9thodes :  <ul> <li>\\(\\color{red}\\text{\u00c0 partir du }\\textit{graphe de flot de contr\u00f4le}\\) \\(\\color{red}\\text{ : couverture de toutes les  instructions, tous les branchements...}\\) (CPGE)  </li> <li>\u00c0 partir du graphe de flot de donn\u00e9es : couverture de toutes les  utilisations d'une variable, de tous les couples d\u00e9finition-utilisation...  </li> </ul> </li> </ul>"},{"location":"Tests/1-Tests/#graphe-de-flot-de-controle","title":"Graphe de flot de contr\u00f4le","text":"<p>Graphe simple orient\u00e9 connexe avec un sommet initial (ou d'entr\u00e9e) <code>E</code> et un sommet de sortie <code>S</code> accessible depuis <code>E</code>.</p> <ul> <li>Un sommet interne est  <ul> <li>Soit un bloc d'instructions \u00e9l\u00e9mentaires (on regroupe les s\u00e9quences).  </li> <li>Soit un sommet de d\u00e9cision \u00e9tiquet\u00e9 par un test.  </li> </ul> </li> <li>Il y a deux sortes d'arcs :  <ul> <li>Les arcs de sortie de blocs d'instructions : ils repr\u00e9sentent le passage  d'un bloc d'instructions \u00e0 une instruction conditionnelle ou \u00e0 un autre  bloc d'instruction. Il ne sont pas \u00e9tiquet\u00e9s.  </li> <li>Les arcs de d\u00e9cision : ce sont les arcs de sortie des sommets de d\u00e9cision.  Ils sont \u00e9tiquet\u00e9s par les r\u00e9ponses aux tests des expressions  conditionnelles.  </li> </ul> </li> </ul> <p>Il y a un seul arc de sortie d'un sommet bloc d'instructions. Et, le plus  souvent, deux arcs de sortie (dits arcs de d\u00e9cision) des sommets de d\u00e9cision correspondant aux valeurs positives ou n\u00e9gatives des conditions.  </p>"},{"location":"Tests/1-Tests/#exemple-calcul-de-xn","title":"Exemple : calcul de \\(X^n\\)","text":"<pre><code>float power (float x, int n){\n    int p = n ; float s = 1.;\n    while(p&gt;=l){\n        s=s*x;\n        p=p-1;\n    }\n    return s;\n}\n</code></pre>"},{"location":"Tests/1-Tests/#exemple-des-triangles","title":"Exemple des triangles","text":"<pre><code>void triangle (int j, int k, int l) {\n    // j, k, l : les 3 c\u00f4t\u00e9s d'un triangle\n    // indique si le triangle est quelconque,\n    // isoc\u00e8le ou \u00e9quilat\u00e9ral\n    int n = 0; // n pour 'nature du triangle\n    if (j+k&lt;=l || k+l &lt;= j || l+j &lt;= k) {\n        printf(\"pas un triangle\");\n    } else {\n        if (j==k) n = n+1;\n        if (j==l) n = n+1;\n        if (l==k) n = n+1;\n        if (n==0)\n            printf(\"quelconque\");\n        else if (n==1)\n            printf(\"isoc\u00e8le\");\n        else\n            printf(\"\u00e9quilat\u00e9ral\");\n    }\n}\n</code></pre> <p>Avec \\(T\\) pour True et \\(F\\) pour False</p>"},{"location":"Tests/1-Tests/#chemin-faisable","title":"Chemin faisable","text":"<p>Un chemin de contr\u00f4le est une suite \\(x_0, x_1, . . . , x_n\\) de sommets tels que \\(x_0 = E\\) , \\(x_n = S\\) et \\((x_i , x_{i+1})\\) est un arc pour tout \\(i &lt; n\\).  </p> <p>Un chemin est dit faisable si il existe un ensemble de conditions sur les variables d'entr\u00e9es permettant de passer par tous les sommets de ce chemin.</p> <p>Si un chemin n'est pas faisable, il est dit infaisable. La recherche de infaisable est ind\u00e9cidable : on ne sait pas en entr\u00e9e un GFC quelconque, dire dans tous les cas s'il existe un chemin infaisable.</p> Exemple des triangles <p><p></p> Figure - Chemin faisable <p></p> Figure - Chemin infaisable</p>"},{"location":"Tests/1-Tests/#condition-dun-chemin","title":"Condition d'un chemin","text":"<p>La condition d'un chemin est la conjonction de tous les sommets de d\u00e9cision portant sur les entr\u00e9es que traverse ce chemin.  </p> <p>Exemple : avec \\(j = 3, k = 5, l = 3\\), la condition du chemin vert  parcouru est  </p> \\[\u00ac(j +k \u2264 l \u2228k +l \u2264 j \u2228j +l \u2264 k)\u2227j \\neq k \u2227 j = l \u2227 l \\neq k \u2227 n \\neq 0 \u2227 n = 1\\] <p>La condition du chemin rouge est  </p> \\[\u00ac(j + k \u2264 l \u2228 k + l \u2264 j \u2228 j + l \u2264 k) \u2227 j \\neq k \u2227 j \\neq l \u2227 l \\neq k \u2227 n \\neq 0 \u2227 n \\neq 1\\] <p>Or  </p> \\[\u00ac(j + k \u2264 l \u2228 k + l \u2264 j \u2228 j + l \u2264 k) \u2227 j \\neq k \u2227 j \\neq l \u2227 l \\neq k \\Rightarrow n = 0\\] <p>Et donc la condition du chemin rouge est  </p> \\[\u00ac(j +k \u2264 l \u2228k +l \u2264 j \u2228j +l \u2264 k)\u2227j \\neq k \u2227j \\neq l \u2227l \\neq k \u2227 {\\color{red}0\\neq 0} \u2227 0 \\neq 1\\] <p>Cette formule est une antilogie : le chemin est rouge est infaisable.  </p>"},{"location":"Tests/1-Tests/#suite-de-syracuse","title":"Suite de Syracuse","text":"<pre><code>void syracuse(int x) {\n    // on ne consid\u00e8re que des entiers &gt; 0\n    while (x!=1){\n        if (x%2==0)\n            x=x/2;\n        else\n            x=3*x+1;\n    }\n    printf(\" fini\\n\");\n</code></pre> <p>La conjecture veut que au bout d'un moment \\(x = 1\\).  </p> <p></p> <p>On ne sait pas s'il existe des chemins infaisables de \\(E\\) \u00e0 \\(S\\).  </p>"},{"location":"Tests/1-Tests/#syracuse-la-discipline-de-test-dt-x2-sensibilise-le-chemin-c","title":"Syracuse : La discipline de test (DT) \\(x=2\\) sensibilise le chemin \\(C\\)","text":"<p>Etant donn\u00e9 un chemin faisable, on sait trouver les conditions pour le  parcourir.</p> <p></p> <ul> <li> <p>soit le chemin \\(C\\) : \\(E\\), \\(\\begin{matrix}  x &amp; \u2260 &amp; 1 \\\\  x\\text{ \\% } 2 &amp; == &amp; 0 \\\\  x &amp; = &amp; \\frac{x}{2} \\\\  x &amp; \u2260 &amp; 1, S \\end{matrix}\\)</p> </li> <li> <p>Quelle condition le v\u00e9rifie ?  </p> </li> <li> <p>Celle-ci : \\(\\begin{matrix} x &amp; \u22601 &amp;  \\\\ x\\text{ mod } 2 &amp; =0 &amp; \\text{: x est pair}  \\\\ \\frac{x}{2} &amp; = 1 &amp; \\end{matrix}\\)</p> </li> </ul> <p>On trouve \\(x = 2\\).  </p>"},{"location":"Tests/1-Tests/#critere-de-couverture","title":"Crit\u00e8re de couverture","text":"<p>On appelle crit\u00e8re de couverture une condition d\u00e9finissant un  ensemble de chemins du graphe de flot de contr\u00f4le.  </p> <p>G\u00e9n\u00e9ration de tests gr\u00e2ce \u00e0 un crit\u00e8re de couverture :  </p> <ul> <li>S\u00e9lectionner un ensemble minimal de chemins satisfaisant le crit\u00e8re.  </li> <li>Eliminer les chemins infaisables  </li> <li>Pour chaque chemin faisable, on d\u00e9finit un ensemble de conditions associ\u00e9es sur les entr\u00e9es (c'est \u00e0 dire un objectif de test). \\(\\color{red}\\text{Par exemple : entr\u00e9e }x &gt; 0\\)</li> <li>Pour chaque objectif de test (donc pour chaque chemin faisable) choisir un cas de test (donc des valeurs d'entr\u00e9es satisfaisant la condition associ\u00e9e au chemin). \\(\\color{red}\\text{Par exemple : entr\u00e9e }x = 3\\)</li> </ul>"},{"location":"Tests/1-Tests/#critere-tous-les-sommets","title":"Crit\u00e8re \"tous les sommets\"","text":"<p>Crit\u00e8re atteint lorsque tous les sommets du graphe de contr\u00f4le sont  parcourus.  </p> <p>On d\u00e9finit le taux de couverture des sommets par  </p> \\[ \\tau_s = \\frac{\\text{nombre de sommets parcourus}}{\\text{nombre de sommets}}\\] <p>Exigence minimale pour la certification en a\u00e9ronautique (norme EUROCAE ED-12B) : \\(\\tau_s = 1\\).  </p> <p>Qualification niveau C : Un d\u00e9faut peut provoquer un probl\u00e8me majeur entra\u00eenant un dysfonctionnement des \u00e9quipements vitaux de l'appareil.  </p> <pre><code>int somme (int x, int y){\n    int s = 0;\n    if (x==0) s=x;\n    else s=x+y;\n    return s;\n}\n</code></pre> <p>Il y a deux chemins. L'un d'eux permet de d\u00e9tecter le d\u00e9faut.  </p> <p></p> <p>Le chemin \\(E\\) ; \\(int\\) \\(s=0\\) ; \\(x==0\\) ; \\(s=x\\) ; \\(return\\) \\(s\\) ; \\(S\\) est associ\u00e9e \u00e0 la condition \\(x = 0\\)  satisfaite par les entr\u00e9es  \\(x = 0\\), \\(y = 6\\). Cela permet de d\u00e9tecter le d\u00e9faut.  </p>"},{"location":"Tests/1-Tests/#limite-du-critere-tous-les-sommets","title":"Limite du crit\u00e8re \"tous les sommets\"","text":"<pre><code>float div(float x){\n    float r;\n    if (x!=0) \n        r=1.;\n    r = 1/x;\n    return r;\n}\n</code></pre> <p>Le chemin \\(E\\) ; \\(int\\) \\(r\\) ; \\(x\u22600\\) ; \\(r=1\\) ; \\(return\\) \\(r\\); \\(S\\)  (associ\u00e9 \u00e0 \\(x = 2\\)) couvre bien tous les sommets mais la division par z\u00e9ro n'est pas d\u00e9tect\u00e9e.  </p>"},{"location":"Tests/1-Tests/#critere-tous-les-arcs","title":"Crit\u00e8re \"Tous les arcs\"","text":"<p>Dit aussi crit\u00e8re \"toutes les d\u00e9cisions\".  </p> <p>Pour chaque d\u00e9cision, un test rend la d\u00e9cision vraie, un autre la rend  fausse.  </p> <p>Taux de courverture des arcs :</p> \\[\\tau_a = \\frac{\\text{nombre d'arcs parcourus}}{\\text{nombre d'arcs}}\\] <p>Norme DO 178B, qualification des syst\u00e8mes embarqu\u00e9s au niveau B :  un d\u00e9faut peut provoquer un probl\u00e8me dangereux</p> <p>Crit\u00e8re \"Tous-les-arcs\" entra\u00eene crit\u00e8re \"Tous-les-sommets\".(puisque le graphe est connexe, chaque sommet est adjacent \u00e0 un arc au moins).</p>"},{"location":"Tests/1-Tests/#limite-du-critere-tous-les-arcs","title":"Limite du crit\u00e8re tous les arcs","text":"<pre><code>float F(int a, int b){\n    int r;\n    if (a!=0 || a==b) \n        r=1/a;\n    else \n        r=0;\n    return r;\n}\n</code></pre> <p>Crit\u00e8re Toutes-les-D\u00e9cisions  satisfait avec \\(\\{a = 0,b = 1\\}\\) \\(et\\) \\(\\{a = 2, b = 1\\}\\).  </p> <p>Pourtant, division par z\u00e9ro non d\u00e9tect\u00e9e avec \\(\\{a = 0,b = 0\\}\\).  </p>"},{"location":"Tests/1-Tests/#decomposer-les-conditionnelles","title":"D\u00e9composer les conditionnelles","text":""},{"location":"Tests/1-Tests/#toutes-les-conditions-multiples","title":"Toutes les conditions multiples","text":"<p>On a vu que le crit\u00e8re \"tous les arcs\" pouvait passer \u00e0 c\u00f4t\u00e9  d'erreurs.  </p> <p>C'est parce que ce crit\u00e8re est satisfait pour un sommet de d\u00e9cision  avec seulement deux jeux d'entr\u00e9es : un jeu d'entr\u00e9es rendant la  d\u00e9cision vraie et un autre la rendant fausse.  </p> <p>Plut\u00f4t que la consid\u00e9rer la d\u00e9cision comme un seul sommet du graphe  de contr\u00f4le, on introduit les sous-decisions comme nouveaux sommets.  </p> <p>Ce crit\u00e8re est appel\u00e9 \"toutes les conditions multiples\"  </p> <p>Le crit\u00e8re  Toutes-les-d\u00e9cisions  n'est plus satisfait  avec seulement \\(\\{a = 0,b = 1\\}\\) \\(et\\) \\(\\{a = 2, b = 1\\}\\).  </p> <p>Le crit\u00e8re  Toutes-les-d\u00e9cisions  est satisfait avec  \\(\\{a = 0,b = 1\\}\\) \\(et\\) \\(\\{a = 2, b = 1\\}\\) \\(et\\) \\(\\{a = 2, b = 2\\}\\) et enfin \\(\\{a = 0,b = 0\\}\\). Division par z\u00e9ro d\u00e9tect\u00e9e.  </p> <p><p></p></p> <p>Le graphe simple devient un  multigraphe (deux arcs sortant  du \\(a==b\\) de gauche vers \\(\\frac{1}{a}\\) ).  </p>"},{"location":"Tests/1-Tests/#critere-toutes-les-decisions-multiples-explosion-combinatoire","title":"Crit\u00e8re \"Toutes les d\u00e9cisions multiples\" : Explosion combinatoire","text":"<p>Exemple <code>if (A &amp;&amp; (B || C))</code></p> <p>Toutes-les-conditions  </p> \\[\\begin{array}{|c c c | c |} A &amp; B &amp; C &amp; \\text{D\u00e9cision} \\\\ \\hline 0 &amp; 1 &amp; 1 &amp; 0 \\\\ 1 &amp; 1 &amp; 1 &amp; 1 \\\\ \\end{array}\\] <p>Toutes-les-conditions-multiples</p> \\[\\begin{array}{|c c c | c |} A &amp; B &amp; C &amp; \\text{D\u00e9cision} \\\\ \\hline 1 &amp; 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 1 &amp; 0 &amp; 1 \\\\ 1 &amp; 0 &amp; 1 &amp; 1 \\\\ 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; 1 &amp; 1 &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 0 \\\\ \\end{array}\\] <p>\\(2^{\\text{nb de variables }}\\): Comment limiter la  combinatoire ?  </p>"},{"location":"Tests/1-Tests/#critere-toutes-les-conditionsdecisions-modifie-mcdc","title":"Crit\u00e8re Toutes-les-Conditions/D\u00e9cisions-modifi\u00e9 : MC/DC","text":"<p>Objectif : am\u00e9liorer les crit\u00e8res de couverture bas\u00e9s sur les d\u00e9cisions  tout en contr\u00f4lant la combinatoire  </p> <p>D\u00e9finition: Crit\u00e8re MC/DC</p> <p>MC/DC : Modified Condition/Decision Coverage</p> <p>On ne s'int\u00e9resse \u00e0 un jeu de test faisant varier une condition que s'il  influe sur la d\u00e9cision.  </p>"},{"location":"Tests/1-Tests/#critere-mcdc","title":"Crit\u00e8re MC/DC","text":"<p>Exemple <code>if (A &amp;&amp; (B || C))</code></p> <p>Principe : pour chaque test atomique, trouver deux cas de tests qui  changent la d\u00e9cision lorsque les autres conditions sont fix\u00e9es.  </p> <ul> <li>Pour \\(A\\) :  <ul> <li>\\(A = 0\\) , \\(B = 1\\) , \\(C = 1\\). D\u00e9cision : \\(0\\) </li> <li>\\(A = 1\\) , \\(B = 1\\) , \\(C = 1\\). D\u00e9cision : \\(1\\) </li> </ul> </li> <li>Pour \\(B\\) :  <ul> <li>\\(A = 1\\) , \\(B = 0\\) , \\(C = 0.\\) D\u00e9cision : \\(0\\) </li> <li>\\(A = 1\\) , \\(B = 1\\) , \\(C = 0.\\) D\u00e9cision : \\(1\\) </li> </ul> </li> <li>Pour \\(C\\) :  <ul> <li>\\(A = 1\\) , \\(B = 0\\) , \\(C = 1.\\) D\u00e9cision : \\(1\\) </li> <li>\\(\\color{red}A = 1 \\text{ , } B = 0 \\text{ , } C = 0. \\text{ D\u00e9cision : 0. D\u00e9j\u00e0 couvert}\\).  </li> </ul> </li> </ul> <p>Si \\(n\\) conditions : crit\u00e8re \\(MC/DC\\) entra\u00eene au plus \\(2 \u00d7 n\\) tests contre \\(2^n\\) pour le crit\u00e8re Toutes-les-d\u00e9cisions-multiple.  </p>"},{"location":"Tests/1-Tests/#limite-du-critere-toutes-les-decisions-multiples","title":"Limite du crit\u00e8re Toutes-les-d\u00e9cisions-multiples","text":"<pre><code>float invsum(int n, float a[]){\n    int i = 0;\n    float s = 0;\n    while(i&lt;n){\n        s = s+a[i];\n        i++;\n    }\n    return 1/s;\n}\n</code></pre> <p>Toutes-les-d\u00e9cisions \\(=\\) toutes-les-d\u00e9cisions-multiples puisque test atomique.</p> <p></p> <p>\\(\\color{red}\\textbf{E,B1,C1,B2,C1,ret. }\\frac 1 s\\textbf{ , S}\\text{ couvre toutes les d\u00e9cisions.}\\) \\(\\color{red}\\text{Satisfait par } n = 1,  a = \\{2., 3., 5.\\}.\\) \\(\\color{red}\\text{D\u00e9faut non  d\u00e9tect\u00e9 si le tableau est vide.}\\)</p>"},{"location":"Tests/1-Tests/#critere-tous-les-chemins","title":"Crit\u00e8re \"tous les chemins\"","text":"<p>D\u00e9finition: Crit\u00e8re Tous-les-chemins</p> <p>Parcourir tous les arcs dans chaque configuration possible (et non pas au moins une fois comme dans le  crit\u00e8re toutes-les-d\u00e9cisions)  </p> <p>Impraticable d\u00e8s qu'il y a des boucles car existence de chemins infinis.  </p> <p>A\ufb00aiblissement possible : \"tous les chemins qui passent au plus \\(k\\) fois dans les boucles\"</p> <p>En pratique on se limite souvent aux cas \\(k = 1\\) ou \\(k = 2\\). Cela permet au moins de d\u00e9tecter les erreurs produites quand on ne rentre pas dans la/les boucle.s.  </p> <p>Dans l'exemple pr\u00e9c\u00e9dent, \\(n = 1\\), \\(a = \\{\\}\\) satisfait le chemin  \\(\\textbf{E,B1,C1,ret. }\\frac 1 s\\textbf{ , S}\\) et d\u00e9tecte la division par z\u00e9ro.  </p>"},{"location":"Tests/1-Tests/#hierarchie-des-criteres","title":"Hi\u00e9rarchie des crit\u00e8res","text":""},{"location":"Tests/1-Tests/#convention-de-notation-algebrique","title":"Convention de notation alg\u00e9brique","text":"<ul> <li>\\(\u03b5\\) pour \"chemin vide\"  </li> <li>\\(A \u00b7 B\\) ou \\(AB\\) pour \"\\(A\\) suivi de \\(B\\)\"  </li> <li>\\((CB)^3\\) pour \"\\(CBCBCB\\)\"  </li> <li>\\(A + B\\) pour \"\\(A ou B\\)\"  </li> <li>\\(A^{+}\\) pour \"\\(A + A^2 + A^3 + \u00b7 \u00b7 \u00b7 + A^n + . . .\\)\"  </li> <li>\\(A^{\u2217}\\) pour \"\\(\u03b5 + A + A^2 + A^3 + \u00b7 \u00b7 \u00b7 + A^n + . . .\\)\"  </li> <li>\\(A^{\\underline{4}}\\) pour \\(\u03b5 + A + A^2 + A^3 + A^4\\)</li> </ul>"},{"location":"Tests/1-Tests/#expression-des-chemins-sous-forme-algebrique","title":"Expression des chemins sous forme alg\u00e9brique","text":"<pre><code>void F(int x){\n    if (x &lt;= 0)\n        x = -x;\n    else\n        x = 1 + x;\n\n    if (x==1)\n        x=1-x;\n    else\n        x=1;\n    return x;\n}\n</code></pre> <ul> <li>Les chemins de contr\u00f4le possibles sont d\u00e9crits par</li> </ul> \\[IA(B+C)D(E+F)GO\\] <ul> <li>Le nombre de chemins de contr\u00f4le possible est \\(1 \u00b7 1 \u00b7(1+1)\u00b7 1 \u00b7(1+1)\u00b7 1 = 4\\)</li> </ul>"},{"location":"Textes/1-Textes/","title":"Recherche dans un texte","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d'\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> Sommaire <p>Rappel de l'algorithme na\u00eff Algorithme de Boyer-Moore  </p> <ul> <li>Boyer-Moore-Horspool</li> </ul> <p>Algorithme de Rabin-Karp</p> <p>Cr\u00e9dits</p> <p>Pour Boyer-Moore :</p> <ul> <li>Wikipedia</li> <li>Un cours de Marc de Falco</li> <li>Cette vid\u00e9o de Ben Langmead</li> </ul> <p>Pour Rabin-Karp : Informatique -Cours et exercices corrig\u00e9s- (MP2I-MPI) (ellipse)  </p>"},{"location":"Textes/1-Textes/#introduction","title":"Introduction","text":""},{"location":"Textes/1-Textes/#principe-de-la-recherche","title":"Principe de la recherche","text":"<ul> <li>Soit un texte \u00e9crit dans l'alphabet \\(\u03a3\\)</li> <li>Soit un autre texte (plus court) \u00e9crit dans le m\u00eame alphabet : le motif  </li> <li>On cherche le motif dans le texte et, en cas de pr\u00e9sence constat\u00e9e, on  retourne la position de la premi\u00e8re lettre de la premi\u00e8re occurence du  motif dans le texte.  </li> <li>Nous dirons que le motif est pr\u00e9sent \u00e0 la position \\(i\\) si la lettre \\(i\\) du  texte est \u00e9gale \u00e0 la lettre \\(0\\) du motif, la lettre \\(i+1\\) du texte est \u00e9gale \u00e0 la lettre \\(1\\) du motif et ainsi de suite jusqu'\u00e0 la derni\u00e8re lettre du motif.  </li> </ul>"},{"location":"Textes/1-Textes/#difference-avec-la-recherche-de-sous-tableau-dans-un-tableau","title":"Di\ufb00\u00e9rence avec la recherche de sous-tableau dans un  tableau","text":"<ul> <li>Le nombre de caract\u00e8res dans l'alphabet est en g\u00e9n\u00e9ral n\u00e9gligeable  devant celle du texte explor\u00e9  </li> <li>Cette propri\u00e9t\u00e9 am\u00e8ne des optimisations inapplicables dans un  contexte de tableau contenant un grand nombre de symboles  di\ufb00\u00e9rents.  </li> </ul>"},{"location":"Textes/1-Textes/#rappel-de-lalgorithme-naif","title":"Rappel de l'algorithme na\u00eff","text":""},{"location":"Textes/1-Textes/#conventions","title":"Conventions","text":"<ul> <li>Soit \\(s\\) le texte et \\(m\\) le motif, \\(|s|\\) et \\(|m|\\) leurs longueurs. Soient \\(k\\), \\(r\\)  dans \\([\\![ 0,\\left |\\textsf s  \\right | ]\\!]\\). Les lettres sont num\u00e9rot\u00e9es \u00e0 partir de \\(0\\).</li> <li>On applique les notation de slicing Python :  </li> <li>\\(s[i]\\) est la lettre en position \\(i\\)</li> <li>\\(s[\u22121]\\) : derni\u00e8re lettre de \\(s\\) (comprendre \\(s[|s| \u2212 1]\\)).</li> <li>\\(s[\u2212k]\\) : \\(k-i\u00e8me\\) lettre de \\(s\\) en partant de la fin (comprendre \\(s[|s| \u2212 k]\\)).</li> <li>\\(s[k : r]\\) est la sous-cha\u00eene de \\(s\\) qui contient les lettres de la position \\(k\\) \u00e0 \\(r\u22121\\). C'est la cha\u00eene vide si \\(r \u2264 k\\)</li> <li>\\(s[: r]\\) est le pr\u00e9fixe de longueur \\(r\\) de \\(s\\) (lettres \\(0\\) \u00e0 \\(r \u2212 1\\)).</li> <li>\\(s[: \u2212k]\\) est la sous-cha\u00eene qui ne contient pas les \\(k\\) derni\u00e8res lettres.  Longueur \\(|s| \u2212 k\\).</li> <li>\\(s[k :]\\) est le suffixe de \\(s\\) qui commence \u00e0 la position \\(k\\) (toutes les lettres  de \\(s[k]\\) incluse \u00e0 la fin). C'est un mot de longueur \\(|s| \u2212 k\\).  </li> </ul>"},{"location":"Textes/1-Textes/#principe","title":"Principe","text":"<ul> <li>On parcourt toutes les positions de \\(s[: \u2212(|m| \u22121)]\\) et on fait glisser le  motif de une case \u00e0 chaque \u00e9tape (on s'arr\u00eate d\u00e8s que le motif  \"d\u00e9passe\" du texte).</li> <li>Pour la position \\(i\\), on regarde si le motif est pr\u00e9sent \u00e0 partir de cette  position :  </li> <li>Pour une position \\(k\\) dans le motif</li> <li>La lettre \\(s[i + k]\\) dans le texte doit \u00eatre \u00e9gale \u00e0 la lettre \\(m[k]\\) dans le  motif</li> <li>Si c'est le cas on passe \u00e0 la position suivante dans le motif et le texte.</li> <li>Sinon, le motif n'est pas pr\u00e9sent en position \\(i\\), on recommence la  recherche \u00e0 la position \\(i+1\\).  </li> </ul>"},{"location":"Textes/1-Textes/#code","title":"Code","text":"<pre><code>int recherche_naive ( const char *m , const char * s ){  \n   int n = strlen ( s ) ; \n   int p = strlen ( m ) ;  \n   for ( int i = 0; i &lt;= n - p ; i ++) {  \n      int j ;  \n      for ( j = 0; j &lt; p ; j ++) {  \n         if ( s [ i + j ] != m [ j ]) \n         break ; // pas la peine de continuer  \n      } // for j  \n      if ( j == p )  \n         return i ; // motif en pos . i  \n   }  // for i  \n   return -1; // motif absent  \n}\n</code></pre>"},{"location":"Textes/1-Textes/#complexite-au-pire","title":"Complexit\u00e9 au pire","text":"<p>La complexit\u00e9 au pire est obtenue lorsqu'on entre syst\u00e9matiquement dans  la seconde boucle et qu'on explore les lettres du motif presque jusqu'au  bout.</p> <ul> <li>\\(s = a^n\\) (\\(n\\) lettres) et \\(m = a^{p-1}b ~~\\)(\\(p\\) lettres)</li> <li>On explore les \\(p\\) lettres du motif pour chacune des \\(n \u2212 p + 1\\) premi\u00e8res lettres du texte.  </li> <li>Complexit\u00e9 au pire en \\(\\Theta((n+1 -p)p)~\\) Et \\(\\Theta(np)\\) (si \\(p &lt; \\frac{n}{2}\\) par exemple).  </li> </ul>"},{"location":"Textes/1-Textes/#complexite","title":"Complexit\u00e9","text":"<ul> <li>Souvent, au bout d'une ou deux comparaisons, on peut invalider la  position et passer \u00e0 la suivante.  </li> <li>Si le motif est pr\u00e9sent \u00e0 la fin du texte, on a une complexit\u00e9 en  \\(O(n+p)\\) (o\u00f9 \\(p\\) comparaisons sont n\u00e9cessaires pour v\u00e9rifier une \u00e0 une  les lettres du motif).  </li> <li>\\(O(n+p) = O(n)\\) si \\(p \u2264 n\\).  </li> </ul>"},{"location":"Textes/1-Textes/#algorithme-de-boyer-moore","title":"Algorithme de Boyer-Moore","text":""},{"location":"Textes/1-Textes/#boyer-moore-horspool","title":"Boyer-Moore-Horspool","text":""},{"location":"Textes/1-Textes/#principe-de-lalgorithme","title":"Principe de l'algorithme","text":"<ul> <li>On parcourt le texte \\(s\\) du d\u00e9but \u00e0 la fin mais on e\ufb00ectue parfois un  d\u00e9calage d\u00e9pendant de la premi\u00e8re comparaison n\u00e9gative (ce qui fait  gagner du temps).  </li> <li>Le motif \\(m\\) est recherch\u00e9 en commen\u00e7ant par la fin : on teste la  pr\u00e9sence de suffixes du motif de plus en plus gros. \\(\\color{red}\\text{C'est le contraire de la m\u00e9thode na\u00efve ou le motif}\\) \\(\\color{red}\\text{est recherch\u00e9 en faisant grossir ses pr\u00e9fixes.}\\)</li> <li> <p>L'algorithme utilise un pr\u00e9-traitement du motif afin de calculer le saut maximum \u00e0 e\ufb00ectuer apr\u00e8s avoir trouv\u00e9 une non-concordance.  </p> </li> <li> <p>Exploration de la lettre \\(i\\) de \\(s\\) : on se demande si ce n'est pas la  premi\u00e8re lettre de \\(m\\).</p> </li> <li>On se place donc en position \\(i + |m| \u2212 1\\) de \\(s\\)(donc \u00e0 droite de \\(i\\)). On  explore les positions \\(i + |m| \u2212 1\\), \\(i + |m| \u2212 2\\) . . . dans le texte en comparant avec les positions \\(\u22121\\), \\(\u22122\\) etc.. du motif. On esp\u00e8re arriver sans encombre \u00e0 la lettre \\(i\\).</li> <li>Si on arrive sans erreur \u00e0 la position \\(i\\) : on a trouv\u00e9 le motif.</li> <li>Sinon, on a trouv\u00e9 un suffixe \\(xm'\\) de \\(s[: i+ |m|]\\) (\\(s\\) tronqu\u00e9 \u00e0 \\(i + |m| \u2212 1\\)) tel que \\(m'\\) est un suffixe propre de \\(m\\) et pas \\(xm'\\)<ul> <li>Si \\(x\\) n'est pas pr\u00e9sent dans \\(m\\), on reprend la recherche juste apr\u00e8s \\(x\\) (pas la peine de perdre son temps \u00e0 placer le motif avant le \\(x\\) du texte)</li> <li>si \\(x\\) est pr\u00e9sent, on aligne le \\(x\\) de \\(m\\) le plus \u00e0 droite et le \\(x\\) de \\(s\\)</li> </ul> </li> </ul>"},{"location":"Textes/1-Textes/#regle-du-mauvais-caractere-exemple","title":"R\u00e8gle du mauvais caract\u00e8re : exemple","text":"<p>On cherche <code>string</code> \\((m)\\) dans le texte <code>stupid_spring_string</code> \\((s)\\).  </p> <ul> <li>D\u00e9marrage en position \\(0\\) de \\(s\\). d et g ne correspondent pas en position \\(5\\) et il n'y a aucun d dans le motif. On passe \u00e0 la position suivante \\(0 + |m|\\) de \\(s\\).  </li> <li> <p>Poursuite en position \\(6\\) de \\(s\\) :     Le n et le g ne correspondent pas. Mais \\(1\\) cran \u00e0 gauche de g, il y a  un n dans le motif. On aligne donc le n du motif avec celui du texte.  </p> </li> <li> <p>Poursuite en position \\(6 + 1\\) de \\(s\\) :        Correspondance de \\(4\\) lettres. Mais p ne figure pas dans le motif. On d\u00e9cale le motif APR\u00c8S ce p, donc de \\(2\\) positions. etc..  </p> </li> </ul>"},{"location":"Textes/1-Textes/#table-des-sautsoccurences-a-droite","title":"Table des sauts/occurences \u00e0 droite","text":"<p>On veut chercher le motif abaa. Voici sa table des occurrences \u00e0 droite : occurrence la plus \u00e0 droite :</p> <p>Table des occurences \u00e0 droite</p> <p>\\(\\begin{matrix} \\text{Lettre} &amp; \\text{occurence la plus \u00e0 droite} &amp; \\text{saut max}\\\\  &amp; &amp; \\\\ a&amp; 2 \\text{ (on ne tient pas compte du dernier a)} &amp; 3-2\\\\ b&amp; 1 &amp; 3-1\\\\ &amp; &amp;  \\\\ \\text{Autres lettres}&amp; \\varnothing  &amp; |m|= 4\\\\ \\end{matrix}\\)</p> <p>On note \\(d_m(x)\\) l'occurrence la plus \u00e0 droite de \\(x\\) dans \\(m\\).  On veut chercher le motif abc. Voici sa table des occurrences \u00e0 droite :  </p> <p>Table des occurences \u00e0 droite</p> <p>\\(\\begin{matrix} \\text{Lettre} &amp; \\text{occurence la plus \u00e0 droite} &amp; \\text{saut max}\\\\  &amp;  &amp; \\\\ a&amp; 0 &amp; 2-0\\\\ b&amp; 1 &amp; 2-1\\\\  &amp; &amp;  \\\\ \\text{Autres lettres dont c}&amp; \\varnothing  &amp; |m|= 3\\\\ \\end{matrix}\\)</p> <p>Remarques</p> <p>Lorsque la derni\u00e8re lettre du motif \\((m[\u22121])\\) n'est pas pr\u00e9sente ailleurs dans \\(m\\) (comme dans abcd mais pas abcb), le saut pour \\(m[\u22121]\\) est de \\(|m|\\). Il y a autant de lignes que dans l'alphabet. On peut pr\u00e9f\u00e9rer utiliser  un dictionnaire, ce qui est \u00e9conome en espace si le motif contient  beaucoup moins de lettres que l'alphabet (songer \u00e0 l'UTF16 !)  </p>"},{"location":"Textes/1-Textes/#definition-des-variables-et-principe","title":"D\u00e9finition des variables et principe","text":"<p>\\(s\\) : texte, \\(m\\) : motif, \\(d_m\\) tableau des occurrences les plus \u00e0 droite.</p> <ul> <li>\\(i\\) est la position courante dans le texte (position \u00e0 laquelle on esp\u00e8re  trouver le premier caract\u00e8re du motif). \\(i \u2191\\) </li> <li>Le motif est plac\u00e9 sous la position \\(i\\) du texte.</li> <li>\\(j\\) est la position de la lettre courante du motif. \\(j \u2193\\). On compare \\(s[i + j]\\) et \\(m[j]\\) comme dans l'algo na\u00eff.  </li> <li>Si \\(s[i + j] = m[j]\\), j est d\u00e9cr\u00e9ment\u00e9 : c'est positif pour esp\u00e9rer trouver le motif.</li> <li>Si \\(s [i + j ] \u2260 m[j ]\\) et \\(s [i + j ] = y\\) , on am\u00e8ne la lettre \\(y\\) la plus \u00e0 droite du motif (si elle existe...) au dessous de la position \\(i + j\\) du texte. Ce d\u00e9placement peut s'effectuer en d\u00e9calant le motif vers la gauche (aucun int\u00e9r\u00eat) ou vers la droite (tr\u00e8s int\u00e9ressant).</li> </ul>"},{"location":"Textes/1-Textes/#comparaison-de-s-i-j-avec-mj","title":"Comparaison de \\(s [i + j]\\) avec \\(m[j]\\)","text":"<p>\\(s\\) : texte, \\(m\\) : motif, \\(d_m\\) tableau des occurrences les plus \u00e0 droite. Le motif a \u00e9t\u00e9 plac\u00e9 sous la position \\(i\\) du texte. Les lettres \\(j + 1,j + 2,...,|m|\u22121\\) du motif corespondent bien \u00e0 leurs homologues du texte. Supposons que \\(s[i + j] \u2260 m[j]\\) (sinon \\(j\\) est d\u00e9cr\u00e9ment\u00e9) :</p> <ul> <li>Si \\(d_m(s[i + j]) = \u2205\\), la recherche du motif ne sera pas satisfaite tant que ce caract\u00e8re \\(s[i + j]\\) sera pr\u00e9sent. On reprend la recherche en \\(i + j + 1\\) </li> <li>si \\(s[i + j]\\) est dans le motif et \\(d_m(s[i + j]) \u2265 j\\), cela signifie que \\(s[i + j]\\) est pr\u00e9sent plus \u00e0 droite que \\(j\\) dans le motif. Aligner cette occurrence ne permettrait pas d'avancer la recherche (cf figure 1). On reprend en \\(i + 1\\).  </li> <li>Si \\(d_m(s[i + j]) &lt; j\\), le caract\u00e8re \\(s[i + j]\\) est pr\u00e9sent dans le motif \u00e0 gauche de la position courante j. On \"aligne\" ce caract\u00e8re du motif avec celui du texte. \\(\\color{red}\\text{On reprend donc la recherche dans le texte en}\\) \\(\\color{red}i'\\) \\(\\color{red}\\text{tel que}\\) \\(\\color{red}i' + d_m(s[i + j]) = i + j.\\) \\(\\color{red}\\text{ Ainsi, la nouvelle position dans le texte est }\\) \\(\\color{red}i' = i + (j \u2212 d_m(s[i + j]))\\).  </li> </ul>"},{"location":"Textes/1-Textes/#figure-1-d_msi-j-j","title":"Figure 1 : \\(d_m(s[i + j]) \u2265 j\\)","text":"<p>\\(s[i + j]\\) est dans le motif et \\(d_m(s[i + j]) \u2265 j\\) (\\(dm(s[i + j])\\) est not\u00e9 \\(d\\)) :  </p> <p>Figure 1</p> <p>\\(\\begin{matrix} . &amp; . &amp; . &amp; . &amp; . &amp; i &amp; . &amp; . &amp; . &amp; (i+j) &amp;.  &amp; . &amp; . &amp; \\text{pos. txt} \\\\ &amp;   &amp;   &amp;   &amp;   &amp; a &amp;  &amp;  &amp;  &amp; y &amp;  &amp;  &amp;  &amp; \\text{texte}\\\\ &amp;  &amp;  &amp;  &amp;  &amp; ? &amp;  &amp;  &amp;  &amp; z &amp; y &amp;  &amp;  &amp; \\text{motif}\\\\ &amp;  &amp;  &amp;  &amp;  &amp;  &amp;  &amp;  &amp;  &amp; j &amp; d &amp;  &amp;  &amp; \\text{pos. motif} \\end{matrix}\\)</p> <p>D\u00e9caler le motif de \\(\u2212(d \u2212 j)\\) n'a pas d'int\u00e9r\u00eat car le point de d\u00e9part dans le texte serait alors en \\(i \u2212 d\\) qui a d\u00e9j\u00e0 \u00e9t\u00e9 inspect\u00e9 et invalid\u00e9 ! On se  place donc en \\(i + 1\\) : aucun gain par rapport \u00e0 l'algorithme na\u00eff.  </p>"},{"location":"Textes/1-Textes/#figure-2-0-d_msi-j-j","title":"Figure 2 : \\(0 \u2264 d_m(s[i + j]) &lt; j\\)","text":"<p>\\(d_m\\) : table des occurrences \u00e0 droite. Posons \\(d = d_m(s[i + j])\\).  </p> <p>Figure 2</p> <p>\\(\\begin{matrix} \\text{. . . .}&amp; i &amp; .&amp; . &amp; . &amp; . &amp; . &amp; . &amp; . &amp;(i+j) &amp; . &amp; . &amp; . &amp;: &amp; \\text{ pos. dans txt}\\\\ &amp;a&amp; &amp; &amp; &amp; &amp; &amp; &amp; &amp; y &amp; &amp; &amp; &amp;  : &amp; \\text{texte} \\\\ &amp;?&amp; &amp; &amp; &amp; &amp; y &amp; &amp; &amp; z &amp; &amp; &amp; x &amp;  : &amp; \\text{motif m} \\\\ &amp;&amp;&amp;&amp;&amp;&amp;&lt;-&amp;-&amp;-&amp;-&gt;&amp;&amp;&amp;&amp;&amp;\\text{(Aucun y dans m[d+1:])} \\\\ &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;\\text{j - d}&amp; \\\\ &amp;0&amp;&amp;&amp;&amp;&amp;d&amp;&amp;&amp;j&amp;&amp;&amp;(|m|-1)&amp; : &amp; \\text{pos. dans motif} \\\\ \\end{matrix}\\)</p> <p>Nouveau point de d\u00e9part en \\(i + j \u2212 d\\) (pour aligner les \\(y\\) ) :  </p> <p>Figure 2</p> <p>\\(\\begin{matrix} \\text{. . . .}&amp; i &amp; . &amp; . &amp; (i+j-d) &amp; . &amp; . &amp; . &amp; . &amp;(i+j) &amp; . &amp; . &amp; . &amp; . &amp; . &amp;: &amp; \\text{ pos. dans txt}\\\\ &amp; &amp; &amp; &amp; b &amp; &amp; &amp; &amp; &amp; y &amp; &amp; &amp; &amp; &amp; &amp;  : &amp; \\text{texte} \\\\ \\text{dec. = j-d}&amp; &amp; &amp; &amp; ? &amp; &amp; &amp; &amp; &amp; y &amp; u &amp; &amp; z &amp; &amp; x &amp; : &amp; \\text{motif good} \\\\ \\text{dec. &lt; j-d}&amp; &amp; &amp; ? &amp; &amp; &amp; &amp; &amp; y &amp; u &amp; &amp; z &amp; &amp; x &amp; &amp; : &amp; \\text{motif bad} \\\\ \\end{matrix}\\)</p> <p>Prendre un d\u00e9calage \\(&lt;j-d\\) est inutile am\u00e8ne une lettre \\(u \u2260 v\\)  sous \\(y\\) .  </p>"},{"location":"Textes/1-Textes/#terminaison-informelle","title":"Terminaison Informelle","text":"<p>Dans la boucle externe, \\(|s| \u2212 i\\) est strictement d\u00e9croissant et dans la  boucle interne, c'est \\(j\\) qui est strictement d\u00e9croissant. On en d\u00e9duit la terminaison  </p>"},{"location":"Textes/1-Textes/#correction-informelle","title":"Correction Informelle","text":"<p>Par rapport \u00e0 l'algo na\u00eff, on fait des sauts. Il suffit donc de s'assurer que les positions non explor\u00e9es du fait des  sauts ne conduisent pas \u00e0 une solution. Un saut de \\(1\\) case n'est pas int\u00e9ressant \u00e0 \u00e9tudier car il correspond \u00e0  l'algo na\u00eff. On s'int\u00e9resse au cas \\(i = 0\\) (pour simplifier) et \u00e0 un saut de \\(2\\) cases  au moins.  </p> <ul> <li> <p>Il existe \\(3\\) caract\u00e8res \\(x, y , z\\) (avec \\(y \u2260 z\\)) et des mots \\(m_1, m_2, m_3, s_1, s_2\\) (avec \\(|m| \u2265 1\\)) tels que \\(m = m_1  \\underbrace{y}_{pos. d_m(y) &lt;y} m_2 \\underbrace{z}_{pos. j} m_3x\\) et \\(s = s_1 \\underbrace{y}_{pos. 0 +j} m_3 s_2\\) et \\(y \u2209 m_2 z m_3\\)</p> </li> <li> <p>Un d\u00e9calage trop faible (donc inf\u00e9rieur \u00e0 \\(j \u2212 d_m(y ) \u2212 1\\)) am\u00e8ne une  lettre de \\(m_2\\) au niveau du \\(y\\) de \\(ym_3s_2\\). Or cette lettre de \\(m_2\\) est diff\u00e9rente de \\(y\\) (voir transparent figure 2). D'o\u00f9 l'inutilit\u00e9 de d\u00e9caler moins que \\(j \u2212 d_m(y )\\).  </p> </li> </ul>"},{"location":"Textes/1-Textes/#complexite-informelle","title":"Complexit\u00e9 informelle","text":"<p>\\(s\\) texte, \\(m\\) motif Si l'alphabet contient beaucoup de caract\u00e8res (par exemple UTF8),  on peut esp\u00e9rer que les motifs auront peu de r\u00e9p\u00e9titions. Chaque d\u00e9calage sera donc en gros de \\(|m|\\). En cas de recherche infructueuse, on e\ufb00ectue environ \\(\\frac{|s|}{|m|}\\) comparaisons.  </p> <p>Exemple le pire \\(m = ba^{p\u22121}\\) et \\(s = a^n\\). Il faut, avant de faire un d\u00e9calage, atteindre le \\(b\\), soit \\(p\\) comparaisons. Et le d\u00e9calage, obtenu en comparant \\(a\\) et \\(b\\), est alors de \\(1\\) (car \\(j = 0 &lt; p \u2212 1 = d_a\\)).  Comme pour l'algo na\u00eff, on a un nombre de comparaisons en \\(\u0398((n \u2212 p + 1)p) = \u0398(|m| \u00d7 (|s| - |m|)) = O(|m|\u00d7|s|)\\) </p>"},{"location":"Textes/1-Textes/#algorithme","title":"Algorithme \u2665","text":"<p>Listing 2 - Table des sauts</p> <pre><code>fonction derniereOccurence (m)\n    T := une table index\u00e9e par les lettres\n    /\u2217prendre plut\u00f4t un dictionnaire si gros alphabet \u2217/\n    pour toute lettre a\n        T[a] := \u22121 /\u2217 les char sont des entiers \u2217/\n    pour k = 0 \u00e0 |m| \u2212 2 /\u2217 |m| \u2212 2, Si! \u2217/\n        T[m[k]] := k\n    renvoyer  T\n</code></pre> <p>Listing 3 - Fonction principale</p> <pre><code>fonction rechercher_bmh (m, texte)\n    T := derniereOccurence(m)\n    i := 0 /\u2217position dans le texte : \u2217/\n           /\u2217on souhaite y trouver le motif \u2217/\n    tant que i + |m| \u2212 1 &lt; |texte|\n        j := |m| \u2212 1 /\u2217j : position dans le motif \u2217/\n                     /\u2217i + j : position courante dans le texte \u2217/\n        tant que texte [i + j] = m[j] et j &gt;= 0\n            j := j \u22121\n        si j &lt; 0\n            alors renvoyer i\n        d := T[texte[i + j]] /\u2217pos. la plus \u00e0 droite dans m \u2217/\n        si d &lt; 0 /\u2217texte[i + j] n'est pas dans motif [:\u22121] \u2217/\n            alors i := i + j + 1 /\u2217un cran apres pos. courante \u2217/\n        sinon \n            si d &gt;= j\n                alors i := i + 1 /\u2217pas mieux que na\u00eff \u2217/\n            sinon i := i + (j \u2212 d) /\u2217mieux que na\u00eff \u2217/ \n    renvoyer \u22121 /\u2217not found \u2217/\n</code></pre>"},{"location":"Textes/1-Textes/#boyer-moore-complet","title":"Boyer-Moore complet","text":"<p>L'algorithme de Boyer-Moore complet, plus d\u00e9licat que Boyer-Moore-Horspool, introduit une seconde table de sauts en plus de la table des derni\u00e8res occurrences. Conform\u00e9ment au programme, on peut s'abstenir de l'\u00e9tudier.  </p>"},{"location":"Textes/1-Textes/#algorithme-de-rabin-karp","title":"Algorithme de Rabin-Karp","text":""},{"location":"Textes/1-Textes/#presentation","title":"Pr\u00e9sentation","text":"<p>L'algorithme de Rabin-Karp ou Karp-Rabin est un algorithme de  recherche de sous-cha\u00eene cr\u00e9\u00e9 par Richard M. Karp et Michael O.Rabin (1987).</p> <p>Cette m\u00e9thode recherche un ensemble de motifs donn\u00e9s (c'est-\u00e0-dire des sous-cha\u00eenes) dans un texte gr\u00e2ce \u00e0 une fonction de hachage. On  ne compare donc pas directement le motif \u00e0 des sous-cha\u00eenes du texte  mais seulement leurs empreintes (le hache).</p> <p>L'algorithme n'est pas beaucoup employ\u00e9 pour les recherches d'une  unique sous-cha\u00eene mais a une importance th\u00e9orique et s'av\u00e8re tr\u00e8s  efficace pour des recherches de multiples sous-cha\u00eenes. (Wikipedia)  </p> <p>Dans toute la suite on prend \\(s\\) : texte ; \\(m\\) motif. Pour un mot \\(u\\), \\(u_k\\)  d\u00e9signe la lettre \\(k\\) de \\(u\\).  </p>"},{"location":"Textes/1-Textes/#utilisation-dune-fonction-de-hachage","title":"Utilisation d'une fonction de hachage","text":"<p>Rappel : \\(s[i: i+ |m|]\\) d\u00e9signe le facteur de \\(s\\) qui a la m\u00eame longueur que \\(m\\) et qui commence en position \\(i\\) de \\(s\\).</p> <ul> <li> <p>On se donne une fonction de hachage \\(h\\) sur les cha\u00eenes de caract\u00e8res  et on calcule une fois pour toute \\(h(m)\\).  </p> </li> <li> <p>Pour chaque position \\(0 \u2264 i \u2264 |s| \u2212 |m|\\) on calcule \\(h(s[i : i + |m|])\\).  </p> </li> <li>Si \\(h(m) \u2260 h(s[i : i + |m|])\\), on est certain que \\(m\\) n'est pas en position \\(i\\) dans le texte.  </li> <li>Si \\(h(m) = h(s[i : i + |m|])\\), comme \\(h\\) n'est pas injectif en g\u00e9n\u00e9ral, il est possible que \\(m\\) soit en position \\(i\\) dans le texte. Il faut alors comparer \\(m\\) et \\(s[i : i + |m|]\\) en force brute.  </li> </ul>"},{"location":"Textes/1-Textes/#choix-de-h","title":"Choix de h","text":"<p>Le calcul de \\(h(s[i : i + |m|])\\) se fait \u00e0 priori en \\(\u0398(|m|)\\). La s\u00e9quence  des calculs des haches des sous-cha\u00eenes de \\(s\\) a alors la m\u00eame complexit\u00e9 que la recherche na\u00efve, soit en \\(\u0398((|s| \u2212 |m| + 1) \u00d7 |m|)\\) (il  y a \\(|s| \u2212 |m| + 1\\) sous-cha\u00eenes de \\(s\\) de taille \\(|m|\\)).  </p> <p>D'o\u00f9 l'id\u00e9e de choisir \\(h\\) de fa\u00e7on \u00e0 ce que \\(h(s[i + 1 : i + 1 + |m|])\\)  s'obtienne \u00e0 partir de \\(h(s[i : i + |m|])\\) en temps constant.  </p> <p>Choisissons un entier \\(B\\) arbitraire et posons pour le mot  \\(u = u_0u_1 ... u_{|m|-1}\\) que  </p> <p>$$h(u) = \\sum_{0\u2264j&lt;|m|}{B^{|m|\u22121\u2212j} \u00d7 u_j } $$ Une telle fonction, polyn\u00f4miale, se calcule en \\(O(|m|)\\) par la m\u00e9thode de Horner. En C, un caract\u00e8re n'est rien d'autre qu'un nombre cod\u00e9 sur un octet d'o\u00f9 la validit\u00e9 du produit.</p> <p>Selon Wikipedia, cette fonction de hachage est appel\u00e9e empreinte de Rabin.  </p> <p>Appliqu\u00e9e au texte \\(s\\), et posant \\(|m| = M\\), on obtient :  </p> <p>\\(\\begin{matrix}  h(s_is_{i+1} ... s_{i+M})&amp; = &amp; \\sum_{j=0}^{M-1}{B^{M\u22121\u2212j} s_{i+j+1}} \\\\  &amp; &amp; &amp; \\\\  &amp; = &amp; s_{i+M}B^{M\u22121\u2212M+1} \u2212s_i B^M +B \u00d7 \\sum_{j=0}^{M-1}{B^{M-1-j}s_{i+j}} \\\\  &amp; &amp; &amp; \\\\  &amp; = &amp; s_{i+M} + B(h(s_i s_{i+1} ... s_{i+M\u22121}) \u2212 s_i B^{M\u22121}) \\end{matrix}\\)</p> <p>On peut donc calculer \\(h(s[i + 1 : i + 1 + M])\\) \u00e0 partir de \\(h(s[i : i + M])\\)  en temps constant : avec un pr\u00e9calcul (une fois pour toute) de \\(B^{M\u22121}\\), il faut faire une addition une soustraction et \\(2\\) produits.</p> <p>Il peut y avoir un over\ufb02ow. D'o\u00f9 la n\u00e9cessit\u00e9 de travailler modulo (il  est malin de prendre un grand nombre premier pour ce modulo).  </p>"},{"location":"Textes/1-Textes/#cas-dun-motif-unique","title":"Cas d'un motif unique","text":"<p>Listing 4 \u2013 Rabin-Karp : recherche d'un motif</p> <pre><code>fonction rabin_karp(T, M)\n    /* T : texte; M : motif; h : fonction de hachage roulant */\n    n : = longueur(T) /* strlen en C */\n    m := longueur(M)\n    hn := h(T[0 : |M|]) /* hache du debut de mot */\n    hm := h(M) /* hache du motif */\n    pour i = 0 ... n-m faire\n        si hn = hm \n            si T[i : i + |M|] = M\n                renvoyer i\n        hn := h(T[i + 1 : i + 1 + |M|]) /* O(1) si on ce d\u00e9brouille bien */\n    renvoyer TROP2LALOOSE\n</code></pre> <p>Si on veut toutes les occurrences du motif, on cr\u00e9e une liste initialement vide positions puis :  </p> <ul> <li>On remplace la ligne 10 par : ajouter \\(i\\) \u00e0 positions ;  </li> <li>La derni\u00e8re ligne devient :  renvoyer positions </li> </ul>"},{"location":"Textes/1-Textes/#complexite-de-la-recherche-de-toutes-les-positions","title":"Complexit\u00e9 de la recherche de toutes les positions","text":"<p>On pose \\(N = |s|\\) (texte) ; \\(M = |m|\\) (motif)  </p> <ul> <li>Dans le meilleur cas, les comparaisons des hach\u00e9s sont toujours n\u00e9gatives et on n'appelle jamais la fonction de comparaison de  cha\u00eenes de caract\u00e8res. Complexit\u00e9 au mieux en \\(O(N + M)\\) (\\(O(M)\\)  pour les deux hach\u00e9s initiaux -souvent \\(M \u2264 N\u2212\\)). Boyer-Moore  complet (non vu cette ann\u00e9e) peut faire encore mieux.  </li> <li>Le pire cas arrive quand le motif est pr\u00e9sent \u00e0 toutes les positions. Avec \\(s = a^N\\) et \\(m = a^M\\) , on doit faire une comparaisons de cha\u00eenes  de caract\u00e8res \u00e0 chaque position dans le texte. Complexit\u00e9 en  \\(O(N(N \u2212 M + 1))\\) comme pour l'algorithme na\u00eff.</li> </ul>"},{"location":"Textes/1-Textes/#cas-de-motifs-multiples","title":"Cas de motifs multiples","text":"<p>On cherche un ensemble de motifs, tous de longueur m</p> <p>Listing 5 \u2013 Rabin-Karp : recherche de plusieurs motifs <pre><code>fontction rabin_karp_ensemble(T, M, m)\n    /* T : texte ; M : ensemble de motif; m : lg d'un motif */\n    n := longueur(T) /* strlen en C */\n    Position := [] /* liste des position trouvees */\n    hn := hachhe(T[0 : m]) /* hache du debut du mot */\n    pour i = 0 ... n-m faire\n        si hn \u2208 hm et T[i : i+ 1 + m] \u2208 M\n            ajouter i a Positions\n        hn := hache(T[i : i+ 1 + m])\n    renvoyer Positions\n</code></pre></p> <p>Pas si efficace pour la recherche d'un motif unique, il faut privil\u00e9gier Rabin-Karp pour la recherche de plusieurs motifs.  </p>"},{"location":"Textes/2-Huffman/","title":"Algorithme de Huffman","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par F\u00e9lix qui continue le travail fait par Lorentzo et Elowan et Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Wikipedia</li> <li>Informatique -Cours et exercices corrig\u00e9s- (MP2I-MPI) (ellipse)</li> <li>Sujet Mines 2006 ; sujet info tronc commun Mines 2015</li> </ul>"},{"location":"Textes/2-Huffman/#introduction-de-nouvelles-notions","title":"Introduction de nouvelles notions","text":""},{"location":"Textes/2-Huffman/#compression","title":"Compression","text":"<p>Compression de donn\u00e9e : proc\u00e9d\u00e9 qui consiste \u00e0 r\u00e9duire l'espace occup\u00e9 par une information.</p> <p>La compression peut \u00eatre sans perte si \u00e0 partir de l'information compress\u00e9e on retrouve exactement l'information initiale. Dans le cas contraire (avec perte), l'information reconstruite doit \u00eatre \"proche\" (dans un sens \u00e0 d\u00e9finir) de l'information initiale.</p> <p>Le texte \u00e0 compresser est une suite de \\(N\\) caract\u00e8res ; le r\u00e9sultat de la compression est une suite de bits. On fait l'hypoth\u00e8se que chaque caract\u00e8re s'\u00e9crit sur \\(1\\) octet (code ASCII). Ce n'est pas le cas pour un encodage UTF-16.</p>"},{"location":"Textes/2-Huffman/#taux-de-compression","title":"Taux de compression","text":"<p>Le r\u00e9sultat de la compression des \\(N\\) caract\u00e8res est une suite de \\(C\\) bits.</p> <p>En pratique, il faut regrouper ces bits par paquets de huit pour former des octets (taille du byte en C), avec \u00e9ventuellement quelques bits de remplissage pour le dernier octet. Le r\u00e9sultat est \u00e9crit dans un fichier.</p> <p>Le taux de compression est le rapport \\(\u03c4 = \\frac{N}{\\frac{C}{8}} = \\frac{8N}{C}\\). L'\u00e9conomie d'espace est la diff\u00e9rence \\(E = 1 \u2212 \\frac{8N}{C}\\)</p> <p>Pour \u00e9viter la manipulation bit-\u00e0-bit, on triche un peu dans les codes propos\u00e9s : on consid\u00e8re des cha\u00eenes de caract\u00e8res '\\(0\\)' et '\\(1\\)'. Le code obtenu est alors \\(8\\) fois plus long qu'une s\u00e9quence de bits.</p>"},{"location":"Textes/2-Huffman/#presentation-de-lalgorithme","title":"Pr\u00e9sentation de l'algorithme","text":""},{"location":"Textes/2-Huffman/#presentation","title":"Pr\u00e9sentation","text":"<p>Le codage de Huffman est un algorithme de compression de donn\u00e9es sans perte (on peut compresser puis d\u00e9compresser et retrouver les valeurs initiales).</p> <p>Il utilise un code \u00e0 longueur variable pour repr\u00e9senter un symbole de la source (par exemple un caract\u00e8re dans un fichier).</p> <p>Le code est d\u00e9termin\u00e9 \u00e0 partir d'une estimation des fr\u00e9quences d'apparition des symboles de source, un code court \u00e9tant associ\u00e9 aux symboles de source les plus fr\u00e9quents.</p> <p>L'algorithme d\u00e9bute par une analyse fr\u00e9quentielle des caract\u00e8res d'un texte. Cet aspect n'est pas trait\u00e9 ici : nous supposons que cette analyse \u00e0 d\u00e9j\u00e0 \u00e9t\u00e9 effectu\u00e9e</p> <p>Un code de Huffman est optimal au sens de la plus courte longueur pour un codage par symbole, et une distribution de probabilit\u00e9 (une fr\u00e9quence) connue.</p> <p>Avec \" satisfaisant \", les caract\u00e8res 'a' et 's' apparaissent \\(3\\) fois, et 'f','n' \\(1\\) fois et 'i','t' \\(2\\) fois.</p> <p>On peut par exemple les coder sous la forme 'a'\\((01)\\) ; 's'\\((10)\\) ; 'f'\\((000)\\) ;'n'\\((001)\\) ;'i'\\((110)\\) ;'t'\\((111)\\). On obtient alors le codage suivant : \\(\\text{10 01 111 110 10 000 01 110 10 01 001 111}\\)</p> <p>Pour le d\u00e9codage, on remarque qu'aucun code n'est pr\u00e9fixe de l'autre.Cette propri\u00e9t\u00e9 est voulue : elle permet un d\u00e9codage sans ambigu\u00eft\u00e9 de \\(100111111010000011101001001111\\). On lit les bits de la cha\u00eene encod\u00e9e jusqu'\u00e0 reconna\u00eetre un code. Ce code n'\u00e9tant pr\u00e9fixe d'aucun autre, on \u00e9crit la lettre correspondante et on poursuit la lecture.</p> <p>Un code qui poss\u00e8de la propri\u00e9t\u00e9 qu'aucun mot n'est pr\u00e9fixe d'un autre est appel\u00e9 code pr\u00e9fixe.</p>"},{"location":"Textes/2-Huffman/#arbre-de-huffman","title":"Arbre de Huffman","text":"<p>Les encodages 'a'\\((01)\\) ; 's'\\((10)\\) ; 'f'\\((000)\\) ;'n'\\((001)\\) ;'i'\\((110)\\) ;'t'\\((111)\\). peuvent \u00eatre repr\u00e9sent\u00e9s par des chemins dans un arbre dont les feuilles sont les lettres du texte \u00e0 compresser.</p> <p>Chaque caract\u00e8re est associ\u00e9 au chemin qui l'atteint depuis la racine : \\(0\\) d\u00e9signe une descente \u00e0 gauche et \\(1\\), \u00e0 droite.</p> <p></p> <p>Code de 'n' \\(= 001\\) (\\(2\\) virages \u00e0 gauche, \\(1\\) \u00e0 droite). Chaque lettre du texte n'appara\u00eet qu'une fois dans l'arbre (m\u00eame si 'a' est pr\u00e9sent \\(3\\) fois dans le texte).</p> <p>D\u00e9fintion</p> <p>Un Arbre de Huffman est un arbre binaire entier \u00e9tiquet\u00e9 par des tuples (caract\u00e8re, fr\u00e9quence).</p> <p>Les n\u0153uds internes ont pour \u00e9tiquette (\\('\\backslash 0'\\),\\(f_g + f_d\\)) o\u00f9 \\(f_g\\) repr\u00e9sente la fr\u00e9quence du fils gauche et \\(f_d\\) celle du fils droit.</p> <p>Remarques</p> <ul> <li>La fr\u00e9quence d'un arbre est le second membre de l'\u00e9tiquette de sa racine. Le caract\u00e8re d'un arbre est le premier membre de l'\u00e9tiquette de sa racine.</li> <li>Les caract\u00e8res des n\u0153uds internes n'ont pas de signification particuli\u00e8re (on choisit donc \\('\\backslash 0'\\) par pure convention).</li> <li>Les caract\u00e8res des feuilles sont exactement les caract\u00e8res diff\u00e9rents du texte.</li> <li>Pour des raisons de place, on ne repr\u00e9sente pas le caract\u00e8re des n\u0153uds internes dans les repr\u00e9sentations graphiques qui suivent.</li> </ul>"},{"location":"Textes/2-Huffman/#frequence-et-effectif","title":"Fr\u00e9quence et effectif","text":"<p>D\u00e9fintion</p> <p>La fr\u00e9quence d'un caract\u00e8re est proportionnelle \u00e0 l'effectif de ce m\u00eame caract\u00e8re dans le texte \\((N \u00d7f_c = n_c)\\).</p> <p>Pour des raisons de place, plut\u00f4t que de manipuler des fr\u00e9quences (repr\u00e9sent\u00e9es par des float), on pr\u00e9f\u00e8re utiliser des effectifs (qui sont entiers).</p>"},{"location":"Textes/2-Huffman/#assemblage","title":"Assemblage","text":"<p>L'assemblage de deux arbres \\(A = (G_A,(c_A,f_A),D_A)\\) et \\(B = (G_B ,(c_B ,f_B ),D_B )\\) est l'arbre \\((A,(\\backslash 0,f_A + f_B ),B )\\)</p> <p>Example</p> <p><p>L'assemblage de  et  est</p> <p></p></p>"},{"location":"Textes/2-Huffman/#algorithme","title":"Algorithme","text":""},{"location":"Textes/2-Huffman/#construction-de-larbre","title":"Construction de l'arbre","text":"<p>Listing 1 \u2013 Construction de l'arbre de Huffman</p> <pre><code>fonction huffman_tree (T : texte )\n    recuperer le tableau des frequences des caracteres de T\n    F := foret vide /\u2217 foret des arbres de Huffman \u2217/\n    pour chaque caractere x de T\n        ajouter l'arbre feuille ( x , frequence de x) a F\n    tant que F a au moins deux arbres\n        enlever les 2 arbres de plus petites frequences de F\n        assembler ces 2 arbres\n        ajouter cet assemblage a F\n        /\u2217F a un arbre de moins qu'au tour d'avant \u2217/\n    renvoyer l'unique element de F\n</code></pre> <p>En pratique, la for\u00eat est une file de priorit\u00e9 d'arbres de Huffman organis\u00e9e selon la fr\u00e9quence des racines (tas-min).</p>"},{"location":"Textes/2-Huffman/#encodage-du-texte","title":"Encodage du texte","text":"<p>Listing 2 \u2013 Encodage du texte</p> <pre><code>fonction encoder (T : texte)\n    H := huffman (T)\n    dico := dictionnaire vide /\u2217encodage des caracteres de T\u2217/\n    pour chaque feuille f de H\n        path := chemin depuis la racine de H vers f\n        /\u2217 path sous forme de sequences de 0 (gauche) et 1 (droite) \u2217/\n        ajouter a dico l'association (caractere de f, path)\n    sq := sequence de bits vide /\u2217encodage du texte \u2217/\n    pour chaque caractere x de T\n        p := dico[x] /\u2217 encodage de x \u2217/\n        ajouter p a sq\n    renvoyer sq\n</code></pre>"},{"location":"Textes/2-Huffman/#exemple","title":"Exemple","text":"<p>\u00c0 partir du texte \" satisfaisant \" :</p> <ul> <li> <p>For\u00eat d'arbres feuilles <p></p></p> </li> <li> <p>Assemblage de f et n <p></p></p> </li> <li> <p>Assemblage de i et t <p></p></p> </li> <li> <p>Assemblage d'arbres de fr\u00e9quences \\(2\\) et \\(3\\) <p></p></p> </li> <li> <p>Assemblage d'arbres de fr\u00e9quences \\(4\\) et \\(3\\) <p></p></p> </li> <li> <p>Assemblage d'arbres de fr\u00e9quences \\(5\\) et \\(7\\) <p></p></p> </li> </ul> <p>La for\u00eat ne contient plus qu'un seul arbre : on s'arr\u00eate l\u00e0 .</p> <p>L'algorithme impose que les chemins soient de longueur au moins \\(1\\) : le code correspondant au chemin ne doit pas \u00eatre la cha\u00eene vide. Si le texte a un seul caract\u00e8re, on peut y ajouter un caract\u00e8re fictif pour remplir cette condition.</p>"},{"location":"Textes/2-Huffman/#decoder","title":"D\u00e9coder","text":"<p>On utilise le texte encod\u00e9 et l'arbre de Huffman</p> <pre><code>fonction decode (T; H)\n    entree : T texte encod\u00e9; H arbre de Huffman\n    sortie : T' texte d\u00e9cod\u00e9\n    T' \u2190 texte vide\n    fonction aux (i, N)\n        entree : i position courante; N noeud courant\n        debut\n            si i &lt; |T|\n                si N est une feuille\n                    ajouter le caract\u00e8re de N \u00e0 T'\n                    aux (i+1, H)\n                sinon\n                    si Ti = 0\n                        aux (i+1, fils gauche de N)\n                    sinon /\u2217 Ti vaut 1 \u2217/\n                        aux (i+1, fils droit de N)\n        fin\n    aux (0, H)\n    renvoyer T' \n</code></pre>"},{"location":"Textes/2-Huffman/#analyse","title":"Analyse","text":""},{"location":"Textes/2-Huffman/#correction","title":"Correction","text":""},{"location":"Textes/2-Huffman/#convention-et-proposition","title":"Convention et proposition","text":"<p>Convention : \\(N\\) nombre de caract\u00e8res du texte ; \\(c_i\\) caract\u00e8re en position \\(i\\) du texte ; \\(n_i\\) nombre d'occurrences du caract\u00e8re \\(c_i\\) ; \\(f_i\\) fr\u00e9quence du caract\u00e8re \\(c_i\\) : \\(f_i = \\frac{n_i}{N}\\).</p> <p>On va montrer la propri\u00e9t\u00e9 :</p> <p>Soit \\(T\\) un arbre de Huffman dont les feuilles sont les caract\u00e8res du texte. On appelle poids de \\(T\\) et note \\(S_T = \\sum_{i\u2208feuilles(T)}{f_i \\times d_i}\\)  O\u00f9 \\(d_i\\) est la profondeur du caract\u00e8re \\(c_i\\) dans \\(T\\) , (c'est aussi la longueur du code du caract\u00e8re \\(c_i\\) dans le texte compress\u00e9).</p> <p>L'arbre \\(H\\) construit par l'algorithme de Huffman a le plus petit poids parmi les arbres de Huffman dont les feuilles sont les caract\u00e8res du texte : \\(S_H \u2264 S_T\\) pour tout autre arbre de Huffman \\(T\\) de m\u00eames lettres.</p> <p>\\(S_T\\) est appel\u00e9 poids (ou encore \u00e9valuation) de l'arbre \\(T\\) .</p>"},{"location":"Textes/2-Huffman/#longueur-du-codage","title":"Longueur du codage","text":"<p>On observe que \\(N \u00d7 S_T = N \u00d7 \\sum_{i\u2208feuilles(T)}{f_i\\times d_i} = \\sum_{i\u2208feuilles(T)}{n_i\\times d_i}\\)</p> <p>Cette quantit\u00e9 est la somme de toutes les longueurs des chemins allant de la racine aux feuilles pond\u00e9r\u00e9e par l'effectif.</p> <p>Or, chaque feuille \\(i\\) correspond \u00e0 une unique lettre \\(l(i)\\) du texte. Et la profondeur \\(d_i\\) est la taille du code de \\(l(i)\\) \\(N \u00d7 S_T = \\sum_{i\u2208feuilles(T)}{n_i\\times |code(l(i))|} = \\sum_{i\u2208feuilles(T)}{n_c\\times |code(c)|}\\)</p> <p>La quantit\u00e9 \\(NS_T\\) est donc la taille du texte compress\u00e9! La propri\u00e9t\u00e9 du transparent pr\u00e9c\u00e9dent, nous indique donc que le texte compress\u00e9 par Huffman est le meilleur possible (parmi les compressions effectu\u00e9es par remplacement de symboles).</p>"},{"location":"Textes/2-Huffman/#idee-de-la-preuve-par-recurrence","title":"Id\u00e9e de la preuve par r\u00e9currence","text":"<p>Par r\u00e9currence sur le nombre de caract\u00e8res.</p> <ul> <li>S'il n'y a que deux caract\u00e8res, il n'y a que deux arbres entiers possibles \u00e0 deux feuilles et ces deux arbres ont la m\u00eame somme \\(S\\). L'algorithme de Huffman produit l'un de ces deux arbres : il a donc une somme minimale.</li> <li>H\u00e9r\u00e9dit\u00e9 : On suppose que si le nombre de caract\u00e8res est \\(n \u22652\\), alors l'arbre de Huffamn \\(H\\) est optimal.</li> <li>Consid\u00e9rons un texte \u00e0 \\(n + 1\\) caract\u00e8res, \\(H\\) l'arbre construit par l'algorithme de Huffman et \\(T_0\\) un arbre de Huffman construit avec les m\u00eames caract\u00e8res tel que \\(S_H &gt; S_{T_0}\\) .</li> <li>Soient \\(x ,y\\) les \\(2\\) premiers caract\u00e8res du texte \"assembl\u00e9s\" par l'algorithme. Alors \\(x\\) et \\(y\\) sont fils d'un m\u00eame n\u0153ud \\(((x ,f_x ),f_x + f_y ,(y ,f_y ))\\) dans l'arbre \\(H\\). Et \\(x ,y\\) ont les deux plus petites fr\u00e9quences parmi les caract\u00e8res du texte : la somme \\(f_x + f_y\\) est minimale parmi les sommes de fr\u00e9quences de deux caract\u00e8res</li> <li>Dans l'arbre \\(T_0\\), si \\(x\\) (resp. \\(y\\)) n'est pas \u00e0 la profondeur maximale, on peut l'\u00e9changer avec une feuille \\(z\\) de profondeur maximale. On a \\(d_z &gt; d_x\\) et \\(f_z \u2265f_x\\) . Le delta des contributions de \\(x\\) et \\(z\\) \u00e0 la somme totale est \\(d_z f_x + d_x f_z \u2212d_x f_x \u2212d_z f_z = (d_z \u2212d_x )(f_x \u2212f_z ) \u22640\\) Le nouvel arbre a une somme plus petite que le pr\u00e9c\u00e9dent.</li> <li>On fait de m\u00eame avec \\(y\\) . Dans l'arbre \\(T_1\\) ainsi construit on a \\(S_{T_1} \u2264 S_{T_0}\\) . Avec cette op\u00e9ration \\(x ,y\\) sont maintenant \u00e0 la profondeur maximale de \\(T_1\\).</li> <li> <p>De m\u00eame, si \\(x\\) et \\(y\\) ne sont pas fils d'un m\u00eame n\u0153ud de \\(T_1\\), on peut les \u00e9changer avec d'autres feuilles de profondeur maximale pour que ce soit le cas. Avec cette op\u00e9ration, l'arbre \\(T_2\\) construit v\u00e9rifie \\(S_{T_2} \u2264 S_{T_1} \u2264 S_{T_0} &lt; S_H\\) .</p> </li> <li> <p>Supprimons dans \\(T_2\\) et \\(H\\) le n\u0153ud interne p\u00e8re de \\(x ,y\\) et rempla\u00e7ons le par une feuille \\((y ,f_x + f_y )\\). On obtient deux arbres \\(T'\\) et \\(H'\\) tels que  \\(S_{T'} = S_{T_2} \u2212(f_x + f_y ) \u2264S_{T_0} \u2212(f_x + f_y ) &lt; S_H \u2212(f_x + f_y ) = S_{H'}\\).  En effet, la distance de \\(x\\) et de \\(y\\) \u00e0 la racine dans \\(T_2\\) est incr\u00e9ment\u00e9 de \\(1\\) par rapport \u00e0 celle de \\(y\\) \u00e0 la racine dans \\(T'\\). idem pour \\(H'\\).</p> </li> <li>Dans le texte on remplace toute occurrence de \\(x\\) par \\(y\\) (donc \\(y\\) est de freq. \\(f1 + f2\\)). Alors \\(H'\\) est l'arbre de Huffman obtenu pour le nouveau texte (c'est l'id\u00e9e, il reste du travail pour en \u00eatre s\u00fbr). Comme ce texte n'a que \\(n\\) caract\u00e8res, on a : \\(\\color{red}{S_{T'} \u2265S_{H'}} \\color{red}{\\text{ par HR. Contradiction avec }}\\color{red}{ S_{T'} &lt; S_{H'}}\\).</li> </ul>"},{"location":"Textes/2-Huffman/#arbres-non-entiers","title":"Arbres non entiers","text":"<p>Nous avons impos\u00e9 que les arbres de Huffman soient entiers et nous avons montr\u00e9 qu'un arbre entier construit par l'algorithme est optimal.</p> <p>On peut se demander s'il est int\u00e9ressant d'\u00e9largir la notion : consid\u00e9rons, sans rien changer d'autre \u00e0 la d\u00e9finition, que l'arbre vide est un arbre de Huffman de fr\u00e9quence z\u00e9ro. Les n\u0153uds internes peuvent ainsi avoir un ou deux fils.</p> <p>On peut montrer (en exo ?) que si un tel arbre est non entier, alors il existe toujours un arbre entier de m\u00eames feuilles (c.a.d de m\u00eames lettres) de poids plus petit.</p> <p>Donc l'arbre de Hufman construit par l'algorithme, qui est entier, a encore le plus petits poids parmi ces nouveaux arbres.</p>"},{"location":"Textes/2-Huffman/#complexite","title":"Complexit\u00e9","text":""},{"location":"Textes/2-Huffman/#conventions","title":"Conventions","text":"<p>\\(N\\) taille du texte ; \\(M\\) nombre de caract\u00e8res diff\u00e9rents ; \\(C\\) nombre de bits du r\u00e9sultat de la compression.</p> <p>Calcul des fr\u00e9quences en \\(O(N)\\).</p> <p>Construction de l'arbre de Huffman : on construit une file de priorit\u00e9 d'arbres-feuilles (file de taille \\(M\\)) en \\(O(M)\\). Chaque retrait de deux arbres puis ajout de l'arbre assembl\u00e9 est en \\(O (3\\times log(M))\\). Donc co\u00fbt de construction de l'arbre en \\(O (M\\times log(M))\\).</p>"},{"location":"Textes/2-Huffman/#calcul-de-la-complexite","title":"Calcul de la complexit\u00e9","text":"<p>Construction du dictionnaire (caract\u00e8re,code) : L'arbre (entier) construit contient \\(M\\) feuilles et \\(M \u22121\\) n\u0153uds internes.</p> <ul> <li>On g\u00e8re un accumulateur en lui ajoutant un \\(0\\) (resp. \\(1\\)) \u00e0 chaque virage \u00e0 gauche (resp. droite) lors d'un DFS : chaque arriv\u00e9 \u00e0 une feuille est l'occasion d'ins\u00e9rer une nouvelle association dans le dictionnaire.</li> <li>Il y a \\(2M \u22121\\) (c.a.d. nombre de n\u0153uds) \u00e9critures dans l'accumulateur. La transformation des valeurs de l'accumulateur en String a le c\u00f4ut de la somme des longueurs des branches, donc au minimum  \\(\u03a9(M\\times log_2(M))\\) qu'on peut majorer en \\(O(M^2)\\) (il y a \\(M\\) branches, chacun occasionnant un co\u00fbt en \\(O(M)\\)). L'ajout de chaque code au dictionnaire se faite avec un co\u00fbt amorti constant. Au total : \\(O(M^2)\\) pour le dictionnaire.</li> </ul> <p>Co\u00fbt de cette \u00e9tape \\(O(M^2)\\)</p> <ul> <li>Enfin, la compression du texte fait grossir un tableau redimensionnable et consulte le dictionnaire \u00e0 chaque caract\u00e8re lu du texte (co\u00fbt amorti \\(O(1)\\) pour chacun des \\(N\\) caract\u00e8res). \\(\\color{red}{\\text{Au total }}\\color{red}{O(N + M\\times log(M) + M^2 + N) = O(N + M^2)}.\\)</li> </ul>"},{"location":"Textes/2-Huffman/#complexite-de-la-decompression","title":"Complexit\u00e9 de la d\u00e9compression","text":"<p>La d\u00e9compression est aussi en \\(O(C)\\) (lorsqu'on dispose de l'arbre ; que l'on doit donc joindre au fichier compress\u00e9).</p>"},{"location":"Textes/3-LZW/","title":"LZW","text":"<p>Warning</p> <p>Ce cours a \u00e9t\u00e9 automatiquement traduit des transparents de M.Noyer par Lorentzo et Elowan et mis en forme par Mehdi, nous ne nous accordons en aucun cas son travail, ce site \u00e0 pour seul but d\u2019\u00eatre plus compr\u00e9hensible pendant les p\u00e9riodes de r\u00e9vision que des diaporamas.</p> <p>Cr\u00e9dits</p> <ul> <li>Un cours de Marc de Falco.  </li> <li>Wikipedia </li> <li>Informatique -Cours et exercices corrig\u00e9s- (MP2I-MPI) (ellipse)  </li> </ul>"},{"location":"Textes/3-LZW/#compression","title":"Compression","text":""},{"location":"Textes/3-LZW/#presentation","title":"Pr\u00e9sentation","text":"<p>L\u2019algorithme de Lempel-Ziv-Welch (LZW) est un algorithme de  compression de donn\u00e9es sans perte.  </p> <p>Ses inventeurs sont Abraham Lempel, Jakob Ziv qui l\u2019ont propos\u00e9 en \\(1977\\) et Terry Welch qui l\u2019a finalis\u00e9 en \\(1984\\).  </p> <p>LZW a \u00e9t\u00e9 utilis\u00e9 dans des modems aujourd\u2019hui obsol\u00e8tes mais on le  trouve encore dans la compression des images \"\\(GIFF\\)\" ou  \"\\(TIFF\\)\" et les fichiers audio \"\\(MOD\\)\". Il est \u00e0 la base de la compression \"\\(ZIP\\)\".  </p> <p>Facile \u00e0 coder (c\u2019est son principal avantage) il n\u2019est souvent pas  optimal car il n\u2019e\ufb00ectue qu\u2019une analyse sommaire des donn\u00e9es \u00e0  compresser.  </p>"},{"location":"Textes/3-LZW/#principe","title":"Principe","text":"<p>Recherche dans le texte \u00e0 compresser des r\u00e9p\u00e9titions de sous-cha\u00eenes  identiques et leur donner une forme compacte dans le texte compress\u00e9.</p> <p>L\u2019algorithme LZW proc\u00e8de en une seule passe, en maintenant, au fur  et \u00e0 mesure de la compression, l\u2019ensemble des factiers qu\u2019il a d\u00e9j\u00e0  rencontr\u00e9s.</p> <p>Cette caract\u00e9ristique est adapt\u00e9e \u00e0 la compression d\u2019un texte qu\u2019on  d\u00e9couvre \u00e0 la vol\u00e9e comme lorsque le texte est transmis via un canal  de communication.</p>"},{"location":"Textes/3-LZW/#prefixe-suffixe","title":"Pr\u00e9fixe, su\ufb03xe","text":"<p>D\u00e9finition : Pr\u00e9fixe / Suffixe</p> <ul> <li>Le mot \\(x\\) est appel\u00e9 un pr\u00e9fixe du mot \\(m\\) si il existe un mot \\(y\\) tel que  \\(m = x \u00b7 y\\) .  </li> <li>Le mot \\(x\\) est appel\u00e9 un su\ufb03xe du mot \\(m\\) si il existe un mot \\(y\\) tel que  \\(m = y \u00b7 x\\).  </li> </ul> <p>Exemple</p> <ul> <li>\\(\\varepsilon\\), langage et lang sont des pr\u00e9fixes de langage,  </li> <li>\\(\\varepsilon\\), langage et gage sont des su\ufb03xes de langage,  </li> <li>Si \\(xu = m\\) et \\(xv = m\\) alors, par r\u00e9gularit\u00e9, \\(u = v\\) .  </li> </ul>"},{"location":"Textes/3-LZW/#facteurs","title":"Facteurs","text":"<p>D\u00e9finition : facteur</p> <p>On dit qu\u2019un mot \\(x\\) est facteur d\u2019un mot \\(m\\) s\u2019il existe \\(u\\), \\(v\\) , deux mots tels que \\(m = uxv\\).</p> <p>Exemple</p> <p>Le mot sol est facteur de insolent. La cha\u00eene vide \\(\\varepsilon\\) est un pr\u00e9fixe de tout mot.</p> <p>Pour plus d\u2019informations sur la th\u00e9orie des mots, voir par exemple ce cours.  </p>"},{"location":"Textes/3-LZW/#table-des-correspondances-facteursencodage","title":"Table des correspondances facteurs/encodage","text":"<p>L\u2019algorithme de compression construit une table de traduction des  facteurs du texte en parcourant le texte \u00e0 compresser.</p> <p>Cette table relie des codes de taille (le plus souvent) fix\u00e9e  (g\u00e9n\u00e9ralement \u00e0 \\(12\\) bits) aux cha\u00eenes de caract\u00e8res. Certaines  impl\u00e9mentations avec taille d\u2019encodage variable existent aussi.</p> <p>La table est initialis\u00e9e avec tous les caract\u00e8res (\\(256\\) entr\u00e9es dans le  cas de caract\u00e8res cod\u00e9s sur \\(8\\) bits). C\u2019est une injection qui associe une  valeur num\u00e9rique \u00e0 tout caract\u00e8re de l\u2019alphabet.</p> <p>Il est malin d\u2019utiliser un dictionnaire (facteur, encodage). Les seules  cl\u00e9s du dictionnaires qui ne sont pas des facteurs du texte sont les  caract\u00e8res de l\u2019alphabet non utilis\u00e9s par le texte.</p> <p>L\u2019algorithme LZW exploite et modifie \u00e0 la vol\u00e9e le dictionnaire des facteurs. Il renvoie une liste de cl\u00e9s de ce dictionnaire (c\u2019est \u00e0 dire une  liste d\u2019entiers), chacune codant un facteur du texte.</p>"},{"location":"Textes/3-LZW/#algorithme-de-compression","title":"Algorithme de compression","text":"<pre><code>/\u2217 L\u2019alphabet \u03a3 est suppos\u00e9 connu \u2217/\nfonction lzw_compress (t : texte):\n    initialiser d avec \u03a3 /\u2217 dictionnaire(facteur, code) \u2217/\n    w \u2190 \u03b5 ; /\u2217 le facteur courant \u2217/\n    t' \u2190 \u03b5 ; /\u2217 le texte compress\u00e9 \u2217/\n    n \u2190 |\u03a3| ; /\u2217 nombre de facteurs d\u00e9j\u00e0 compress\u00e9s \u2217/\n    tant que t n\u2019est pas vide faire:\n        c \u2190 t[0] ; /\u2217 1ere lettre de t \u2217/\n        t \u2190 t[1:] /\u2217 supprimer la 1ere lettre de t \u2217/\n        p \u2190 w + c ; /\u2217 ajouter une lettre \u00e0 w \u2217/\n        si p est une cl\u00e9 de d :\n            w \u2190 p;\n        sinon :\n            d[p] \u2190 n ; /\u2217 ajouter l\u2019association (p, n)\u2217/\n            n++;/\u2217 incr\u00e9menter le nb de code enregistr\u00e9s \u2217/\n            /\u2217 rqe : n = |d| : nb de cl\u00e9s dans le dico \u2217/\n            t' \u2190 t' + d[w] ; /\u2217 ajouter le code de w \u00e0 t' \u2217/\n            w \u2190 c;\n    t' \u2190 t' + d[w];\n    renvoyer t'\n</code></pre> Exemple (Wikipedia) <p>On veut compresser \u201dTOBEORNOTTOBEORTOBEORNOT\u201d.</p> <ul> <li>Initialisation de \\(d\\) : \\((A :65)\\) ... \\((T :84)\\), \\((O :79)\\), \\((B :66)\\), \\((E :69)\\),  \\((R :82)\\), \\((N :78)\\) ... \\((Z :90)\\) ... \\((\\backslash 255,255)\\) et \\(t'\\leftarrow \\varepsilon\\) (texte compress\u00e9)</li> <li>Position \\(0\\) : \\(T\\) est une cl\u00e9 mais pas \\(TO\\). \\(d[TO] \\leftarrow 255 + 1 = 256\\),  \\(t' \\leftarrow 84\\) </li> <li>Position \\(1\\) :\\(O\\) est une cl\u00e9 mais pas \\(OB\\). \\(d[OB] \\leftarrow 257\\), \\(t' \\leftarrow 84, 79\\)</li> <li>Position \\(2\\) : \\(B\\) est une cl\u00e9 mais pas \\(BE\\). \\(d[BE] \\leftarrow 258\\), \\(t' \\leftarrow 84, 79, 66\\) </li> <li>Position \\(3\\) : \\(E\\) est une cl\u00e9 mais pas \\(EO\\). \\(d[EO] \\leftarrow 259\\), \\(t' \\leftarrow 84\\), \\(79\\), \\(66\\), \\(69\\) </li> <li>Position \\(4\\) : \\(O\\) est une cl\u00e9 mais pas \\(OR\\). \\(d[OR] \\leftarrow 260\\),  \\(t' \\leftarrow 84\\), \\(79\\), \\(66\\), \\(69\\), \\(82\\)</li> <li>Position \\(5\\) : \\(R\\) est une cl\u00e9 mais pas \\(RN\\). \\(d[RN] \\leftarrow 261\\), \\(t' \\leftarrow\\) \\(84\\), \\(79\\), \\(66\\), \\(69\\), \\(82\\), \\(78\\) </li> <li> <p>La derni\u00e8re lettre du dernier facteur ajout\u00e9 est la premi\u00e8re du nouveau facteur parcouru.  </p> </li> <li> <p>Position \\(6\\) : \\(N\\) est une cl\u00e9 mais pas \\(NO\\). \\(d[NO] \\leftarrow 262\\),  \\(t' \\leftarrow\\) \\(84\\), \\(79\\), \\(66\\), \\(69\\), \\(82\\), \\(78\\), \\(79\\)</p> </li> <li>Position \\(7\\) : \\(O\\) est une cl\u00e9 mais pas \\(OT\\). \\(d[OT] \\leftarrow 263\\),  \\(t' \\leftarrow\\) \\(84\\), \\(79\\), \\(66\\), \\(69\\), \\(82\\), \\(78\\), \\(79\\), \\(84\\)</li> <li>Position \\(8\\) : \\(T\\) est une cl\u00e9 mais pas \\(TT\\). \\(d[TT] \\leftarrow 264\\),  \\(t' \\leftarrow\\) \\(84\\), \\(79\\), \\(66\\), \\(69\\), \\(82\\), \\(78\\), \\(79\\), \\(84\\), \\(84\\)</li> <li>Position \\(9\\) : \\(T, TO\\) sont des cl\u00e9s mais pas \\(TOB\\). \\(d[TOB] \\leftarrow 265\\),  \\(t' \\leftarrow\\) \\(84\\), \\(79\\), \\(66\\), \\(69\\), \\(82\\), \\(78\\), \\(79\\), \\(84\\), \\(84\\), \\(256\\)</li> <li>Position \\(11\\) : \\(B, BE\\) sont des cl\u00e9s mais pas \\(BEO\\). \\(d[BEO] \\leftarrow 266\\),  \\(t' \\leftarrow\\) \\(84\\), \\(79\\), \\(66\\), \\(69\\), \\(82\\), \\(78\\), \\(79\\), \\(84\\), \\(84\\), \\(256\\), \\(258\\)</li> <li>Position \\(13\\) : \\(O\\), \\(OR\\) sont des cl\u00e9s mais pas \\(ORT\\). \\(d[ORT] \\leftarrow 267\\),  \\(t' \\leftarrow\\) \\(84\\), \\(79\\), \\(66\\), \\(69\\), \\(82\\), \\(78\\), \\(79\\), \\(84\\), \\(84\\), \\(256\\), \\(258\\), \\(260\\) </li> <li>Position \\(15\\) : \\(T,TO,TOB\\) sont des cl\u00e9s mais pas \\(TOBE\\). \\(d[TOBE] \\leftarrow 268\\),  \\(t' \\leftarrow\\) \\(84\\), \\(79\\), \\(66\\), \\(69\\), \\(82\\), \\(78\\), \\(79\\), \\(84\\), \\(84\\), \\(256\\), \\(258\\), \\(260\\), \\(265\\)</li> <li>Position \\(18\\) : \\(E,EO\\) sont des cl\u00e9s mais pas \\(EOR\\). \\(d[EOR]\\leftarrow 269\\),  \\(t' \\leftarrow\\) \\(84\\), \\(79\\), \\(66\\), \\(69\\), \\(82\\), \\(78\\), \\(79\\), \\(84\\), \\(84\\), \\(256\\), \\(258\\), \\(260\\), \\(265\\), \\(259\\) </li> <li>Position \\(20\\) : \\(R,RN\\) sont des cl\u00e9s mais pas \\(RNO\\). \\(d[RNO] \\leftarrow 270\\),  \\(t' \\leftarrow\\) \\(84\\), \\(79\\), \\(66\\), \\(69\\), \\(82\\), \\(78\\), \\(79\\), \\(84\\), \\(84\\), \\(256\\), \\(258\\), \\(260\\), \\(265\\), \\(259\\), \\(261\\) </li> <li>Position \\(22\\) \u00e0 fin : \\(O,OT\\) sont des cl\u00e9s.  \\(t' \\leftarrow\\) \\(84\\), \\(79\\), \\(66\\), \\(69\\), \\(82\\), \\(78\\), \\(79\\), \\(84\\), \\(84\\), \\(256\\), \\(258\\), \\(260\\), \\(265\\), \\(259\\), \\(261\\), \\(263\\) </li> </ul> <p>Exercice</p> <p>Faire la compression du mot suivant \"AABABAAA\" avec le dictionnaire \\(d\\) suivant : \\(d\\) : \\((A :0)\\), \\((B :1)\\)</p> <p>Correction</p> <ul> <li>Position \\(0\\) : \\(A\\) est une cl\u00e9 mais pas \\(AA\\) donc \\(d[AA] \u27f5 2\\), \\(t' \u27f5 0\\)</li> <li>Position \\(1\\) : \\(A\\) est une cl\u00e9 mais pas \\(AB\\) donc \\(d[AB] \u27f5 3\\), \\(t' \u27f5 0, 0\\)</li> <li>Position \\(2\\) : \\(B\\) est une cl\u00e9 mais pas \\(BA\\) donc \\(d[BA] \u27f5 4\\), \\(t' \u27f5 0, 0, 1\\)</li> <li>Position \\(3\\) : \\(A, AB\\) sont des cl\u00e9s mais pas \\(ABA\\) donc \\(d[ABA] \u27f5 5\\), \\(t' \u27f5 0, 0, 1, 3\\)</li> <li>Position \\(5\\) : \\(A, AA\\) sont des cl\u00e9s mais pas \\(AAA\\) donc \\(d[AAA] \u27f5 6\\), \\(t' \u27f5 0, 0, 1, 3, 2, 0\\) </li> </ul>"},{"location":"Textes/3-LZW/#decompression","title":"D\u00e9compression","text":""},{"location":"Textes/3-LZW/#initialisation","title":"Initialisation","text":"<p>On note \\(d\\) le dictionnaire (code,facteur) qui est l\u2019inverse de celui de la partie pr\u00e9c\u00e9dente (en fait, puisque l\u2019ensemble des codes forme un  intervalle de nombres, un simple tableau redimensionnable suffit).</p> <p>Ce dictionnaire est initialis\u00e9 ainsi : \u00e0 tous les codes entre (par exemple \\(0\\) et \\(256\\)) on associe la lettre correspondante de l\u2019alphabet.</p> <p>La notation \\(|d|\\) d\u00e9signe le nombre d\u2019associations d\u00e9j\u00e0 entr\u00e9es. Avec le  code ASCII, \\(|d| = 256\\) au d\u00e9part.</p> <p>Le premier code \\(c\\) lu est n\u00e9cessairement celui d\u2019un unique caract\u00e8re.  On \u00e9crit donc \\(d[c]\\) dans le fichier de sortie et on garde \\(c\\) en m\u00e9moire.  </p>"},{"location":"Textes/3-LZW/#deroulement","title":"D\u00e9roulement","text":""},{"location":"Textes/3-LZW/#cas-facile-on-lit-un-code-connu","title":"Cas facile : on lit un code connu","text":"<p>On garde en m\u00e9moire le pr\u00e9c\u00e9dent code lu \\(c\\). On lit un code \\(n\\) o\u00f9 \\(n &lt; |d|\\) (ce qui signifie qu\u2019on sait ce que code \\(n\\)).  </p> <ul> <li>Posons \\(d[n] = xm'\\) ; \\(x\\) est un caract\u00e8re et \\(m'\\) un mot.</li> <li>On \u00e9crit \\(xm'\\) dans le fichier de sortie  </li> <li>On rajoute ensuite un nouvel \u00e9l\u00e9ment \\(mx\\) dans le dictionnaire o\u00f9 \\(m = d[c]\\). On pose donc \\(d[|d|] = mx\\).  </li> </ul>"},{"location":"Textes/3-LZW/#cas-facile-pourquoi-cela-marche-t-il","title":"Cas facile : Pourquoi cela marche-t-il ?","text":"<p>On reproduit en fait le processus de compression mais en remplissant le dictionnaire avec un temps de retard.  </p> <p>Selon le principe de compression :  </p> <ul> <li>On ajoute une entr\u00e9e au dictionnaire pour \\(mx\\) quand on lit \\(x\\) et que le pr\u00e9c\u00e9dent motif lu est \\(m\\).  </li> <li>Le code \\(c\\) de \\(m\\) (qui est connu, sinon on ne serait pas arriv\u00e9 \u00e0 \\(x\\)) est ajout\u00e9 au texte cod\u00e9. \\(\\color{red}\\text{Dans la d\u00e9compression, quand on lit } c \\text{, on ajoute } m\\)</li> <li>On repart alors avec \\(x\\) comme motif lu  </li> </ul>"},{"location":"Textes/3-LZW/#cas-problematique-n-d","title":"Cas probl\u00e9matique : n = |d|","text":"<p>Le code \\(n\\) lu est tel que \\(n = |d|\\), donc on lit un code non encore pr\u00e9sent dans la table de d\u00e9compression.</p> <ul> <li>On lit le code \\(n\\) : il a \u00e9t\u00e9 plac\u00e9 \u00e0 cet endroit au moment de la  compression apr\u00e8s avoir lu un \\(wy\\) . Ainsi, \\(n\\) est le code de \\(w\\) .  </li> <li>\\(n\\) est maximal parmi les codes d\u00e9j\u00e0 rencontr\u00e9s. Revenant au moment de la compression, cela signifie que \\(w\\) est le dernier facteur qui a  produit un code avant d\u2019\u00e9crire \\(n\\).  </li> <li>Or, juste avant \\(n\\) dans le texte compress\u00e9, il y a \\(c\\) (lequel code \\(m\\)).  Ainsi \\(w\\) est de la forme \\(mx\\).  </li> <li>Dans la compression, apr\u00e8s avoir lu \\(w = mx\\), on repart de \\(x\\) et on lit \\(wy\\),  c.a.d. \\(mxy\\) . Ainsi, la 1ere lettre de \\(m\\) est \\(x\\) ! (dans le texte originel, on  a donc \\(\\text{... } mmxy \\text{ ...}\\)).  </li> <li>On ajoute \\(mx\\) au texte d\u00e9compress\u00e9 et on r\u00e9alise l\u2019association  \\(d[n] = mx\\).  </li> </ul> <p>\\(n\\) code un \\(wy\\) tel que le code de \\(w\\) est le dernuer lu.</p> <p></p>"},{"location":"Textes/3-LZW/#algorithme-de-decompression","title":"Algorithme de d\u00e9compression","text":"<p>On initialise le dictionnaire avec l\u2019alphabet (par exemple alphabet ASCII des caract\u00e8res cod\u00e9s sur \\(8\\) bits).  La fonction <code>Lire</code> lit le code courant de \\(T'\\) et positionne le curseur sur le code suivant.</p> <pre><code>fonction lzw_decompress (T' : texte compress\u00e9,\n                          d : dictionnaire (code, facteur)):\n    c \u2190 Lire(T'); /\u2217 1er code lu \u2217/\n    /\u2217 le 1er code correspond toujours \u00e0 une lettre \u2217/\n    Ecrire (d[c]); /\u2217 ajouter le texte cod\u00e9 parc \u2217/\n    tant_que il reste un codes de T' non lu faire\n        n \u2190 lire(T'); /\u2217 code courant \u2217/\n        si n est une clef de d /\u2217 code n d\u00e9j\u00e0 rencontr\u00e9 \u2217/\n            alors e \u2190 d[n]; /\u2217 d\u00e9compression \u2217/\n        sinon e \u2190 d[c] \u00b7 d[c][0]; /\u2217 d\u00e9compression , cas n = |d|\u2217/\n        Ecrire e;\n        c \u2190 n;\n        d[|d|] \u2190 d[c] \u00b7 e[0]; /\u2217 ajouter une association \u2217/\n    fin faire\n</code></pre> <p>Exercice</p> <p>Notre dictionnaire de d\u00e9part \\(d\\) est  \\(d\\) : \\((0 :A)\\), \\((1 :B)\\) D\u00e9coder (selon l'algorithme ci-dessus) la suite \\(t'\\) suivante \\(t' \u27f5 0, 0, 1, 3, 2, 0\\)</p> <p>Correction</p> <ul> <li>Position \\(0\\) : \\(0\\) est une cl\u00e9 connue donc \\(t \u27f5 d[0]\\) donc \\(t \u27f5 A\\)</li> <li>Position \\(1\\) : \\(0\\) est une cl\u00e9 connue donc \\(t \u27f5 d[0]\\) donc \\(t \u27f5 A, A\\). On lit la lettre pr\u00e9c\u00e9dente, \\(AA\\) n'est pas une cl\u00e9 du dictionnaire donc on l'ajoute \\(d[2] \u27f5 AA\\).</li> <li>Position \\(2\\) : \\(1\\) est une cl\u00e9 connue donc \\(t \u27f5 d[1]\\) donc \\(t \u27f5 A, A, B\\) On lit la lettre pr\u00e9c\u00e9dente, \\(AB\\) n'est pas une cl\u00e9 du dictionnaire donc on l'ajoute \\(d[3] \u27f5 AB\\)</li> <li>Position \\(3\\) : \\(3\\) est une cl\u00e9 connue donc \\(t \u27f5 d[3]\\) donc \\(t \u27f5 A, A, B, AB\\) On lit la lettre pr\u00e9c\u00e9dente, \\(BA\\) n'est pas une cl\u00e9 du dictionnaire donc on l'ajoute \\(d[4] \u27f5 BA\\)</li> <li>Position \\(4\\) : \\(2\\) est une cl\u00e9 connue donc \\(t \u27f5 d[2]\\) donc \\(t \u27f5 A, A, B, AB, AA\\) On lit la lettre pr\u00e9c\u00e9dente, \\(ABA\\) n'est pas une cl\u00e9 du dictionnaire donc on l'ajoute \\(d[5] \u27f5 ABA\\)</li> <li>Position \\(5\\) : \\(0\\) est une cl\u00e9 connue donc \\(t \u27f5 d[0]\\) donc \\(t \u27f5 A, A, B, AB, AA, A\\) On lit la lettre pr\u00e9c\u00e9dente, \\(AAA\\) n'est pas une cl\u00e9 connue donc on l'ajoute \\(d[6] \u27f5 AAA\\)</li> </ul> <p>\\(t \u27f5 AABABAAA\\)</p> <p>Meilleur Exercice</p> <p>Faire la compression puis d\u00e9compression du tete suivant \"AAABAA\" avec le dictionnaire \\(d\\) suivant : \\(d\\) : \\((A :0)\\), \\((B :1)\\)</p> <p>Correction</p> <p>Compression : \\(d\\) : \\((A :0)\\), \\((B :1)\\)</p> <ul> <li>Position \\(0\\) : \\(A\\) est une cl\u00e9 connue mais pas \\(AA\\) donc \\(d[AA] \u27f5 2\\), \\(t' \u27f5 0\\)</li> <li>Position \\(1\\) : \\(A\\), \\(AA\\) sont des cl\u00e9s connues mais pas \\(AAB\\) donc \\(d[AAB] \u27f5 3\\), \\(t' \u27f5 0, 2\\)</li> <li>Position \\(3\\) : \\(B\\) est une cl\u00e9 connue mais pas \\(BA\\) donc \\(d[BA] \u27f5 4\\), \\(t' \u27f5 0, 2, 1\\)</li> <li>Position \\(4\\) : \\(AA\\) est une cl\u00e9 connue \\(t' \u27f5 0, 2, 1, 2\\) </li> </ul> <p>D\u00e9compression : \\(d\\) : \\((0 :A)\\), \\((1 :B)\\)</p> <ul> <li>Position \\(0\\) : \\(0\\) est une cl\u00e9 connue donc \\(t \u27f5 d[0]\\) donc \\(t \u27f5 A\\)</li> <li>Position \\(1\\) : \\(2\\) n'est pas une cl\u00e9 connue donc on lit la lettre pr\u00e9c\u00e9dente \\(A\\) qui est connue et on l'ajoute \\(d[2] \u27f5 AA\\) donc \\(t \u27f5 d[2]\\) donc \\(t \u27f5 A, AA\\).</li> <li>Position \\(3\\) : \\(1\\) est une cl\u00e9 connue donc \\(t \u27f5 d[1]\\) donc \\(t \u27f5 A, AA, B\\) On lit la lettre pr\u00e9c\u00e9dente, \\(AAB\\) n'est pas une cl\u00e9 connue du dictionnaire donc on l'ajoute \\(d[3] \u27f5 AAB\\)</li> <li>Position \\(4\\) : \\(2\\) est une cl\u00e9 connue donc \\(t \u27f5 d[2]\\) donc \\(t \u27f5 A, AA, B, AA\\) On lit la lettre pr\u00e9c\u00e9dente, \\(BA\\) n'est pas une cl\u00e9 connue du dictionnaire donc on l'ajoute \\(d[4] \u27f5 BA\\)</li> </ul>"},{"location":"Textes/3-LZW/#taille-des-entiers-de-codage","title":"Taille des entiers de codage","text":""},{"location":"Textes/3-LZW/#taille-des-entiers-en-ocaml","title":"Taille des entiers en OCaml","text":"<p>En OCaml, les entiers sont deux bits plus courts que les entiers machines.  Sur la plupart des machines, les entiers sont de taille \\(32\\) ou \\(64\\) bits. \\(\\color{red}\\text{En OCaml, les entiers sont donc de taille 31 ou 63 bits}\\).</p> <p>Or, le premier bit est un bit de signe, les entiers positifs sont donc cod\u00e9s entre \\(0\\) et \\(2^{30} - 1\\) (ou \\(2^{62} -1\\))</p> <p>La repr\u00e9sentation du r\u00e9sultat de la compression par une liste d\u2019entiers  OCAML n\u2019est pas tr\u00e8s r\u00e9aliste : il faudrait a priori \\(30\\) bits (ou \\(62\\)) pour  stocker chaque entier.</p> <p>Cependant, on remarque que la taille des entiers produits par l\u2019algorithme de compression cro\u00eet progressivement au fur et \u00e0 mesure que l\u2019on avance dans la liste (et que le dictionnaire se remplit). </p> <p>Dans la pratique, on peut donc utiliser la technique suivante pour coder la liste :  </p> <ul> <li>Tant que tous les entiers sont strictement inf\u00e9rieurs \u00e0 \\(255\\), coder ces  entiers sur \\(8\\) bits.  </li> <li>Lorsque l\u2019on rencontre le premier entier sup\u00e9rieur ou \u00e9gal \u00e0 \\(255\\),  \u00e9mettre la s\u00e9quence \\(11111111\\) (huit fois le bit \\(1\\)) et continuer, tant  que les entiers sont strictement inf\u00e9rieurs \u00e0 \\(511\\), en codant les entiers sur \\(9\\) bits.  </li> <li>Lorsque l\u2019on rencontre le premier entier sup\u00e9rieur ou \u00e9gal \u00e0 \\(511\\),  \u00e9mettre la s\u00e9quence \\(111111111\\) (neuf fois le bit \\(1\\)) et continuer, tant que les entiers sont strictement inf\u00e9rieurs \u00e0 \\(1023\\), en codant les  entiers sur \\(10\\) bits.  </li> <li>De mani\u00e8re g\u00e9n\u00e9rale, tant que les entiers consid\u00e9r\u00e9s sont strictement  inf\u00e9rieurs \u00e0 \\(n = 2k \u2212 1\\), on peut les repr\u00e9senter sur \\(k\\) bits.  </li> <li>Lorsque le premier entier sup\u00e9rieur ou \u00e9gal \u00e0 \\(2k \u2212 1\\) est rencontr\u00e9, on  \u00e9met la s\u00e9quence \\(1 . . . 1\\) (\\(k\\) fois le bit \\(1\\)) et on continue en codant les entiers sur \\(k + 1\\) bits.  </li> <li>Donc si le code \\(10\\) se trouve au d\u00e9but de la liste des codages, il prend \\(8\\) bits d\u2019espace mais apr\u00e8s le premier nombre plus grand que \\(255\\), il prend \\(9\\) bits etc.  </li> </ul>"}]}